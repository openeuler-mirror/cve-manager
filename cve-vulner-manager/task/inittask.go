package task

import (
	"github.com/astaxie/beego/config"
	"github.com/astaxie/beego/logs"
	"github.com/astaxie/beego/toolbox"
)

//CheckOriCveTask Verify the original cve data
func CheckOriCveTask(oriCveCheck string) {
	logs.Info("The task of verifying the original cve data starts...")
	CheckTask := toolbox.NewTask("CheckOriCve", oriCveCheck, CheckOriCve)
	toolbox.AddTask("CheckOriCve", CheckTask)
	logs.Info("End of verifying original cve data task...")
}

//InitYamlTask Get yaml data source
func InitYamlTask(getYaml string) {
	logs.Info("Get the yaml data source task started...")
	yamlTask := toolbox.NewTask("GetYamlData", getYaml, GetYamlData)
	toolbox.AddTask("GetYamlData", yamlTask)
	logs.Info("End of the task of obtaining yaml data source...")
}

//InitEulerYamlTask Get yaml data source
func InitEulerYamlTask(eulergetymal string) {
	logs.Info("Get the euleryaml data source task started...")
	eulerYamlTask := toolbox.NewTask("GetEulerYamlData", eulergetymal, GetEulerYamlData)
	toolbox.AddTask("GetEulerYamlData", eulerYamlTask)
	logs.Info("End of the task of obtaining euleryaml data source...")
}

//InitCveTask Generate cve original data into cve library
//func InitCveTask(getCve string) {
//	logs.Info("The task of generating cve vulnerability library from cve raw data begins...")
//	CveTask := toolbox.NewTask("ParamsCveOriginData", getCve, ParamsCveOriginData)
//	toolbox.AddTask("ParamsCveOriginData", CveTask)
//	logs.Info("The task of generating cve vulnerability library from cve raw data ends...")
//}

// InitIssueTask Get the created issue data source
func InitIssueTask(getIssue string) {
	logs.Info("Get the created issue data source task starts...")
	issueTask := toolbox.NewTask("GetIssueData", getIssue, GetIssueData)
	toolbox.AddTask("GetIssueData", issueTask)
	logs.Info("End of the task of obtaining the created issue data source...")
}

// InitIssueToken Execute the token acquisition task to start
func InitIssueToken(issueOath string) {
	logs.Info("Execute the token acquisition task to start...")
	TokenTask := toolbox.NewTask("GetGiteeToken", issueOath, GetGiteeToken)
	toolbox.AddTask("GetGiteeToken", TokenTask)
	logs.Info("End of execution of the token acquisition task...")
}

// CreatTask  Execute the create issue task to start
func CreatTask(createIssue string) {
	logs.Info("Execute the create issue task to start...")
	cIssueTask := toolbox.NewTask("CreateIssue", createIssue, CreateIssue)
	toolbox.AddTask("CreateIssue", cIssueTask)
	logs.Info("End of execution of the task of creating an issue...")
}

// Handle the current emergency cve and create an issue
//func EmgCreatTask(emergCreateIssue string) {
//	logs.Info("Handle the current emergency cve and create an issue task to start...")
//	cIssueTask := toolbox.NewTask("EmgCreateIssue", emergCreateIssue, EmgCreateIssue)
//	toolbox.AddTask("EmgCreateIssue", cIssueTask)
//	logs.Info("Handle the current emergency cve and create an issue to end...")
//}

// unlock table
func UnlockTask(unLockTable string) {
	logs.Info("Execute unlock table task start...")
	cUnLockTable := toolbox.NewTask("UnLockTable", unLockTable, UnLockTable)
	toolbox.AddTask("UnLockTable", cUnLockTable)
	logs.Info("End of execution of unlock table task...")
}

// Handling hook events
func ProcHookTask(prochook string) {
	logs.Info("Execute the Hook event task start...")
	cProchook := toolbox.NewTask("ProcHookEvent", prochook, ProcHookEvent)
	toolbox.AddTask("ProcHookEvent", cProchook)
	logs.Info("The execution of the Hook event task ends...")
}

// Create webhooks for all repo
func CreateHookTask(createHook string) {
	logs.Info("Start creating all webhook tasks...")
	createhook := toolbox.NewTask("CreateWebhookEvent", createHook, CreateWebhookEvent)
	toolbox.AddTask("CreateWebhookEvent", createhook)
	logs.Info("End of execution to create all webhook tasks...")
}

//GenSAExcelTask Execute issue to generate excel task start
func GenSAExcelTask(genExcel string) {
	logs.Info("Execute issue to generate excel task start...")
	genExcelTask := toolbox.NewTask("GenExcelData", genExcel, GenExcelData)
	toolbox.AddTask("GenExcelData", genExcelTask)
	logs.Info("Execute issue to generate excel task ends...")
}

// Handling abnormal cve data
func AbnormalCveTask(exceptcve string) {
	logs.Info("Execute abnormal cve task task start...")
	procabnTask := toolbox.NewTask("AbnormalCve", exceptcve, ProcAbnCve)
	toolbox.AddTask("AbnormalCve", procabnTask)
	logs.Info("Execute processing exception cve task task end...")
}

// Generate SA number
func GenerateSaNumberTask(genSa string) {
	logs.Info("Start the task of generating SA number...")
	proSaTask := toolbox.NewTask("GenerateSaNumber", genSa, ProcSaNumber)
	toolbox.AddTask("GenerateSaNumber", proSaTask)
	logs.Info("The task of generating SA number is over...")
}

// issue statistics mailing list
func IssueStstisticsTask(issueStatistic string) {
	logs.Info("Execute issue statistics task start...")
	iStTask := toolbox.NewTask("IssueStatistics", issueStatistic, IssueStatistics)
	toolbox.AddTask("IssueStatistics", iStTask)
	logs.Info("The end of the issue statistics task...")
}

// Cve data email task with low credibility
func cveLowCredTask(cvecredit string) {
	logs.Info("Execute the CVE credibility data feedback task started...")
	iStTask := toolbox.NewTask("ProcCveLowCred", cvecredit, ProcCveLowCred)
	toolbox.AddTask("ProcCveLowCred", iStTask)
	logs.Info("The end of the CVE credibility data feedback task...")
}

// Handling urgent tasks
func UrgentTask(urgenttask string) {
	logs.Info("Handling urgent task started...")
	iStTask := toolbox.NewTask("HandUrgentData", urgenttask, HandUrgentData)
	toolbox.AddTask("HandUrgentData", iStTask)
	logs.Info("The end of the Handling urgent task...")
}

// Add security bulletin link task
func SecurityLinkTask(seclinktask string) {
	logs.Info("Add security bulletin link task started...")
	sEtTask := toolbox.NewTask("ProcSecLinkTemplate", seclinktask, ProcSecLinkTemplate)
	toolbox.AddTask("ProcSecLinkTemplate", sEtTask)
	logs.Info("End of task of adding a link to a security bulletin...")
}

// Verify whether the issue on gitee is deleted, and the data is synchronized
func CheckIssueDel(checkissuedel string) {
	logs.Info("Verify whether the issue on gitee is deleted and the task starts...")
	cHiTask := toolbox.NewTask("CheckIssueIsExist", checkissuedel, CheckIssueIsExist)
	toolbox.AddTask("CheckIssueIsExist", cHiTask)
	logs.Info("Verify whether the issue on gitee is deleted and the task ends...")
}

// Print logs to the console and delete redundant logs
func PrintLogTask(printLog string) {
	logs.Info("Execute log task task start...")
	printLogTask := toolbox.NewTask("ProcLogData", printLog, ProcLogData)
	toolbox.AddTask("ProcLogData", printLogTask)
	logs.Info("Execute log task task end...")
}

//Statistics of issues created in different communities, uncreated issues are created
func IssueCommunityStatistTask(issuecommunity string) {
	logs.Info("Community issue statistics task started...")
	issueStatTask := toolbox.NewTask("CommunityIssueStatist", issuecommunity, CommunityIssueStatist)
	toolbox.AddTask("CommunityIssueStatist", issueStatTask)
	logs.Info("Community issue statistics task is over...")
}

//Check whether the issue label is reasonable
func IssueLabelCheckTask(issuelabelcheck string) {
	issueLaCheckTask := toolbox.NewTask("IssueLabelCheck", issuelabelcheck, IssueLabelCheck)
	toolbox.AddTask("IssueLabelCheck", issueLaCheckTask)
}

func GetV8TokenTask(getv8token string) {
	getTokenTask := toolbox.NewTask("GetV8Token", getv8token, GetV8Token)
	toolbox.AddTask("GetV8Token", getTokenTask)
}

func SetIssueProcDateTask(setissueprocdate string) {
	setIssueDateTask := toolbox.NewTask("SetIssueProcParams", setissueprocdate, SetIssueProcParams)
	toolbox.AddTask("SetIssueProcParams", setIssueDateTask)
}

func ReleaseUnaffetcdCveTask(spec string) {
	toolbox.AddTask("ReleaseUnaffetcdCveTask", toolbox.NewTask("ReleaseUnaffetcdCveTask", spec, ReleaseUnaffectedCve))
}

// start task
func StartTask() {
	toolbox.StartTask()
}

func StopTask() {
	toolbox.StopTask()
}

//InitTask Timing task initialization
func InitTask() bool {
	BConfig, err := config.NewConfig("ini", "conf/app.conf")
	if err != nil {
		logs.Error("config init error: file:conf/app.conf: ", err)
		return false
	}
	// Get the original yaml data
	ymalflag, errxs := BConfig.Int("crontab::ymalflag")
	if ymalflag == 1 && errxs == nil {
		getymal := BConfig.String("crontab::getymal")
		InitYamlTask(getymal)
	}
	// Verify the original cve data
	oricveflag, errxs := BConfig.Int("crontab::oricveflag")
	if oricveflag == 1 && errxs == nil {
		oricvecheck := BConfig.String("crontab::oricvecheck")
		CheckOriCveTask(oricvecheck)
	}
	// Refresh gittoken regularly
	gittokenflag, errx := BConfig.Int("crontab::gittokenflag")
	if gittokenflag == 1 && errx == nil {
		issueoath := BConfig.String("crontab::issueoath")
		// Get token from environment variable
		gitToken := BConfig.String("gitee::git_token")
		if gitToken == "xxx" {
			InitIssueToken(issueoath)
		}
	}
	// Get the created issue
	getissueflag, errxs := BConfig.Int("crontab::getissueflag")
	if getissueflag == 1 && errxs == nil {
		getissue := BConfig.String("crontab::getissue")
		InitIssueTask(getissue)
	}
	// Generate cve vulnerability library
	//cveflag, errxs := BConfig.Int("crontab::cveflag")
	//if cveflag == 1 && errxs == nil {
	//	getcve := BConfig.String("crontab::getcve")
	//	InitCveTask(getcve)
	//}
	// Regularly output logs to the console
	printLogFlag, errxs := BConfig.Int("crontab::printlogflag")
	if printLogFlag == 1 && errxs == nil {
		printLog := BConfig.String("crontab::printlog")
		PrintLogTask(printLog)
	}
	// Add issue
	taskFlag, errx := BConfig.Int("crontab::issueflag")
	if taskFlag == 1 && errx == nil {
		createIssue := BConfig.String("crontab::createissue")
		CreatTask(createIssue)
	}
	// Handle the current emergency cve and create an issue
	//emergissueflag, errx := BConfig.Int("crontab::emergissueflag")
	//if emergissueflag == 1 && errx == nil {
	//	emergCreateIssue := BConfig.String("crontab::emergcreateissue")
	//	EmgCreatTask(emergCreateIssue)
	//}
	// Generate excel data from issue
	genexcelflag, errx := BConfig.Int("crontab::genexcelflag")
	if genexcelflag == 1 && errx == nil {
		genExcel := BConfig.String("crontab::genexcel")
		GenSAExcelTask(genExcel)
	}
	// unlock mysql
	unlockflag, errx := BConfig.Int("crontab::unlockflag")
	if unlockflag == 1 && errx == nil {
		unlock := BConfig.String("crontab::unlock")
		UnlockTask(unlock)
	}
	// Handling hook events
	hookflag, errx := BConfig.Int("crontab::hookflag")
	if hookflag == 1 && errx == nil {
		prochook := BConfig.String("crontab::prochook")
		ProcHookTask(prochook)
	}
	// Create webhooks for all repo
	createHookFlag, errx := BConfig.Int("crontab::createhookflag")
	if createHookFlag == 1 && errx == nil {
		createHook := BConfig.String("crontab::createhook")
		CreateHookTask(createHook)
	}
	// Handling abnormal cve data
	exceptflag, errx := BConfig.Int("crontab::exceptflag")
	if exceptflag == 1 && errx == nil {
		exceptcve := BConfig.String("crontab::exceptcve")
		AbnormalCveTask(exceptcve)
	}
	// Generate SA number
	gensaflag, errx := BConfig.Int("crontab::gensaflag")
	if gensaflag == 1 && errx == nil {
		gensa := BConfig.String("crontab::gensa")
		GenerateSaNumberTask(gensa)
	}
	// issue statistics mailing list
	issuestatisticflag, errx := BConfig.Int("crontab::issuestatisticflag")
	if issuestatisticflag == 1 && errx == nil {
		issueStatistic := BConfig.String("crontab::issuestatistic")
		IssueStstisticsTask(issueStatistic)
	}
	// Cve data email task with low credibility
	cvecredflag, errx := BConfig.Int("crontab::cvecredflag")
	if cvecredflag == 1 && errx == nil {
		cvecredit := BConfig.String("crontab::cvecredit")
		cveLowCredTask(cvecredit)
	}
	// Handling urgent tasks
	urgenttaskflag, errx := BConfig.Int("crontab::urgenttaskflag")
	if urgenttaskflag == 1 && errx == nil {
		urgenttask := BConfig.String("crontab::urgenttask")
		UrgentTask(urgenttask)
	}
	// Add security bulletin link task
	seclinkflag, errx := BConfig.Int("crontab::seclinkflag")
	if seclinkflag == 1 && errx == nil {
		seclinktask := BConfig.String("crontab::seclinktask")
		SecurityLinkTask(seclinktask)
	}
	// Verify whether the issue on gitee is deleted, and the data is synchronized
	checkissuedelflag, errx := BConfig.Int("crontab::checkissuedelflag")
	if checkissuedelflag == 1 && errx == nil {
		checkissuedel := BConfig.String("crontab::checkissuedel")
		CheckIssueDel(checkissuedel)
	}
	// Obtain openEuler data sources from other channels
	eulerymalflag, errxs := BConfig.Int("crontab::eulerymalflag")
	if eulerymalflag == 1 && errxs == nil {
		eulergetymal := BConfig.String("crontab::eulergetymal")
		InitEulerYamlTask(eulergetymal)
	}
	// Statistics of issues created in different communities, uncreated issues are created
	issuecommunityflag, errxs := BConfig.Int("crontab::issuecommunityflag")
	if issuecommunityflag == 1 && errxs == nil {
		issuecommunity := BConfig.String("crontab::issuecommunity")
		IssueCommunityStatistTask(issuecommunity)
	}
	issuelabelcheckflag, errxs := BConfig.Int("crontab::issuelabelcheckflag")
	if issuelabelcheckflag == 1 && errxs == nil {
		issuelabelcheck := BConfig.String("crontab::issuelabelcheck")
		IssueLabelCheckTask(issuelabelcheck)
	}
	// Get v8 token task
	getv8tokenflag, errxs := BConfig.Int("crontab::getv8tokenflag")
	if getv8tokenflag == 1 && errxs == nil {
		getv8token := BConfig.String("crontab::getv8token")
		GetV8TokenTask(getv8token)
	}
	// Set issue processing date
	setissueprocdateflag, errxs := BConfig.Int("crontab::setissueprocdateflag")
	if setissueprocdateflag == 1 && errxs == nil {
		setissueprocdate := BConfig.String("crontab::setissueprocdate")
		SetIssueProcDateTask(setissueprocdate)
	}

	releaseUnaffectedCveFlag, sErr := BConfig.Int("crontab::releaseUnaffectedCveflag")
	if releaseUnaffectedCveFlag == 1 && sErr == nil {
		ReleaseUnaffetcdCveTask(BConfig.String("crontab::releaseUnaffectedCve"))
	}

	return true
}
