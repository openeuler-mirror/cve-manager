package task

import (
	"bytes"
	"encoding/json"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/opensourceways/server-common-lib/utils"

	"cvevulner/common"
	"cvevulner/models"
	"cvevulner/taskhandler"

	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
)

// Verify whether the issue on gitee has been deleted
func CheckIssueIsExist() error {
	defer common.Catchs()
	prnum, prErr := beego.AppConfig.Int("crontab::prcnum")
	if prErr != nil {
		prnum = 100
	}
	// Get the data source of the table
	err := taskhandler.ProcIssueIsExists(prnum)
	logs.Info(err)
	return err
}

// Statistics of issues created in different communities, uncreated issues are created
func CommunityIssueStatist() error {
	// Get the configuration file
	yamlConfigTable := beego.AppConfig.String("cve::yaml_config_table")
	tableList := strings.Split(yamlConfigTable, ",")
	localList := make([][]string, 0)
	cyc := models.GetCommunityYamlConfigAll()
	if len(cyc) > 0 {
		for _, c := range cyc {
			taskhandler.StatistCommunityIssue(c)
		}
	}
	for _, tab := range tableList {
		flag := false
		tabList := strings.Split(tab, ":")
		for _, c := range cyc {
			if tabList[0] == c.TableName {
				flag = true
				break
			}
		}
		if !flag {
			if len(tabList) > 1 {
				localList = append(localList, tabList)
			}
		}
	}
	if len(localList) > 0 {
		for _, lc := range localList {
			organizationID, _ := strconv.Atoi(lc[1])
			cyc := models.CommunityYamlConfig{TableName: lc[0], OrganizationID: int8(organizationID)}
			num, err := models.InsertCommunityYamlConfig(&cyc)
			if err != nil {
				logs.Error("num: ", num, ",err: ", err)
			}
		}
	}
	return nil
}

func IssueLabelCheck() error {
	uNaffected := beego.AppConfig.String("labeUnaffected")
	labelFixed := beego.AppConfig.String("labelFixed")
	labelUnFix := beego.AppConfig.String("labelUnFix")
	templateId := int64(0)
	num := 100
	for {
		issueTemp, issueErr := models.GetIssueTemplateByStatus(3, templateId, num)
		if len(issueTemp) == 0 {
			logs.Error("issueErr", issueErr)
			return issueErr
		}
		for _, issue := range issueTemp {
			templateId = issue.TemplateId
			path := issue.Repo
			if issue.StatusName != "closed" && issue.StatusName != "已完成" {
				logs.Error("issue.StatusName: ", issue.StatusName)
				continue
			}
			affectBrandFlag := false
			cveCenter := models.VulnCenter{CveId: issue.CveId, CveNum: issue.CveNum}
			cveErr := models.GetVulnCenterByCid(&cveCenter, "cve_id", "cve_num")
			if cveErr != nil {
				logs.Error("cveErr: ", cveErr)
				continue
			}
			owner, token := common.GetOwnerAndToken(cveCenter.CveNum, cveCenter.OrganizationID)
			sn := models.SecurityNotice{CveId: issue.CveId, CveNum: issue.CveNum}
			snErr := sn.Read("cve_id", "cve_num")
			if snErr != nil {
				logs.Error("snErr: ", snErr)
			} else {
				affectBranchsxList := make([]string, 0)
				affectedBranchs := ""
				if cveCenter.OrganizationID == 4 {
					affectedBranchs = strings.ReplaceAll(sn.AffectProduct, "/", ",")
				} else if cveCenter.OrganizationID == 3 {
					if sn.AffectProduct != "" && len(sn.AffectProduct) > 1 {
						tmpTagList := make([]string, 0)
						affectProductSlice := strings.Split(sn.AffectProduct, "/")
						for _, tags := range affectProductSlice {
							mdbt := models.MindSporeBrandTags{PackageName: path, Tags: tags}
							mtErr := models.QueryMindSporeBrandTags(&mdbt, "PackageName", "Tags")
							if mtErr == nil {
								tmpTagList = append(tmpTagList, mdbt.Brand)
							}
						}
						if len(tmpTagList) > 0 {
							sn.AffectProduct = strings.Join(tmpTagList, "/")
							affectedBranchs = strings.ReplaceAll(sn.AffectProduct, "/", ",")
						} else {
							sn.AffectProduct = ""
						}
					}
				} else if cveCenter.OrganizationID == 2 {
					affectedBranchs = strings.ReplaceAll(sn.AffectProduct, "/", ",")
				} else {
					affectedBranchs = beego.AppConfig.String("cve::affected_branchs")
					affectedBranchs = affectedBranchs + "," + beego.AppConfig.String("cve::abandoned_branchs")
				}
				if affectedBranchs != "" && len(affectedBranchs) > 0 {
					affectBranchsxList = strings.Split(affectedBranchs, ",")
				}
				if sn.AffectProduct != "" && len(sn.AffectProduct) > 1 {
					affectProductList := strings.Split(sn.AffectProduct, "/")
					if len(affectProductList) > 0 {
						for _, brands := range affectProductList {
							if len(affectBranchsxList) > 0 {
								for _, affectBranch := range affectBranchsxList {
									if affectBranch == brands {
										affectBrandFlag = true
										break
									}
								}
							}
							if affectBrandFlag {
								break
							}
						}
					}
				}
				switch issue.IssueStatus {
				case 2:
					sn.AffectStatus = "Fixed"
				case 6:
					sn.AffectStatus = "UnAffected"
				default:
					sn.AffectStatus = "UnFixed"
				}
				err := sn.Update("affect_status")
				if err != nil {
					logs.Error(err)
				}
			}
			if affectBrandFlag {
				issue.IssueLabel = labelFixed
			} else {
				issue.IssueLabel = uNaffected
			}
			labelSlice := make([]string, 0)
			labelSlice = taskhandler.AddLabelValue(token, path, issue.IssueNum, owner, issue.IssueLabel, 2)
			upLabelFlag := false
			if len(labelSlice) > 0 {
				labelStr := strings.Join(labelSlice, ",")
				if affectBrandFlag {
					if strings.Contains(labelStr, uNaffected) {
						labelSlice = common.DeleteSliceValue(labelSlice, uNaffected)
						upLabelFlag = true
					}
				} else {
					if strings.Contains(labelStr, labelFixed) {
						labelSlice = common.DeleteSliceValue(labelSlice, labelFixed)
						upLabelFlag = true
					}
				}
				if strings.Contains(labelStr, labelUnFix) {
					labelSlice = common.DeleteSliceValue(labelSlice, labelUnFix)
					upLabelFlag = true
				}
				issue.IssueLabel = strings.Join(labelSlice, ",")
				issue.CveLevel = models.OpenEulerScoreProc(issue.OpenEulerScore)
				tpErr := models.UpdateIssueTemplate(&issue, "IssueLabel", "CveLevel")
				if tpErr != nil {
					logs.Error(tpErr)
				}
			}
			if upLabelFlag {
				update := taskhandler.UpdateIssueLabels(token, path, issue.IssueNum, owner, issue.IssueLabel)
				if !update {
					logs.Error("update gitee issue label  fail ,", issue.IssueNum, issue.IssueLabel)
				}
			}
		}
	}
}

func GetV8Token() error {
	tokenList := models.QueryAuthTokenInfo()
	if len(tokenList) > 0 {
		for _, tk := range tokenList {
			var giteeToken taskhandler.GiteeTokenInfo
			taskhandler.GiteePostFreshToken(tk.RefreshToken, &giteeToken)
			if len(giteeToken.AccessToken) > 0 {
				tk.AccessToken = giteeToken.AccessToken
				tk.RefreshToken = giteeToken.RefreshToken
				tk.CreatedAt = giteeToken.CreatedAt
				tk.ExpiresIn = giteeToken.ExpiresIn
				tk.Scope = giteeToken.Scope
				tk.TokenType = giteeToken.TokenType
				tk.UpdateTime = common.GetCurTime()
				models.UpdateAuthTokenInfoById(tk)
			}
		}
	}
	return nil
}

func SetIssueProcParams() error {
	prnum, prErr := beego.AppConfig.Int("crontab::prcnum")
	if prErr != nil {
		prnum = 100
	}
	tokenList := models.QueryAuthTokenInfo()
	tokenMap := make(map[int8]models.AuthTokenInfo, len(tokenList))
	if len(tokenList) > 0 {
		for _, tl := range tokenList {
			tokenMap[tl.OrganizationID] = tl
		}
	}
	// 1.Get pending data
	cveId := int64(0)
	for {
		vulnCve, _ := models.QueryAllCveVuln(prnum, cveId)
		if len(vulnCve) > 0 {
			for _, vl := range vulnCve {
				cveId = vl.CveId
				organid := vl.OrganizationID

				// ignore openeuler, handle it in SyncPlanDateOfIssueFromMaJun job
				if organid == models.OrganizationIdOpeneuler {
					continue
				}

				if vl.Status > 2 && organid != 3 {
					continue
				}
				its := models.IssueTemplate{CveId: vl.CveId, CveNum: vl.CveNum}
				_ = models.GetIssueTemplateByColName(&its, "CveId", "CveNum")
				if its.TemplateId == 0 || its.Status > 2 {
					continue
				}
				if len(its.PlanStarted) > 1 && len(its.Deadline) > 1 && organid != 3 {
					continue
				}
				authToken := tokenMap[organid]
				var priorityOld int = -1
				taskhandler.GetEntIssueDetail(vl, &its, &priorityOld)
				if len(its.PlanStarted) > 1 && len(its.Deadline) > 1 {
					its.UpdateTime = time.Now()
					models.UpdateIssueTemplate(&its, "PlanStarted", "Deadline", "UpdateTime")
					if organid != 3 {
						continue
					}
				}
				if its.NVDScore > 0 || organid == 3 {
					var cveLevel string
					if organid == 3 {
						cveLevel = models.MindSporeScoreProc(its.NVDScore)
					} else {
						cveLevel = models.OpenEulerScoreProc(its.NVDScore)
					}
					deadLine := taskhandler.CvePlanCloseTime(its.CreateTime, cveLevel, false, true)
					planAt := common.GetSpecifiedTime(its.CreateTime, 0, false, true)
					priority := taskhandler.GetIssuePriority(cveLevel)
					if priority <= priorityOld {
						continue
					}
					owner, accessToken := common.GetOwnerAndToken(vl.CveNum, organid)
					issueErr, issueBody := taskhandler.GetGiteeIssue(accessToken, owner, its.Repo, its.IssueNum)
					if issueErr == nil && issueBody != nil {
						if s, ok := issueBody["created_at"].(string); ok {
							if t, err := time.Parse("2006-01-02T15:04:05+08:00", s); err == nil {
								planAt = common.GetSpecifiedTime(t, 0, true, true)
								deadLine = taskhandler.CvePlanCloseTime(t, cveLevel, true, true)
							}
						}
					}
					taskhandler.UpdateEntIssueDetail(authToken.EnId, its.IssueId,
						authToken.AccessToken, planAt, deadLine, priority)
				}
			}
		} else {
			break
		}
	}
	return nil
}

func SyncPlanDateOfIssueFromMaJun() error {
	at := models.AuthTokenInfo{OrganizationID: models.OrganizationIdOpeneuler}
	if err := models.QueryAuthTokenById(&at, "organizate_id"); err != nil {
		return err
	}

	for _, v := range getPlanData() {
		its := models.IssueTemplate{IssueNum: v.IssueNum}
		models.GetIssueTemplateByColName(&its, "IssueNum")
		if its.TemplateId == 0 || its.NVDScore <= 0 {
			continue
		}

		var planAt, deadLine string
		cveLevel := models.OpenEulerScoreProc(its.NVDScore)
		if v.BeginTime == "" || v.EndTime == "" {
			if its.PlanStarted != "" && its.Deadline != "" {
				continue
			}
			planAt = common.GetSpecifiedTime(its.CreateTime, 0, false, true)
			deadLine = taskhandler.CvePlanCloseTime(its.CreateTime, cveLevel, false, true)
		} else {
			planAt = strings.Replace(v.BeginTime, " ", "T", -1)
			deadLine = strings.Replace(v.EndTime, " ", "T", -1)

			if planAt == its.PlanStarted && deadLine == its.Deadline {
				continue
			}
		}

		its.PlanStarted = planAt
		its.Deadline = deadLine
		if err := models.UpdateIssueTemplate(&its, "PlanStarted", "Deadline"); err != nil {
			logs.Error("sync plan date update error:", err.Error())
			continue
		}

		priority := taskhandler.GetIssuePriority(cveLevel)
		taskhandler.UpdateEntIssueDetail(at.EnId, its.IssueId, at.AccessToken, planAt, deadLine, priority)
	}

	return nil
}

type PlanDataOfMaJun struct {
	IssueNum  string  `json:"issueId"`
	CveNum    string  `json:"cveNum"`
	CvssScore float64 `json:"cvssScore"`
	BeginTime string  `json:"cveRepairStartTime"`
	EndTime   string  `json:"issuePlanClosedTIme"`
}

type PlanResponse struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
	Result  struct {
		Data []PlanDataOfMaJun `json:"data"`
	}
}

type PlanRequest struct {
	Organization string `json:"organization"`
	PageNum      int    `json:"pageNum"`
	PageSize     int    `json:"pageSize"`
}

func getPlanData() []PlanDataOfMaJun {
	url := "https://majun.osinfra.cn/api/http/majun-vulnerability-view/admin/ci-portal/ci-admin/cve/getTime/details"
	token := beego.AppConfig.String("majun::api_token")
	pageNum := 1
	pageSize := 1000
	cli := utils.NewHttpClient(3)

	var data []PlanDataOfMaJun
	for {
		var ret PlanResponse
		param := PlanRequest{
			Organization: "openeuler",
			PageNum:      pageNum,
			PageSize:     pageSize,
		}
		b, _ := json.Marshal(param)
		req, _ := http.NewRequest(http.MethodPost, url, bytes.NewBuffer(b))

		req.Header.Add("access_token", token)

		if _, err := cli.ForwardTo(req, &ret); err != nil {
			logs.Error("get plan data error: ", err.Error())
			break
		}

		data = append(data, ret.Result.Data...)

		if len(ret.Result.Data) < pageSize {
			break
		}

		pageNum++
	}

	return data
}
