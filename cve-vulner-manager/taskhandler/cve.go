package taskhandler

import (
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"

	"cvevulner/common"
	"cvevulner/cve-timed-task/tabletask"
	"cvevulner/models"
	"cvevulner/util"

	"github.com/astaxie/beego"
	"github.com/astaxie/beego/config"
	"github.com/astaxie/beego/logs"
)

var GetCveDetailUrl = "https://openeuler.org/api-cve/cve-security-notice-server/cvedatabase/getByCveId?cveId=%s"

var (
	pkgLock sync.Mutex
	lockx   sync.Mutex
	dbLock  sync.Mutex
)
var ewg sync.WaitGroup

type UpdateInfoXml struct {
	XmfilePath     string
	Cvexml         []CveXml
	Dpdates        *Updates
	SecurityNotice map[string][]SecurityNoticeXml
	PackRpmx       map[string][]PackRpm
	FileName       string
	AffectBranch   string
}

type PackageVersion struct {
	OrganizationID int8
	VerionList     []string
	ids            []string
}

func UpdateExcelCveGroups(cveData models.OriginExcel,
	cveRef string, openeulerNum int, CveRes models.VulnCenter,
	goe models.GitPackageInfo, organizationID int8) (bool, error) {
	var OpenEulId int64
	CveRes.Description = cveData.CveDesc
	CveRes.CveVersion = cveData.CveVersion
	if len(CveRes.RepairTime) < 2 && len(cveData.RepairTime) > 2 {
		CveRes.RepairTime = cveData.RepairTime
	}
	if len(goe.Decription) < 1 {
		goe.Decription = goe.Summary
	}
	//CveRes.PackName = cveData.PackName
	CveRes.RepoName = cveData.PackName
	CveRes.CveUrl = cveRef + cveData.CveNum
	CveRes.CveLevel = cveData.CveLevel
	CveRes.OrganizationID = organizationID
	if CveRes.DataSource == 1 {
		CveRes.DataSource = 3
	}
	if CveRes.DataSource != 4 && CveRes.Status != 0 && CveRes.Status != 1 {
		CveRes.Status = 1
		CveRes.IsExport = 0
	}
	if (CveRes.DataSource == 4 || CveRes.DataSource == 3) &&
		CveRes.Status != 0 && CveRes.Status != 1 {
		issueTmp := models.IssueTemplate{CveId: CveRes.CveId,
			Repo: CveRes.PackName, OwnedVersion: CveRes.CveVersion}
		err := models.GetIssueTemplateByColName(&issueTmp, "CveId", "Repo", "OwnedVersion")
		if err != nil {
			if CveRes.DataSource == 3 {
				CveRes.Status = 0
				CveRes.IsExport = 0
			}
			logs.Error(err)
		} else {
			if issueTmp.Status < 3 {
				CveRes.Status = 1
				CveRes.IsExport = 0
			}
		}
	}
	//CveRes.Status = 1
	openEusa, operr := models.QueryOpenEulerSAByCveId(CveRes.CveId)
	if operr == false {
		var opensa models.OpenEulerSA
		osx, operr := models.QueryOpenSaLastId()
		var OpenNumData int
		if operr == nil {
			OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
			OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
			if err == nil {
				OpenNum += 1
			} else {
				OpenNum = openeulerNum
			}
			OpenNumData = OpenNum
		} else {
			OpenNumData = openeulerNum
		}
		OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(OpenNumData)
		opensa.OpenEulerSANum = OpenEulerSANum
		opensa.CveId = CveRes.CveId
		openEulerId, opEerr := models.CreateOpenEulerSA(&opensa)
		if opEerr == nil {
			OpenEulId = openEulerId
		} else {
			logs.Error("UpdateExcelCveGroups, Failed to update openEulerSa data table, err: ", opEerr)
			return false, errors.New("openEulerSA数据错误，暂时不处理")
		}
	} else {
		OpenEulId = openEusa.OpenId
	}
	scoreRes, scoreerr := models.QueryScoreByCveId(CveRes.CveId)
	if scoreerr {
		if scoreRes.NVDScore != cveData.NVDScore {
			var scorecode models.ScoreRecord
			scorecode.NVDScore = cveData.NVDScore
			scorecode.NvectorVule = cveData.NVDVector
			scorecode.Status = 0
			scorecode.CveId = CveRes.CveId
			scoreid, err := models.InsertScoreRecord(&scorecode)
			if scoreid > 0 && err == nil {
				logs.Info("insert score_record success, id:", scoreid)
			} else {
				return false, errors.New("评分记录数据错误，暂时不处理")
			}
		}
		scoreRes.NVDScore = cveData.NVDScore
		scoreRes.NvectorVule = cveData.NVDVector
		scoreRes.OpenId = OpenEulId
		scoreRes.Nstatus = 1
		if strings.ToLower(cveData.ScoreType) == "v2" || strings.ToLower(cveData.ScoreType) == "v2.0" {
			scoreRes.NaccessVector = cveData.AccessVector
			scoreRes.NaccessComplexity = cveData.AccessComplexity
			scoreRes.Nauthentication = cveData.Authentication
			scoreRes.ScoreType = "v2"
		} else {
			scoreRes.NattackVector = cveData.AttackVector
			scoreRes.NattackComplexity = cveData.AttackComplexity
			scoreRes.NprivilegeRequired = cveData.PrivilegeRequired
			scoreRes.NuserInteraction = cveData.UserInteraction
			scoreRes.Nscope = cveData.Scope
			scoreRes.ScoreType = "v3"
		}
		scoreRes.Nconfidentiality = cveData.Confidentiality
		scoreRes.Nintegrity = cveData.Integrity
		scoreRes.Navailability = cveData.Availability
	} else {
		var sc models.Score
		sc.CveNum = cveData.CveNum
		sc.NVDScore = cveData.NVDScore
		sc.OpenEulerScore = cveData.NVDScore
		sc.OpenId = OpenEulId
		sc.NvectorVule = cveData.NVDVector
		sc.OvectorVule = cveData.NVDVector
		sc.CveId = CveRes.CveId
		sc.Nstatus = 0
		sc.Ostatus = 0
		if strings.ToLower(cveData.ScoreType) == "v2" ||
			strings.ToLower(cveData.ScoreType) == "v2.0" {
			sc.NaccessVector = cveData.AccessVector
			sc.OaccessVector = cveData.AccessVector
			sc.NaccessComplexity = cveData.AccessComplexity
			sc.OaccessComplexity = cveData.AccessComplexity
			sc.Nauthentication = cveData.Authentication
			sc.Oauthentication = cveData.Authentication
			sc.ScoreType = "v2"
		} else {
			sc.NattackVector = cveData.AttackVector
			sc.OattackVector = cveData.AttackVector
			sc.NattackComplexity = cveData.AttackComplexity
			sc.OattackComplexity = cveData.AttackComplexity
			sc.NprivilegeRequired = cveData.PrivilegeRequired
			sc.OprivilegeRequired = cveData.PrivilegeRequired
			sc.OuserInteraction = cveData.UserInteraction
			sc.NuserInteraction = cveData.UserInteraction
			sc.Oscope = cveData.Scope
			sc.Nscope = cveData.Scope
			sc.ScoreType = "v3"
		}
		sc.Nconfidentiality = cveData.Confidentiality
		sc.Oconfidentiality = cveData.Confidentiality
		sc.Nintegrity = cveData.Integrity
		sc.Ointegrity = cveData.Integrity
		sc.Navailability = cveData.Availability
		sc.Oavailability = cveData.Availability
		scid, scErr := models.CreateScore(&sc)
		if scErr != nil {
			logs.Error("UpdateExcelCveGroups, insert cve_score failed cveScV3: ", sc, ",scerr: ", scErr)
			return false, errors.New("记录评分失败，暂时不处理")
		} else {
			logs.Info("insert cve_score success scid: ", scid, "CveNum:", cveData.CveNum)
		}
	}
	SecNOtice, secerrx := models.QuerySecNoticeByCveId(CveRes.CveId)
	if secerrx {
		SecNOtice.InfluenceComponent = cveData.PackName
		SecNOtice.OpenId = OpenEulId
		SecNOtice.Summary = cveData.PackName + " security update"
		SecNOtice.ReferenceLink = cveRef + cveData.CveNum
	} else {
		var sec models.SecurityNotice
		sec.CveNum = cveData.CveNum
		sec.OpenId = OpenEulId
		sec.InfluenceComponent = cveData.PackName
		sec.Status = 0
		sec.AffectStatus = "Fixed"
		sec.CveId = CveRes.CveId
		sec.Summary = cveData.PackName + " security update"
		sec.ReferenceLink = cveRef + cveData.CveNum
		if goe.Decription != "" && len(goe.Decription) > 0 {
			sec.Description = goe.Decription + "\n\n" + "Security Fix(es):" + "\n\n" + cveData.CveDesc + "(" + CveRes.CveNum + ")"
		} else {
			sec.Description = "Security Fix(es):" + "\n\n" + cveData.CveDesc + "(" + CveRes.CveNum + ")"
		}
		secid, secerr := models.CreateSecurityNotice(&sec)
		if secerr != nil {
			logs.Error("insert cve_security_notice failed CveNum:", cveData.CveNum)
			return false, errors.New("记录SA失败，暂时不处理")
		} else {
			logs.Info("insert cve_security_notice success secid: , cveNum: ", secid, cveData.CveNum)
		}
	}
	if scoreerr && secerrx {
		errx := models.UpdateCveRelat(&CveRes, &SecNOtice, &scoreRes)
		if errx != nil {
			logs.Error("UpdateExcelCveGroups, UpdateCveRelat, update failed, CveNum:",
				cveData.CveNum, ", errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else if scoreerr {
		errx := models.UpdateCveRelat1(&CveRes, &SecNOtice)
		if errx != nil {
			logs.Error("UpdateExcelCveGroups, UpdateCveRelat1, update failed,  CveNum:",
				cveData.CveNum, ", errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else {
		errx := models.UpdateCveRelat2(&CveRes, &scoreRes)
		if errx != nil {
			logs.Error("UpdateExcelCveGroups, UpdateCveRelat2, "+
				"update failed, CveNum:", cveData.CveNum, ",errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	}
	return true, nil
}

func InsertCveExcelGroups(cveData models.OriginExcel, cveRef, repoName string, openeulerNum int,
	goe models.GitPackageInfo, organizationID int8) (bool, error) {
	var vul models.VulnCenter
	vul.CveNum = cveData.CveNum
	vul.Description = cveData.CveDesc
	vul.Status = 0
	vul.CveVersion = cveData.CveVersion
	vul.RepairTime = cveData.RepairTime
	vul.PackName = repoName
	vul.RepoName = cveData.PackName
	vul.CveUrl = cveRef + cveData.CveNum
	vul.CveLevel = cveData.CveLevel
	vul.DataSource = 3
	vul.IsExport = 0
	vul.OrganizationID = organizationID
	var sec models.SecurityNotice
	sec.CveNum = cveData.CveNum
	sec.InfluenceComponent = cveData.PackName
	sec.Status = 0
	sec.AffectStatus = "Fixed"
	sec.Summary = cveData.PackName + " security update"
	sec.ReferenceLink = cveRef + cveData.CveNum
	specCharList := []string{"\n", "\r", "\t"}
	if len(goe.Decription) < 1 {
		goe.Decription = goe.Summary
	}
	if goe.Decription != "" && len(goe.Decription) > 0 {
		sec.Description = RemoveSubstring(goe.Decription, specCharList) + "\n\n" +
			"Security Fix(es):" + "\n\n" + RemoveSubstring(cveData.CveDesc, specCharList)
	} else {
		sec.Description = "Security Fix(es):" + "\n\n" + RemoveSubstring(cveData.CveDesc, specCharList)
	}
	if sec.Description != "" && len(sec.Description) > 1 {
		sec.Description = deleteTailBlank(sec.Description) + "(" + vul.CveNum + ")"
	} else {
		sec.Description += "(" + vul.CveNum + ")"
	}
	var sc models.Score
	sc.CveNum = cveData.CveNum
	sc.NVDScore = cveData.NVDScore
	sc.OpenEulerScore = cveData.NVDScore
	sc.NvectorVule = cveData.NVDVector
	sc.OvectorVule = cveData.NVDVector
	sc.Nstatus = 0
	sc.Ostatus = 0
	if strings.ToLower(cveData.ScoreType) == "v2" ||
		strings.ToLower(cveData.ScoreType) == "v2.0" {
		sc.NaccessVector = cveData.AccessVector
		sc.OaccessVector = cveData.AccessVector
		sc.NaccessComplexity = cveData.AccessComplexity
		sc.OaccessComplexity = cveData.AccessComplexity
		sc.Nauthentication = cveData.Authentication
		sc.Oauthentication = cveData.Authentication
		sc.ScoreType = "v2"
	} else {
		sc.NattackVector = cveData.AttackVector
		sc.OattackVector = cveData.AttackVector
		sc.NattackComplexity = cveData.AttackComplexity
		sc.OattackComplexity = cveData.AttackComplexity
		sc.NprivilegeRequired = cveData.PrivilegeRequired
		sc.OprivilegeRequired = cveData.PrivilegeRequired
		sc.OuserInteraction = cveData.UserInteraction
		sc.NuserInteraction = cveData.UserInteraction
		sc.Oscope = cveData.Scope
		sc.Nscope = cveData.Scope
		sc.ScoreType = "v3"
	}
	sc.Nconfidentiality = cveData.Confidentiality
	sc.Oconfidentiality = cveData.Confidentiality
	sc.Nintegrity = cveData.Integrity
	sc.Ointegrity = cveData.Integrity
	sc.Navailability = cveData.Availability
	sc.Oavailability = cveData.Availability
	var opensa models.OpenEulerSA
	//var os models.OpenSaId
	osx, operr := models.QueryOpenSaLastId()
	var OpenNumData int
	if operr == nil {
		OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
		OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
		if err == nil {
			OpenNum += 1
		} else {
			OpenNum = openeulerNum
		}
		OpenNumData = OpenNum
	} else {
		OpenNumData = openeulerNum
	}
	OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
	opensa.OpenEulerSANum = OpenEulerSANum
	var scorecode models.ScoreRecord
	scorecode.NVDScore = cveData.NVDScore
	scorecode.NvectorVule = cveData.NVDVector
	scorecode.Status = 0
	cveid, cveerr := models.CreateCveRelat(&vul, &sec, &sc, &opensa, &scorecode)
	if cveerr != nil || cveid <= 0 {
		logs.Error("InsertCveExcelGroups, CreateCveRelat, "+
			"insert failed, CveNum:", cveData.CveNum, ", cveerr: ", cveerr)
		return false, errors.New("数据插入失败, 暂时不处理")
	}
	return true, nil
}

func UpdateCveGroups(cveData models.OriginUpstream, cveRef string, openeulerNum int, CveRes models.VulnCenter,
	cveDesc models.OriginUpstreamDesc, cveScV3 models.OriginUpstreamImpactScoreV3, goe models.GitPackageInfo,
	scopeType string, cveScV2 models.OriginUpstreamImpactScoreV2, pkList []string, organizationID int8) (bool, error) {
	var OpenEulId int64
	if len(cveDesc.EnDescription) > 2 {
		CveRes.Description = cveDesc.EnDescription
	}
	CveRes.CveVersion = pkList[1]
	if len(cveData.PublishedDate) > 10 && CveRes.RepairTime != cveData.PublishedDate {
		CveRes.RepairTime = cveData.PublishedDate
	}
	if common.GetCveSource(cveData.CveNum) == 1 || common.GetCveSourceRecord(cveData.CveNum) == 1 {
		CveRes.DataSource = 5
	}
	//CveRes.PackName = pkList[0]
	CveRes.RepoName = pkList[0]
	CveRes.CveUrl = cveRef + cveData.CveNum
	CveRes.CveLevel = cveScV3.CveLevel
	CveRes.OrganizationID = organizationID
	CveRes.FirstPerTime = cveData.FirstPerTime
	CveRes.FirstGetTime = cveData.FirstGetTime
	//CveRes.DataSource = 1
	if CveRes.DataSource != 4 && CveRes.Status != 0 && CveRes.Status != 1 {
		CveRes.Status = 1
		CveRes.IsExport = 0
	}
	//CveRes.Status = 1
	openEusa, operr := models.QueryOpenEulerSAByCveId(CveRes.CveId)
	if operr == false {
		var opensa models.OpenEulerSA
		osx, operr := models.QueryOpenSaLastId()
		var OpenNumData int
		if operr == nil {
			OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
			OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
			if err == nil {
				OpenNum += 1
			} else {
				OpenNum = openeulerNum
			}
			OpenNumData = OpenNum
		} else {
			OpenNumData = openeulerNum
		}
		OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(OpenNumData)
		opensa.OpenEulerSANum = OpenEulerSANum
		opensa.CveId = CveRes.CveId
		openEulerId, opEerr := models.CreateOpenEulerSA(&opensa)
		if opEerr == nil {
			OpenEulId = openEulerId
		} else {
			logs.Error("InsertCveExcelGroups, CreateOpenEulerSA, Update failed, err: ", opEerr)
			return false, errors.New("openEulerSA数据错误，暂时不处理")
		}
	} else {
		OpenEulId = openEusa.OpenId
	}
	scoreRes, scoreerr := models.QueryScoreByCveId(CveRes.CveId)
	if scoreerr {
		scoreRes.ScoreType = scopeType
		vectorString := ""
		if scopeType == "v3" {
			if cveScV3.VectorString != "" && len(cveScV3.VectorString) > 0 {
				index := strings.IndexAny(cveScV3.VectorString, "/")
				if index > 0 && strings.ToLower(cveScV3.VectorString)[:4] == "cvss" {
					vectorString = cveScV3.VectorString[index+1:]
				} else {
					vectorString = cveScV3.VectorString
				}
			}
			if scoreRes.NVDScore != cveScV3.BaseScore {
				var scorecode models.ScoreRecord
				scorecode.NVDScore = cveScV3.BaseScore
				scorecode.NvectorVule = vectorString
				scorecode.Status = 0
				scorecode.CveId = CveRes.CveId
				scoreid, err := models.InsertScoreRecord(&scorecode)
				if scoreid > 0 && err == nil {
					logs.Info("insert score_record success, id:", scoreid)
				} else {
					return false, errors.New("评分记录数据错误，暂时不处理")
				}
			}
			scoreRes.NVDScore = cveScV3.BaseScore
			scoreRes.NvectorVule = vectorString
			scoreRes.OpenId = OpenEulId
			scoreRes.Nstatus = 1
			scoreRes.NattackVector = cveScV3.AttackVector
			scoreRes.NattackComplexity = cveScV3.AttackComplexity
			scoreRes.NprivilegeRequired = cveScV3.PrivilegesRequired
			scoreRes.NuserInteraction = cveScV3.UserInteraction
			scoreRes.Nscope = cveScV3.Scope
			scoreRes.Nconfidentiality = cveScV3.ConfidentialityImpact
			scoreRes.Nintegrity = cveScV3.IntegrityImpact
			scoreRes.Navailability = cveScV3.AvailabilityImpact
		} else {
			if cveScV2.VectorString != "" && len(cveScV2.VectorString) > 0 {
				index := strings.IndexAny(cveScV2.VectorString, "/")
				if index > 0 && strings.ToLower(cveScV2.VectorString)[:4] == "cvss" {
					vectorString = cveScV2.VectorString[index+1:]
				} else {
					vectorString = cveScV2.VectorString
				}
			}
			if scoreRes.NVDScore != cveScV2.BaseScore {
				var scorecode models.ScoreRecord
				scorecode.NVDScore = cveScV2.BaseScore
				scorecode.NvectorVule = vectorString
				scorecode.Status = 0
				scorecode.CveId = CveRes.CveId
				scoreid, err := models.InsertScoreRecord(&scorecode)
				if scoreid > 0 && err == nil {
					logs.Info("insert score_record success, id:", scoreid)
				} else {
					return false, errors.New("评分记录数据错误，暂时不处理")
				}
			}
			scoreRes.NVDScore = cveScV2.BaseScore
			scoreRes.NvectorVule = vectorString
			scoreRes.OpenId = OpenEulId
			scoreRes.Nstatus = 1
			scoreRes.NaccessVector = cveScV2.AccessVector
			scoreRes.NaccessComplexity = cveScV2.AccessComplexity
			scoreRes.Nconfidentiality = cveScV2.ConfidentialityImpact
			scoreRes.Nintegrity = cveScV2.IntegrityImpact
			scoreRes.Navailability = cveScV2.AvailabilityImpact
			scoreRes.Nauthentication = cveScV2.Authentication
		}
	} else {
		var sc models.Score
		sc.CveNum = cveData.CveNum
		sc.OpenId = OpenEulId
		sc.CveId = CveRes.CveId
		sc.Nstatus = 0
		sc.Ostatus = 0
		sc.ScoreType = scopeType
		if scopeType == "v3" {
			sc.NVDScore = cveScV3.BaseScore
			sc.OpenEulerScore = cveScV3.BaseScore
			vectorString := ""
			if cveScV3.VectorString != "" && len(cveScV3.VectorString) > 0 {
				index := strings.IndexAny(cveScV3.VectorString, "/")
				if index > 0 && strings.ToLower(cveScV3.VectorString)[:4] == "cvss" {
					vectorString = cveScV3.VectorString[index+1:]
				} else {
					vectorString = cveScV3.VectorString
				}
			}
			sc.NvectorVule = vectorString
			sc.OvectorVule = vectorString
			sc.NattackVector = cveScV3.AttackVector
			sc.OattackVector = cveScV3.AttackVector
			sc.NattackComplexity = cveScV3.AttackComplexity
			sc.OattackComplexity = cveScV3.AttackComplexity
			sc.NprivilegeRequired = cveScV3.PrivilegesRequired
			sc.OprivilegeRequired = cveScV3.PrivilegesRequired
			sc.NuserInteraction = cveScV3.UserInteraction
			sc.OuserInteraction = cveScV3.UserInteraction
			sc.Nscope = cveScV3.Scope
			sc.Oscope = cveScV3.Scope
			sc.Nconfidentiality = cveScV3.ConfidentialityImpact
			sc.Oconfidentiality = cveScV3.ConfidentialityImpact
			sc.Nintegrity = cveScV3.IntegrityImpact
			sc.Ointegrity = cveScV3.IntegrityImpact
			sc.Navailability = cveScV3.AvailabilityImpact
			sc.Oavailability = cveScV3.AvailabilityImpact
		} else {
			sc.NVDScore = cveScV2.BaseScore
			sc.OpenEulerScore = cveScV2.BaseScore
			vectorString := ""
			if cveScV2.VectorString != "" && len(cveScV2.VectorString) > 0 {
				index := strings.IndexAny(cveScV2.VectorString, "/")
				if index > 0 && strings.ToLower(cveScV2.VectorString)[:4] == "cvss" {
					vectorString = cveScV2.VectorString[index+1:]
				} else {
					vectorString = cveScV2.VectorString
				}
			}
			sc.NvectorVule = vectorString
			sc.OvectorVule = vectorString
			sc.NaccessVector = cveScV2.AccessVector
			sc.OaccessVector = cveScV2.AccessVector
			sc.NaccessComplexity = cveScV2.AccessComplexity
			sc.OaccessComplexity = cveScV2.AccessComplexity
			sc.Nauthentication = cveScV2.Authentication
			sc.Oauthentication = cveScV2.Authentication
			sc.Nconfidentiality = cveScV2.ConfidentialityImpact
			sc.Oconfidentiality = cveScV2.ConfidentialityImpact
			sc.Nintegrity = cveScV2.IntegrityImpact
			sc.Ointegrity = cveScV2.IntegrityImpact
			sc.Navailability = cveScV2.AvailabilityImpact
			sc.Oavailability = cveScV2.AvailabilityImpact
		}
		scid, scerr := models.CreateScore(&sc)
		if scerr != nil {
			logs.Error("InsertCveExcelGroups, CreateScore, "+
				"insert failed, cveScV3:", cveScV3, ",scerr: ", scerr)
			return false, errors.New("记录评分失败，暂时不处理")
		} else {
			logs.Info("insert cve_score success scid: ", scid, "CveNum:", cveData.CveNum)
		}
	}
	SecNOtice, secerrx := models.QuerySecNoticeByCveId(CveRes.CveId)
	if secerrx {
		SecNOtice.CveId = CveRes.CveId
		SecNOtice.InfluenceComponent = pkList[0]
		SecNOtice.OpenId = OpenEulId
		SecNOtice.Summary = pkList[0] + " security update"
		SecNOtice.ReferenceLink = cveRef + cveData.CveNum

		split := strings.Split(SecNOtice.Description, "Security Fix(es):")
		if len(split) >= 2 {
			match := regexp.MustCompile(`\S+`).FindAllStringSubmatch(split[0], 1)
			if len(match) == 0 {
				SecNOtice.Description = genSecurityNoticeDescription(goe, cveDesc, CveRes)
			}
		}
	} else {
		var sec models.SecurityNotice
		sec.CveNum = cveData.CveNum
		sec.OpenId = OpenEulId
		sec.InfluenceComponent = pkList[0]
		sec.Status = 0
		sec.AffectStatus = "Fixed"
		sec.CveId = CveRes.CveId
		sec.Summary = pkList[0] + " security update"
		sec.ReferenceLink = cveRef + cveData.CveNum
		if len(goe.Decription) < 1 {
			goe.Decription = goe.Summary
		}
		sec.Description = genSecurityNoticeDescription(goe, cveDesc, CveRes)
		secid, secerr := models.CreateSecurityNotice(&sec)
		if secerr != nil {
			logs.Error("InsertCveExcelGroups, CreateSecurityNotice, "+
				"insert failed, CveNum:", cveData.CveNum, ",secerr: ", secerr)
			return false, errors.New("记录SA失败，暂时不处理")
		} else {
			logs.Info("insert cve_security_notice success secid: , cveNum: ", secid, cveData.CveNum)
		}
	}
	if scoreerr && secerrx {
		errx := models.UpdateCveRelat(&CveRes, &SecNOtice, &scoreRes)
		if errx != nil {
			logs.Error("InsertCveExcelGroups, UpdateCveRelat, "+
				"update failed, CveNum:", cveData.CveNum, ",errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else if scoreerr {
		errx := models.UpdateCveRelat1(&CveRes, &SecNOtice)
		if errx != nil {
			logs.Error("InsertCveExcelGroups, UpdateCveRelat1, "+
				"update failed, CveNum:", cveData.CveNum, ",errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else {
		errx := models.UpdateCveRelat2(&CveRes, &scoreRes)
		if errx != nil {
			logs.Error("InsertCveExcelGroups, UpdateCveRelat2, "+
				"update failed, CveNum:", cveData.CveNum, ", errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	}
	return true, nil
}

func genSecurityNoticeDescription(goe models.GitPackageInfo, cveDesc models.OriginUpstreamDesc, CveRes models.VulnCenter) string {
	if goe.Decription != "" && len(goe.Decription) > 0 {
		return goe.Decription + "\n\n" + "Security Fix(es):" + "\n\n" + cveDesc.EnDescription + "(" + CveRes.CveNum + ")"
	}

	return "Security Fix(es):" + "\n\n" + cveDesc.EnDescription + "(" + CveRes.CveNum + ")"
}

func InsertCveGroups(cveData models.OriginUpstream, cveRef, repoNme string,
	openeulerNum int, cveDesc models.OriginUpstreamDesc,
	cveScV3 models.OriginUpstreamImpactScoreV3, goe models.GitPackageInfo,
	scopeType string, cveScV2 models.OriginUpstreamImpactScoreV2,
	pkList []string, organizationID int8) (bool, error) {
	var vul models.VulnCenter
	vul.CveNum = cveData.CveNum
	vul.FirstPerTime = cveData.FirstPerTime
	vul.FirstGetTime = cveData.FirstGetTime
	vul.Description = cveDesc.EnDescription
	vul.Status = 0
	vul.CveVersion = pkList[1]
	vul.RepairTime = cveData.PublishedDate
	vul.RepoName = pkList[0]
	vul.PackName = repoNme
	vul.CveUrl = cveRef + cveData.CveNum
	vul.CveLevel = cveScV3.CveLevel
	if common.GetCveSource(cveData.CveNum) == 1 || common.GetCveSourceRecord(cveData.CveNum) == 1 {
		vul.DataSource = 5
	} else {
		vul.DataSource = 1
	}
	vul.IsExport = 0
	vul.OrganizationID = organizationID
	var sec models.SecurityNotice
	sec.CveNum = cveData.CveNum
	sec.InfluenceComponent = pkList[0]
	sec.Status = 0
	sec.AffectStatus = "Fixed"
	sec.Summary = pkList[0] + " security update"
	sec.ReferenceLink = cveRef + cveData.CveNum
	specCharList := []string{"\n", "\r", "\t"}
	if len(goe.Decription) < 1 {
		goe.Decription = goe.Summary
	}
	if goe.Decription != "" && len(goe.Decription) > 0 {
		sec.Description = RemoveSubstring(goe.Decription, specCharList) + "\n\n" + "Security Fix(es):" + "\n\n" +
			RemoveSubstring(cveDesc.EnDescription, specCharList)
	} else {
		sec.Description = "Security Fix(es):" + "\n\n" + RemoveSubstring(cveDesc.EnDescription, specCharList)
	}
	if sec.Description != "" && len(sec.Description) > 1 {
		sec.Description = deleteTailBlank(sec.Description) + "(" + vul.CveNum + ")"
	} else {
		sec.Description += "(" + vul.CveNum + ")"
	}
	var sc models.Score
	sc.CveNum = cveData.CveNum
	sc.Nstatus = 0
	sc.Ostatus = 0
	if scopeType == "v3" {
		sc.NVDScore = cveScV3.BaseScore
		sc.OpenEulerScore = cveScV3.BaseScore
		vectorString := ""
		if cveScV3.VectorString != "" && len(cveScV3.VectorString) > 0 {
			index := strings.IndexAny(cveScV3.VectorString, "/")
			if index > 0 && strings.ToLower(cveScV3.VectorString)[:4] == "cvss" {
				vectorString = cveScV3.VectorString[index+1:]
			} else {
				vectorString = cveScV3.VectorString
			}
		}
		sc.NvectorVule = vectorString
		sc.OvectorVule = vectorString
		sc.NattackVector = cveScV3.AttackVector
		sc.OattackVector = cveScV3.AttackVector
		sc.NattackComplexity = cveScV3.AttackComplexity
		sc.OattackComplexity = cveScV3.AttackComplexity
		sc.NprivilegeRequired = cveScV3.PrivilegesRequired
		sc.OprivilegeRequired = cveScV3.PrivilegesRequired
		sc.NuserInteraction = cveScV3.UserInteraction
		sc.OuserInteraction = cveScV3.UserInteraction
		sc.Nscope = cveScV3.Scope
		sc.Oscope = cveScV3.Scope
		sc.Nconfidentiality = cveScV3.ConfidentialityImpact
		sc.Oconfidentiality = cveScV3.ConfidentialityImpact
		sc.Nintegrity = cveScV3.IntegrityImpact
		sc.Ointegrity = cveScV3.IntegrityImpact
		sc.Navailability = cveScV3.AvailabilityImpact
		sc.Oavailability = cveScV3.AvailabilityImpact
	} else {
		sc.NVDScore = cveScV2.BaseScore
		sc.OpenEulerScore = cveScV2.BaseScore
		vectorString := ""
		if cveScV2.VectorString != "" && len(cveScV2.VectorString) > 0 {
			index := strings.IndexAny(cveScV2.VectorString, "/")
			if index > 0 && strings.ToLower(cveScV2.VectorString)[:4] == "cvss" {
				vectorString = cveScV2.VectorString[index+1:]
			} else {
				vectorString = cveScV2.VectorString
			}
		}
		sc.NvectorVule = vectorString
		sc.OvectorVule = vectorString
		sc.NaccessVector = cveScV2.AccessVector
		sc.OaccessVector = cveScV2.AccessVector
		sc.NaccessComplexity = cveScV2.AccessComplexity
		sc.OaccessComplexity = cveScV2.AccessComplexity
		sc.Nauthentication = cveScV2.Authentication
		sc.Oauthentication = cveScV2.Authentication
		sc.Nconfidentiality = cveScV2.ConfidentialityImpact
		sc.Oconfidentiality = cveScV2.ConfidentialityImpact
		sc.Nintegrity = cveScV2.IntegrityImpact
		sc.Ointegrity = cveScV2.IntegrityImpact
		sc.Navailability = cveScV2.AvailabilityImpact
		sc.Oavailability = cveScV2.AvailabilityImpact
	}
	sc.ScoreType = scopeType
	var opensa models.OpenEulerSA
	//var os models.OpenSaId
	osx, operr := models.QueryOpenSaLastId()
	var OpenNumData int
	if operr == nil {
		OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
		OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
		if err == nil {
			OpenNum += 1
		} else {
			OpenNum = openeulerNum
		}
		OpenNumData = OpenNum
	} else {
		OpenNumData = openeulerNum
	}
	OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
	opensa.OpenEulerSANum = OpenEulerSANum
	var scorecode models.ScoreRecord
	scorecode.NVDScore = cveScV3.BaseScore
	scorecode.NvectorVule = cveScV3.VectorString
	scorecode.Status = 0
	cveId, cveErr := models.CreateCveRelat(&vul, &sec, &sc, &opensa, &scorecode)
	if cveErr != nil || cveId <= 0 {
		logs.Error("InsertCveGroups, CreateCveRelat, insert failed, "+
			"CveNum:", cveData.CveNum, ",cveErr: ", cveErr)
		return false, errors.New("数据插入失败, 暂时不处理")
	}
	return true, nil
}

// Synchronize the data returned by the Chinese Academy of Sciences
func GenCveVuler(cveData models.OriginUpstream, cveRef string, openeulernum int) (bool, error) {
	if cveData.Ids == "" || cveData.CveNum == "" {
		logs.Error("GenCveVuler, The current data cveNum is empty "+
			"and will not be processed temporarily, data: ", cveData)
		models.UpdateOriginStatus(common.GetCurTime(),
			cveData.PackName, cveData.Version, cveData.CveId, 3)
		UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum, "ids or cveNum is empty", 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	BConfig, err := config.NewConfig("ini", "conf/app.conf")
	if err != nil {
		logs.Error("GenCveVuler, config init error:", err, cveData.CveNum)
		models.UpdateOriginStatus(common.GetCurTime(),
			cveData.PackName, cveData.Version, cveData.CveId, 0)
		return false, err
	}
	years, confOk := BConfig.Int("cve::cve_number_t")
	if confOk != nil {
		logs.Error("GenCveVuler, config cve::cve_number_t, error:", confOk, cveData.CveNum)
		models.UpdateOriginStatus(common.GetCurTime(),
			cveData.PackName, cveData.Version, cveData.CveId, 0)
		return false, errors.New("数据错误，暂时不处理")
	}
	// Import cve as data after 2018
	cveNumList := strings.Split(cveData.CveNum, "-")
	if cveNumList != nil && len(cveNumList) > 1 {
		cveYears, yearErr := strconv.Atoi(cveNumList[1])
		if yearErr == nil {
			if cveYears <= years {
				models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 5)
				logs.Error("GenCveVuler, cve: ", cveData.CveNum, ",Need to be greater than: ", years,
					", Otherwise there is no need to submit an issue on git, cveData: ", cveData)
				UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum, cveData.CveNum+" cve year limited", 5)
				return false, errors.New("数据错误，暂时不处理")
			}
		}
	}
	cveDesc, ok := models.QueryCveDesc(cveData.CveId)
	if !ok {
		logs.Error("GenCveVuler, QueryCveDesc, The current data description is empty "+
			"and will not be processed temporarily, data: ", cveData)
		models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
		UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum, "cve description information is empty", 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	cveImpact, ok := models.QueryCveImpact(cveData.CveId)
	if !ok {
		logs.Error("GenCveVuler, QueryCveImpact, Data query failed, data: ", cveData)
		models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
		UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum, "cve score information is empty 1", 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	scopeType := "v3"
	//var cveScV2 models.OriginUpstreamImpactScoreV2
	cveScore, ok := models.QueryCveScore(cveImpact.ImpactId, "v3")
	if !ok {
		scopeType = "v2"
	}
	cveScV3, ok := models.QueryCveCvssV3(cveScore.ScoreId)
	if !ok {
		scopeType = "v2"
	}
	if cveScV3.VectorString == "" || len(cveScV3.VectorString) == 0 || cveScV3.BaseScore == 0.0 {
		scopeType = "v2"
	}
	cveScoreV2, ok2 := models.QueryCveScore(cveImpact.ImpactId, "v2")
	if !ok2 {
		if scopeType == "v2" {
			logs.Error("GenCveVuler, QueryCveScore3, data: ", cveData, ",cveImpact: ", cveImpact)
			models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
			UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum, "cve score information is empty 2", 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	}
	cveScV2, okV2 := models.QueryCveCvssV2(cveScoreV2.ScoreId)
	if !okV2 {
		if scopeType == "v2" {
			logs.Error("GenCveVuler, QueryCveCvssV2, data: ", cveData, ",cveScore: ", cveScore)
			models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
			UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum, "cve score information is empty 3", 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	}
	packNameMap := map[string]string{}
	packNameList := []string{}
	if cveData.PackName != "" && len(cveData.PackName) > 0 {
		packNameList = strings.Split(cveData.PackName, ",")
		if len(packNameList) > 0 {
			for _, pk := range packNameList {
				pkList := strings.Split(pk, "==")
				if len(pkList) == 2 {
					if _, ok := packNameMap[pkList[0]]; ok {
						versionList := strings.Split(packNameMap[pkList[0]], ",")
						verExist := false
						for _, vl := range versionList {
							if vl == pkList[1] {
								verExist = true
								break
							}
						}
						if !verExist {
							packNameMap[pkList[0]] += "," + pkList[1]
						}
					} else {
						packNameMap[pkList[0]] = pkList[1]
					}
				}
			}
		}
	}
	for key, value := range packNameMap {
		if key != "" && len(key) > 1 {
			pkList := []string{}
			pkList = append(pkList, key)
			eulerFlag := false
			gaussFlag := false
			sporeFlag := false
			looKengFlag := false
			var goe models.GitPackageInfo
			pvList := make([]PackageVersion, 0)
			openGausVersion := make([]string, 0)
			mindSporeVersion := make([]string, 0)
			mindSporeids := make([]string, 0)
			openEulerVersion := make([]string, 0)
			openLooKengVersion := make([]string, 0)
			versionList := make([]string, 0)
			if value != "" && len(value) > 0 {
				versionList = strings.Split(value, ",")
				if len(versionList) > 0 {
					for _, ver := range versionList {
						if ver != "" && len(ver) > 0 {
							opy := models.OpenGussYaml{PackageName: key, Version: ver}
							gaussErr := models.GetOpengaussYaml(&opy, "PackageName", "Version")
							if gaussErr == nil && opy.Id > 0 {
								openGausVersion = append(openGausVersion, ver)
								gaussFlag = true
							}
							if flag, ids := judgeSocpe(key, ver); flag && len(ids) > 0 {
								mindSporeids = append(mindSporeids, ids...)
								mindSporeVersion = append(mindSporeVersion, ver)
								sporeFlag = true
							}
							olky := models.OpenLookengYaml{PackageName: key, Version: ver}
							looKengErr := models.GetOpenLookengYaml(&olky, "PackageName", "Version")
							if looKengErr == nil && olky.Id > 0 {
								openLooKengVersion = append(openLooKengVersion, ver)
								looKengFlag = true
							}
							goe, ok = models.QueryCveOpeneulerDetaildataByName(key, ver)
							if ok {
								eulerFlag = true
								openEulerVersion = append(openEulerVersion, ver)
							} else {
								logs.Error("GenCveVuler, The corresponding warehouse data is not queried, data: ", cveData)
							}
						}
					}
				}
			}
			if !eulerFlag && !gaussFlag && !sporeFlag && !looKengFlag {
				models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 4)
				logs.Error("GenCveVuler, The version information corresponds to the error, ",
					cveData.PackName, cveData.Version, cveData.CveNum)
				UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum,
					"The cve component or version information cannot be matched to the corresponding data", 4)
				continue
			}
			organizationID := int8(1)
			if eulerFlag {
				openEulerVersion = common.RemoveDupString(openEulerVersion)
				pv := PackageVersion{OrganizationID: organizationID, VerionList: openEulerVersion}
				pvList = append(pvList, pv)
			}
			if gaussFlag {
				organizationID = int8(2)
				openGausVersion = common.RemoveDupString(openGausVersion)
				pv := PackageVersion{OrganizationID: organizationID, VerionList: openGausVersion}
				pvList = append(pvList, pv)
			}
			if sporeFlag {
				organizationID = int8(3)
				mindSporeVersion = common.RemoveDupString(mindSporeVersion)
				pv := PackageVersion{OrganizationID: organizationID, VerionList: mindSporeVersion, ids: mindSporeids}
				pvList = append(pvList, pv)
			}
			if looKengFlag {
				organizationID = int8(4)
				openLooKengVersion = common.RemoveDupString(openLooKengVersion)
				pv := PackageVersion{OrganizationID: organizationID, VerionList: openLooKengVersion}
				pvList = append(pvList, pv)
			}
			failFlag := false
			ok, addErr := AddOrSelectToCenter(key, cveRef, scopeType, value, cveData,
				pvList, pkList, openeulernum, cveDesc, cveScV3, goe, cveScV2)
			if !ok || addErr != nil {
				logs.Error("AddOrSelectToCenter, addErr: ", addErr)
				failFlag = true
			}
			if failFlag {
				logs.Error("Part of the data failed")
				models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
				UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum,
					"Version does not match, data synchronization failed", 3)
				continue
			}
		}
	}
	models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 2)
	UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum, "success", 2)
	return true, nil
}

func AddOrSelectToCenter(packageName, cveRef, scopeType, value string, cveData models.OriginUpstream,
	pvList []PackageVersion, pkList []string, openeulerNum int,
	cveDesc models.OriginUpstreamDesc, cveScV3 models.OriginUpstreamImpactScoreV3, goe models.GitPackageInfo,
	cveScV2 models.OriginUpstreamImpactScoreV2) (bool, error) {
	for _, pv := range pvList {
		organizationID := pv.OrganizationID
		if organizationID == 4 {
			looKengVersion := pv.VerionList
			if len(looKengVersion) > 0 {
				looKengMap := make(map[string]string)
				for _, ver := range looKengVersion {
					olky := models.OpenLookengYaml{PackageName: packageName, Version: ver}
					msy, mErr := models.GetOpenLookengYamlAll(&olky)
					if len(msy) > 0 {
						for _, my := range msy {
							if _, ok := looKengMap[my.Repo]; !ok {
								looKengMap[my.Repo] = packageName
							}
						}
					} else {
						logs.Error("openLooKeng, mErr: ", mErr)
					}
				}
				if len(looKengMap) > 0 {
					for repo, _ := range looKengMap {
						ok, dErr := AddOrDataToCenter(repo, packageName, cveRef, scopeType, value, cveData,
							looKengVersion, pkList, openeulerNum,
							cveDesc, cveScV3, goe, cveScV2, pv.OrganizationID)
						if !ok {
							logs.Error("MindSpore, dErr: ", dErr)
						}
					}
				}
			}
		} else if organizationID == 3 {
			mindSporeVersion := pv.VerionList
			if len(pv.ids) > 0 && len(mindSporeVersion) > 0 {
				list, err := models.GetMindSporeYamlForids(pv.ids)
				mindMap := make(map[string]string)
				if err == nil && len(list) > 0 {
					for _, my := range list {
						if _, ok := mindMap[my.Repo]; !ok {
							mindMap[my.Repo] = packageName
						}
					}
				}
				if len(mindMap) > 0 {
					for repo, _ := range mindMap {
						ok, dErr := AddOrDataToCenter(repo, packageName, cveRef, scopeType, value, cveData,
							mindSporeVersion, pkList, openeulerNum,
							cveDesc, cveScV3, goe, cveScV2, organizationID)
						if !ok {
							logs.Error("MindSpore, dErr: ", dErr)
						}
					}
				}
			}
		} else if organizationID == 2 {
			openGausVersion := pv.VerionList
			if len(openGausVersion) > 0 {
				gaussMap := make(map[string]string)
				for _, ver := range openGausVersion {
					opy := models.OpenGussYaml{PackageName: packageName, Version: ver}
					ogy, oErr := models.GetOpengaussYamlAll(&opy)
					if len(ogy) > 0 {
						for _, gy := range ogy {
							if _, ok := gaussMap[gy.Repo]; !ok {
								gaussMap[gy.Repo] = packageName
							}
						}
					} else {
						logs.Error("openGauss, dErr: ", oErr)
					}
				}
				if len(gaussMap) > 0 {
					for repo, _ := range gaussMap {
						ok, dErr := AddOrDataToCenter(repo, packageName, cveRef, scopeType, value, cveData,
							openGausVersion, pkList, openeulerNum,
							cveDesc, cveScV3, goe, cveScV2, organizationID)
						if !ok {
							logs.Error("openGauss, dErr: ", dErr)
						}
					}
				}
			}
		} else {
			openEulerVersion := pv.VerionList
			ok, dErr := AddOrDataToCenter(packageName, packageName, cveRef, scopeType, value, cveData,
				openEulerVersion, pkList, openeulerNum,
				cveDesc, cveScV3, goe, cveScV2, organizationID)
			if !ok {
				logs.Error("openEuler, dErr: ", dErr)
				return false, dErr
			}
		}
	}
	return true, nil
}

func AddOrDataToCenter(repoNme, packageName, cveRef, scopeType, value string, cveData models.OriginUpstream,
	versionList, pkList []string, openeulerNum int,
	cveDesc models.OriginUpstreamDesc, cveScV3 models.OriginUpstreamImpactScoreV3, goe models.GitPackageInfo,
	cveScV2 models.OriginUpstreamImpactScoreV2, organizationID int8) (bool, error) {
	if repoNme == "OpenSSL" && organizationID == 1 {
		return true, nil
	}
	CveRes, err := models.QueryCveByNum(cveData.CveNum, repoNme, packageName, organizationID)
	if err {
		CveRes.RepoName = packageName
		if CveRes.DataSource == 1 || CveRes.DataSource == 5 {
			retVersion := " "
			if len(versionList) > 0 {
				retVersion = strings.Join(versionList, ",")
			}
			pkList = append(pkList, retVersion)
		} else {
			retVersion := AddCveVersion(organizationID, versionList, CveRes.CveVersion)
			pkList = append(pkList, retVersion)
		}
		lockx.Lock()
		ok, err := UpdateCveGroups(cveData, cveRef, openeulerNum, CveRes, cveDesc, cveScV3, goe,
			scopeType, cveScV2, pkList, organizationID)
		lockx.Unlock()
		if !ok {
			logs.Error("GenCveVuler, UpdateCveGroups, cveData: ", cveData, ", err: ", err)
			//models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	} else {
		retVersion := AddCveVersion(organizationID, versionList, "")
		if len(retVersion) > 0 {
			pkList = append(pkList, retVersion)
		} else {
			pkList = append(pkList, " ")
		}
		lockx.Lock()
		ok, err := InsertCveGroups(cveData, cveRef, repoNme, openeulerNum, cveDesc, cveScV3, goe,
			scopeType, cveScV2, pkList, organizationID)
		lockx.Unlock()
		if !ok {
			logs.Error("GenCveVuler, InsertCveGroups, cveData: ", cveData, ", err: ", err)
			//models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	}
	return true, nil
}

func UpdateOriginUpstreamRecord(ids, cveNum, errDesc string, errStatus int8) {
	our := models.OriginUpstreamRecord{}
	err := models.QueryOriginUpstreamRecord(&our, ids, cveNum)
	if our.CveId > 0 {
		our.SysStatus = errStatus
		our.ErrDesc = errDesc
		upErr := models.UpdateOriginUpstreamRecord(&our, "SysStatus", "ErrDesc")
		if upErr != nil {
			logs.Error("upErr: ", upErr)
		}
	} else {
		logs.Error("err: ", err)
	}
}

func AddCveVersion(organizationID int8, versionList []string, cveVersion string) (retVersion string) {
	retVersion = cveVersion
	cveVerList := []string{}
	if len(cveVersion) > 0 {
		cveVerList = strings.Split(cveVersion, ",")
	}
	if organizationID != 1 {
		if len(cveVerList) > 0 && len(versionList) > 0 {
			versionList = append(versionList, cveVerList...)
		}
		verSlice := make([]string, 0)
		verSlice = common.RemoveDupString(versionList)
		if len(verSlice) > 0 {
			retVersion = strings.Join(verSlice, ",")
		}
	} else {
		if len(cveVerList) > 0 && len(versionList) > 0 {
			versionList = append(versionList, cveVerList...)
		}
		eulerSlice := make([]string, 0)
		if len(versionList) > 0 {
			tmpEulerSlice := make([]string, len(versionList))
			for _, es := range versionList {
				if len(es) > 0 {
					versx := common.BranchVersionRep(es)
					tmpEulerSlice = append(tmpEulerSlice, versx)
				}
			}
			eulerSlice = common.RemoveDupString(tmpEulerSlice)
		}
		if len(eulerSlice) > 0 {
			retVersion = strings.Join(eulerSlice, ",")
		}
	}
	if len(retVersion) > 0 {
		verList := make([]string, 0)
		tmpVer := strings.Split(retVersion, ",")
		for _, ver := range tmpVer {
			if len(ver) > 0 && ver != " " {
				verList = append(verList, ver)
			}
		}
		if len(verList) > 0 {
			retVersion = strings.Join(verList, ",")
		} else {
			retVersion = " "
		}
	}
	if len(retVersion) > 0 && retVersion[0] == ',' {
		retVersion = retVersion[1:]
	}
	return retVersion
}

func SyncCveVuler(cveData models.OriginExcel, cveRef string, openeulerNum, manYears int) (bool, error) {
	if cveData.CveNum == "" || len(cveData.CveNum) == 0 {
		logs.Error("SyncCveVuler, The current data cveNum is empty and "+
			"will not be processed temporarily, data: ", cveData)
		models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	organizationID := int8(1)
	organizationList := make([]int8, 0)
	olky := models.OpenLookengYaml{PackageName: cveData.PackName, Version: cveData.CveVersion}
	looKengErr := models.GetOpenLookengYaml(&olky, "PackageName", "Version")
	if looKengErr == nil && olky.Id > 0 {
		organizationID = 4
		organizationList = append(organizationList, organizationID)
	}
	//ms := models.MindSporeYaml{PackageName: cveData.PackName, Version: cveData.CveVersion}
	//sporeErr := models.GetMindSporeYaml(&ms, "PackageName", "Version")
	//if sporeErr == nil && ms.Id > 0 {
	//	organizationID = 3
	//	organizationList = append(organizationList, organizationID)
	//}
	if flag, _ := judgeSocpe(cveData.PackName, cveData.CveVersion); flag {
		organizationID = 3
		organizationList = append(organizationList, organizationID)
	}
	opy := models.OpenGussYaml{PackageName: cveData.PackName, Version: cveData.CveVersion}
	openErr := models.GetOpengaussYaml(&opy, "PackageName", "Version")
	if openErr == nil && opy.Id > 0 {
		organizationID = 2
		organizationList = append(organizationList, organizationID)
	}
	var god models.GitOpenEuler
	god.PackageName = cveData.PackName
	god.Version = cveData.CveVersion
	god.Status = 1
	ok := models.QueryCveOpeneulerdata(&god)
	if !ok {
		if organizationID == 1 {
			logs.Error("The repo and version correspond to errors, data: ", cveData)
			models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 4)
			return false, errors.New("The repo and version correspond to errors and" +
				" will not be processed temporarily")
		}
	} else {
		organizationList = append(organizationList, organizationID)
	}
	// Import cve as data after 2018
	cveNumList := strings.Split(cveData.CveNum, "-")
	if cveNumList != nil && len(cveNumList) > 1 {
		cveYears, yearErr := strconv.Atoi(cveNumList[1])
		if yearErr == nil {
			if cveYears <= manYears {
				logs.Error("limited cve years, cveData: ", cveData, ", err: ", cveYears, manYears)
				models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 7)
				return false, errors.New("limited cve years")
			}
		}
	}
	goe, ok := models.QueryCveOpeneulerDetaildataByName(cveData.PackName, cveData.CveVersion)
	if !ok {
		logs.Error("SyncCveVuler, The repo exists, but the yaml data source does not exist,"+
			" repo: ", cveData.PackName, cveData.CveVersion)
	}
	failFlag := false
	for _, orId := range organizationList {
		exOk, exErr := AddExcelToCenter(cveData, cveRef, openeulerNum, goe, orId)
		if !exOk || exErr != nil {
			logs.Error("AddExcelToCenter, exErr: ", exErr)
			failFlag = true
		}
	}
	if failFlag {
		models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 2)
	return true, nil
}

func AddExcelToCenter(cveData models.OriginExcel, cveRef string, openeulerNum int,
	goe models.GitPackageInfo, organizationID int8) (bool, error) {
	if organizationID == 4 {
		olky := models.OpenLookengYaml{PackageName: cveData.PackName, Version: cveData.CveVersion}
		opy, mErr := models.GetOpenLookengYamlAll(&olky)
		if len(opy) > 0 {
			for _, my := range opy {
				ok, dErr := AddExDataToCenter(cveData, cveRef, my.Repo, openeulerNum, goe, organizationID)
				if !ok {
					logs.Error("MindSpore, dErr: ", dErr)
					return ok, dErr
				}
			}
		} else {
			logs.Error("MindSpore, mErr: ", mErr)
			return false, mErr
		}
	} else if organizationID == 3 {
		if flag, ids := judgeSocpe(cveData.PackName, cveData.CveVersion); flag && len(ids) > 0 {
			msy, mErr := models.GetMindSporeYamlForids(ids)
			if len(msy) > 0 {
				for _, my := range msy {
					ok, dErr := AddExDataToCenter(cveData, cveRef, my.Repo, openeulerNum, goe, organizationID)
					if !ok {
						logs.Error("MindSpore, dErr: ", dErr)
						return ok, dErr
					}
				}
			} else {
				logs.Error("MindSpore, mErr: ", mErr)
				return false, mErr
			}
		}
	} else if organizationID == 2 {
		opy := models.OpenGussYaml{PackageName: cveData.PackName, Version: cveData.CveVersion}
		ogy, oErr := models.GetOpengaussYamlAll(&opy)
		if len(ogy) > 0 {
			for _, gy := range ogy {
				ok, dErr := AddExDataToCenter(cveData, cveRef, gy.Repo, openeulerNum, goe, organizationID)
				if !ok {
					logs.Error("openGauss, dErr: ", dErr)
					return ok, dErr
				}
			}
		} else {
			logs.Error("openGauss, oErr: ", oErr)
			return false, oErr
		}
	} else {
		ok, dErr := AddExDataToCenter(cveData, cveRef, cveData.PackName, openeulerNum, goe, organizationID)
		if !ok {
			logs.Error("openEuler, dErr: ", dErr)
			return ok, dErr
		}
	}
	return true, nil
}

func AddExDataToCenter(cveData models.OriginExcel,
	cveRef, repoName string, openeulerNum int,
	goe models.GitPackageInfo, organizationID int8) (bool, error) {
	CveRes, err := models.QueryCveByNum(cveData.CveNum, repoName, cveData.PackName, organizationID)
	if err {
		CveRes.RepoName = cveData.PackName
		retVersion := AddCveVersion(organizationID, []string{cveData.CveVersion}, CveRes.CveVersion)
		cveData.CveVersion = retVersion
		lockx.Lock()
		ok, err := UpdateExcelCveGroups(cveData, cveRef, openeulerNum, CveRes, goe, organizationID)
		lockx.Unlock()
		if !ok {
			logs.Error("AddExDataToCenter, UpdateExcelCveGroups, cveData: ", cveData, ", err: ", err)
			models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	} else {
		retVersion := AddCveVersion(organizationID, []string{cveData.CveVersion}, "")
		cveData.CveVersion = retVersion
		lockx.Lock()
		ok, err := InsertCveExcelGroups(cveData, cveRef, repoName, openeulerNum, goe, organizationID)
		lockx.Unlock()
		if !ok {
			logs.Error("AddExDataToCenter, InsertCveExcelGroups, cveData: ", cveData, ", err: ", err)
			models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	}
	return true, nil
}

func GetCveOriginData(prcnum, days, openeulernum, credibilityLevel int, cveRef string, list []string) (bool, error) {
	defer common.Catchs()
	count := 0
	beforeTime := common.GetBeforeTime(days)
	for {
		osx, num, err := models.QueryOriginCve(beforeTime, prcnum, credibilityLevel, list)
		if err != nil || num == 0 {
			logs.Info("There is currently no cve raw data processing, err: ", err,
				", Processing time range > beforetime: ", beforeTime,
				"curtime: ", common.GetCurTime())
			break
		}
		ch := make(chan int, len(osx))
		for i, cveOrg := range osx {
			count = count + 1
			// Add mutex
			if cveOrg.Credibility > 3 && cveOrg.CveId <= 20557 {
				ch <- i
				continue
			}
			lockOk := models.LockUpdateOriginStatus(common.GetCurTime(), cveOrg.PackName,
				cveOrg.Version, cveOrg.CveId, cveOrg.Status, 15)
			if !lockOk {
				logs.Error("Current data is being processed: PackName: ",
					cveOrg.PackName, cveOrg.Version, cveOrg.CveId)
				ch <- i
				continue
			}
			go func(idx int, cveData models.OriginUpstream, locOpenEulernum int, locCveRef string) {
				ok, err := GenCveVuler(cveData, locCveRef, locOpenEulernum)
				if !ok {
					logs.Error("GenCveVuler, cveData: ", cveData, "Processing failed, err: ", err)
				}
				ch <- idx
			}(i, cveOrg, openeulernum, cveRef)
		}
		for i := 0; i < cap(ch); i++ {
			<-ch
		}
		close(ch)
	}
	return true, nil
}

func GetCveOriginExcelData(prcnum, days, openeulerNum int, cveRef string) (bool, error) {
	defer common.Catchs()
	manYears, ok := beego.AppConfig.Int("cve::cve_number_m")
	if ok != nil {
		logs.Error("config cve::manYears error:", ok)
		return false, ok
	}
	count := 0
	beforeTime := common.GetBeforeTime(days)
	for {
		osx, num, err := models.QueryOriginCveExcel(beforeTime, prcnum)
		if err != nil || num == 0 {
			logs.Info("There is currently no cve raw data processing imported by excel, err: ", err,
				", beforetime: ", beforeTime,
				"curtime: ", common.GetCurTime())
			break
		}
		logs.Info("Excel has a total of: ", num, "Articles of data need to be processed,", osx)
		ch := make(chan int, len(osx))
		for i, cveOrg := range osx {
			count = count + 1
			logs.Info("The current normal analysis: ", count, "Pieces of data, i:", i, ", cvenum: ", cveOrg.CveNum)
			// add mutex
			lockOk := models.LockUpdateOriginExcelStatus(common.GetCurTime(), cveOrg.CveId, 15)
			if !lockOk {
				logs.Error("Current data is being processed, cveNum: ", cveOrg.CveNum, ",cveId: ", cveOrg.CveId)
				ch <- i
				continue
			}
			go func(idx, manYears, locOpeneulerNum int, cveData models.OriginExcel, locCveRef string) {
				ok, err := SyncCveVuler(cveData, locCveRef, openeulerNum, manYears)
				if !ok {
					logs.Error("SyncCveVuler, err: ", err, "cveData: ", cveData)
				}
				ch <- idx
			}(i, manYears, openeulerNum, cveOrg, cveRef)
		}
		for i := 0; i < cap(ch); i++ {
			<-ch
		}
		close(ch)
	}
	return true, nil
}

func InsertIssueCveGroups(cveData models.GiteOriginIssue, lop models.Loophole, cveRef string, openeulernum int,
	cveStatus int8, goe models.GitPackageInfo, owner string) (bool, error) {
	var vul models.VulnCenter
	vul.CveNum = cveData.CveNumber
	specCharList := []string{"</br><br>", "\n", "\r", "\t"}
	briefIntroduction := RemoveSubstring(lop.BriefIntroduction, specCharList)
	vul.Description = briefIntroduction
	vul.Status = cveStatus
	vul.OrganizationID = cveData.OrganizationID
	accessToken := ""
	owner, accessToken = common.GetOwnerAndToken(vul.CveNum, vul.OrganizationID)
	retVersion := AddCveVersion(vul.OrganizationID,
		strings.Split(RemoveSubstring(lop.Version, specCharList), ","), "")
	vul.CveVersion = retVersion
	repair := tabletask.GetRepair(cveData.CveNumber)
	if len(repair) > 0 {
		vul.RepairTime = repair
	} else {
		vul.RepairTime = ""
	}
	vul.PackName = cveData.RepoPath
	vul.RepoName = cveData.RepoPath
	vul.CveUrl = cveRef + cveData.CveNumber
	vul.IsExport = 0
	vul.DataSource = 4
	v2, cvsError := strconv.ParseFloat(lop.CvsScore, 64)
	if cvsError != nil {
		vul.CveLevel = "Critical"
	}
	if len(briefIntroduction) < 2 || v2 <= 0 || len(lop.CvsVector) < 1 &&
		cveData.IssueState != "已拒绝" && cveData.IssueState != "已挂起" {
		vul.Status = 1
	}
	vul.CveLevel = models.OpenEulerScoreProc(v2)
	var sec models.SecurityNotice
	sec.CveNum = cveData.CveNumber
	sec.InfluenceComponent = cveData.RepoPath
	sec.Status = 0
	sec.AffectStatus = "Fixed"
	sec.Summary = cveData.RepoPath + " security update"
	if len(goe.Decription) < 1 {
		goe.Decription = goe.Summary
	}
	sec.Description = RemoveSubstring(goe.Decription, specCharList) + "\n\n" + "Security Fix(es):" + "\n\n" +
		RemoveSubstring(lop.BriefIntroduction, specCharList)
	if sec.Description != "" && len(sec.Description) > 1 {
		sec.Description = deleteTailBlank(sec.Description) + "(" + vul.CveNum + ")"
	} else {
		sec.Description += "(" + vul.CveNum + ")"
	}
	opScoreLeve := ""
	opScore, opError := strconv.ParseFloat(lop.OpScore, 64)
	if opError != nil {
		opScoreLeve = "Critical"
	} else {
		opScoreLeve = models.OpenEulerScoreProc(opScore)
	}
	sec.ReferenceLink = cveRef + cveData.CveNumber
	affectBrands := ""
	if lop.InfVersion != "" && len(lop.InfVersion) > 1 {
		affectBrands = AddAffectBrands(lop.InfVersion)
	} else {
		affectBrands = lop.InfProduct
	}
	sec.Introduction = "An update for " + cveData.RepoPath + " is now available for " + affectBrands + "."
	sec.Theme = sec.Introduction[:len(sec.Introduction)-1] + ".\n\n" + "openEuler Security has rated this" +
		" update as having a security impact of " + strings.ToLower(opScoreLeve) + ". A Common Vunlnerability" +
		" Scoring System(CVSS)base score,which gives a detailed severity rating," +
		" is available for each vulnerability from the CVElink(s) in the References section."
	sec.AffectProduct = affectBrands
	var sc models.Score
	sc.CveNum = cveData.CveNumber
	nVDScore, nvdError := strconv.ParseFloat(lop.CvsScore, 64)
	if nvdError == nil {
		sc.NVDScore = nVDScore
	}
	openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
	if openError == nil {
		sc.OpenEulerScore = openEulerScore
	}
	sc.NvectorVule = lop.CvsVector
	sc.OvectorVule = lop.OpVector
	sc.Nstatus = 0
	sc.Ostatus = 0
	sc.ScoreType = lop.ScoreType
	if sc.ScoreType == "v3" {
		vectorN := models.VectorValue{}
		ok := vectorN.VctToVectorValue(lop.CvsVector)
		if ok {
			sc.NattackVector = vectorN.AttackVector
			sc.NattackComplexity = vectorN.AttackComplexity
			sc.NprivilegeRequired = vectorN.PrivilegesRequired
			sc.NuserInteraction = vectorN.UserInteraction
			sc.Nscope = vectorN.Scope
			sc.Nconfidentiality = vectorN.Confidentiality
			sc.Nintegrity = vectorN.Integrity
			sc.Navailability = vectorN.Availability
		}
		vectorO := models.VectorValue{}
		vectOk := vectorO.VctToVectorValue(lop.OpVector)
		if vectOk {
			sc.OattackVector = vectorO.AttackVector
			sc.OattackComplexity = vectorO.AttackComplexity
			sc.OprivilegeRequired = vectorO.PrivilegesRequired
			sc.OuserInteraction = vectorO.UserInteraction
			sc.Oscope = vectorO.Scope
			sc.Oconfidentiality = vectorO.Confidentiality
			sc.Ointegrity = vectorO.Integrity
			sc.Oavailability = vectorO.Availability
		}
	}
	if sc.ScoreType == "v2" {
		vectorN2 := models.VectorValueV2{}
		ok := vectorN2.VctToVectorValue(lop.CvsVector)
		if ok {
			sc.NaccessVector = vectorN2.AccessVector
			sc.NaccessComplexity = vectorN2.AccessComplexity
			sc.Navailability = vectorN2.Availability
			sc.Nconfidentiality = vectorN2.Confidentiality
			sc.Nintegrity = vectorN2.IntegrityImpact
			sc.Nauthentication = vectorN2.Authentication
		}
		vectorO2 := models.VectorValueV2{}
		vectOk := vectorO2.VctToVectorValue(lop.OpVector)
		if vectOk {
			sc.OaccessVector = vectorO2.AccessVector
			sc.OaccessComplexity = vectorO2.AccessComplexity
			sc.Oavailability = vectorO2.Availability
			sc.Oconfidentiality = vectorO2.Confidentiality
			sc.Ointegrity = vectorO2.IntegrityImpact
			sc.Oauthentication = vectorO2.Authentication
		}
	}
	var opensa models.OpenEulerSA
	var OpenNumData int
	//var os models.OpenSaId
	osx, opError := models.QueryOpenSaLastId()
	if opError == nil {
		OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
		OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
		if err == nil {
			OpenNum += 10
		} else {
			OpenNum = openeulernum
		}
		OpenNumData = OpenNum
	} else {
		OpenNumData = openeulernum
	}
	OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
	opensa.OpenEulerSANum = OpenEulerSANum
	var scorecode models.ScoreRecord
	scorecode.NVDScore = nVDScore
	scorecode.NvectorVule = lop.CvsVector
	scorecode.Status = 0
	cveid, cveError := models.CreateCveRelat(&vul, &sec, &sc, &opensa, &scorecode)
	if cveError != nil || cveid <= 0 {
		logs.Error("insert (&CveRes, &scoreRes,  &sec) failed CveNum:", cveData.CveNumber)
		return false, errors.New("数据插入失败, 暂时不处理")
	}
	vul.CveId = cveid
	cveCenter := models.VulnCenter{CveId: vul.CveId, CveNum: vul.CveNum, PackName: cveData.RepoPath}
	cveErr := models.GetVulnCenterByCid(&cveCenter, "cve_id", "cve_num", "pack_name")
	if cveErr != nil {
		logs.Error(cveErr)
	}
	var issueTemp models.IssueTemplate
	issueTemp.CveId = cveid
	issueTemp.CveNum = vul.CveNum
	issueTemp.CveNum = cveData.CveNumber
	issueTemp.OwnedComponent = lop.Components
	issueTemp.OwnedVersion = RemoveSubstring(lop.Version, specCharList)
	issueTemp.NVDScore = nVDScore
	issueTemp.OpenEulerScore = openEulerScore
	issueTemp.NVDVector = lop.CvsVector
	issueTemp.OpenEulerVector = lop.OpVector
	issueTemp.CveBrief = RemoveSubstring(lop.BriefIntroduction, specCharList)
	issueTemp.CveAnalysis = lop.Influences
	issueTemp.PrincipleAnalysis = lop.Principle
	issueTemp.AffectedVersion = lop.InfVersion
	issueTemp.AbiVersion = lop.AbiVersion
	issueTemp.Solution = lop.AvoidScheme
	issueTemp.IssueId = cveData.IssueId
	issueTemp.IssueNum = cveData.Number
	issueTemp.IssueLabel = beego.AppConfig.String("labelUnFix")
	issueTemp.StatusName = cveData.State
	issueTemp.Assignee = cveData.IssueAssignee
	UpdateIssueState(cveData.State, cveData.IssueState, &issueTemp, 3)
	if issueTemp.Status == 3 {
		vul.IsExport = 3
		cveCenter.IsExport = 3
	}
	issueTemp.Owner = owner
	issueTemp.Repo = cveData.RepoPath
	if cveData.Title != "" {
		issueTemp.Title = cveData.Title
	}
	update := models.UpdateVulnCenter(&cveCenter, "is_export")
	if !update {
		logs.Error("update vulnCenter fail ")
	}
	issueTemp.IssueType = CIssueType
	issueTemp.CveLevel = vul.CveLevel
	issueTemp.MtAuditFlag = 1
	issueTemp.SaAuditFlag = 1
	issTempId, issError := models.CreateIssueTemplate(&issueTemp)
	if issError != nil {
		logs.Error("Failed to create data for issue template, "+
			"cveNum: ", cveData.CveNumber, ",err: ", issError)
		return false, issError
	} else {
		logs.Info("The data of the issue template was successfully created, "+
			"issTempId: ", issTempId, ",cveNum: ", cveData.CveNumber)
	}
	hookError := CreateDepositHooks(accessToken, owner, cveData.RepoPath, vul, cveData.Number, cveData.IssueId)
	if hookError != nil {
		logs.Error(hookError)
	}
	return true, nil
}

func UpdateIssueCveGroups(cveData models.GiteOriginIssue, lop models.Loophole, cveRef string, openeulernum int,
	cveStatus int8, goe models.GitPackageInfo, vul models.VulnCenter, owner string) (bool, error) {
	//var vul models.VulnCenter
	if vul.CveNum == "" || len(vul.CveNum) < 1 {
		vul.CveNum = cveData.CveNumber
	}
	vul.Status = cveStatus
	specCharList := []string{"</br><br>", "\n", "\r", "\t"}
	briefIntroduction := RemoveSubstring(lop.BriefIntroduction, specCharList)
	if (vul.Description == "" || len(vul.Description) < 1) && len(briefIntroduction) > 1 {
		vul.Description = briefIntroduction
	}
	retVersion := AddCveVersion(cveData.OrganizationID,
		strings.Split(RemoveSubstring(lop.Version, specCharList), ","), vul.CveVersion)
	vul.CveVersion = retVersion
	if vul.PackName == "" || len(vul.PackName) < 1 {
		vul.PackName = cveData.RepoPath
	}
	if vul.CveUrl == "" || len(vul.CveUrl) < 1 {
		vul.CveUrl = cveRef + cveData.CveNumber
	}
	vul.RepoName = cveData.RepoPath
	vul.OrganizationID = cveData.OrganizationID
	accessToken := ""
	owner, accessToken = common.GetOwnerAndToken(vul.CveNum, vul.OrganizationID)
	var sec models.SecurityNotice
	sec.CveId = vul.CveId
	sec.CveNum = vul.CveNum
	sec.InfluenceComponent = vul.PackName
	sec.Status = 0
	sec.AffectStatus = "Fixed"
	sec.Summary = vul.PackName + " security update"
	if len(goe.Decription) < 1 {
		goe.Decription = goe.Summary
	}
	sec.Description = RemoveSubstring(goe.Decription, specCharList) + "\n\n" + "Security Fix(es):" + "\n\n" + vul.Description
	if sec.Description != "" && len(sec.Description) > 1 {
		sec.Description = deleteTailBlank(sec.Description) + "(" + vul.CveNum + ")"
	} else {
		sec.Description += "(" + vul.CveNum + ")"
	}
	sec.ReferenceLink = vul.CveUrl
	var issueTemps models.IssueTemplate
	issueTemps.CveId = vul.CveId
	issueTemps.CveNum = vul.CveNum
	models.GetIssueTemplateByColName(&issueTemps, "cve_id", "cve_num")
	opScoreLeve := ""
	opScore := float64(0)
	if issueTemps.OpenEulerScore > 0 {
		opScore = issueTemps.OpenEulerScore
		opScoreLeve = models.OpenEulerScoreProc(opScore)
	} else {
		opScore, opError := strconv.ParseFloat(lop.OpScore, 64)
		if opError != nil {
			opScoreLeve = "Critical"
		} else {
			opScoreLeve = models.OpenEulerScoreProc(opScore)
		}
	}
	if issueTemps.NVDVector != "" && len(issueTemps.NVDVector) > 1 && len(lop.CvsVector) < 2 {
		lop.CvsVector = issueTemps.NVDVector
	}
	if issueTemps.OpenEulerVector != "" && len(issueTemps.OpenEulerVector) > 1 && len(lop.OpVector) < 2 {
		lop.OpVector = issueTemps.OpenEulerVector
	}
	vul.CveLevel = opScoreLeve
	affectBrands := ""
	if lop.InfVersion != "" && len(lop.InfVersion) > 2 {
		affectBrands = AddAffectBrands(lop.InfVersion)
	} else {
		if issueTemps.AffectedVersion != "" && len(issueTemps.AffectedVersion) > 1 {
			affectBrands = AddAffectBrands(issueTemps.AffectedVersion)
		}
	}
	sec.Introduction = "An update for " + vul.PackName + " is now available for " + affectBrands + "."
	sec.Theme = sec.Introduction[:len(sec.Introduction)-1] + ".\n\n" + "openEuler Security has rated this" +
		" update as having a security impact of " + strings.ToLower(opScoreLeve) + ". A Common Vunlnerability" +
		" Scoring System(CVSS)base score,which gives a detailed severity rating," +
		" is available for each vulnerability from the CVElink(s) in the References section."
	sec.AffectProduct = affectBrands
	nVDScore := 0.0
	if issueTemps.NVDScore > 0 {
		nVDScore = issueTemps.NVDScore
	}
	//var err error
	var score models.Score
	score.CveId = vul.CveId
	var scOk bool
	score, scOk = models.QueryScoreByCveId(vul.CveId)
	if !scOk || score.Id == 0 {
		//var sc models.Score
		score.CveNum = vul.CveNum
		var nvdError error
		if issueTemps.NVDScore > 0 {
			score.NVDScore = issueTemps.NVDScore
		} else {
			nVDScore, nvdError = strconv.ParseFloat(lop.CvsScore, 64)
			if nvdError == nil && nVDScore > 0 {
				score.NVDScore = nVDScore
			}
		}
		if issueTemps.OpenEulerScore > 0 {
			score.OpenEulerScore = issueTemps.OpenEulerScore
		} else {
			openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
			if openError == nil && openEulerScore > 0 {
				score.OpenEulerScore = openEulerScore
			}
		}
		score.NvectorVule = lop.CvsVector
		score.OvectorVule = lop.OpVector
		score.Nstatus = 0
		score.Ostatus = 0
		score.ScoreType = lop.ScoreType
		if score.ScoreType == "v3" {
			vectorN := models.VectorValue{}
			ok := vectorN.VctToVectorValue(lop.CvsVector)
			if ok {
				score.NattackVector = vectorN.AttackVector
				score.NattackComplexity = vectorN.AttackComplexity
				score.NprivilegeRequired = vectorN.PrivilegesRequired
				score.NuserInteraction = vectorN.UserInteraction
				score.Nscope = vectorN.Scope
				score.Nconfidentiality = vectorN.Confidentiality
				score.Nintegrity = vectorN.Integrity
				score.Navailability = vectorN.Availability
			}
			vectorO := models.VectorValue{}
			vectOk := vectorO.VctToVectorValue(lop.OpVector)
			if vectOk {
				score.OattackVector = vectorO.AttackVector
				score.OattackComplexity = vectorO.AttackComplexity
				score.OprivilegeRequired = vectorO.PrivilegesRequired
				score.OuserInteraction = vectorO.UserInteraction
				score.Oscope = vectorO.Scope
				score.Oconfidentiality = vectorO.Confidentiality
				score.Ointegrity = vectorO.Integrity
				score.Oavailability = vectorO.Availability
			}
		}
		if score.ScoreType == "v2" {
			vectorN2 := models.VectorValueV2{}
			ok := vectorN2.VctToVectorValue(lop.CvsVector)
			if ok {
				score.NaccessVector = vectorN2.AccessVector
				score.NaccessComplexity = vectorN2.AccessComplexity
				score.Navailability = vectorN2.Availability
				score.Nconfidentiality = vectorN2.Confidentiality
				score.Nintegrity = vectorN2.IntegrityImpact
				score.Nauthentication = vectorN2.Authentication
			}
			vectorO2 := models.VectorValueV2{}
			vectOk := vectorO2.VctToVectorValue(lop.OpVector)
			if vectOk {
				score.OaccessVector = vectorO2.AccessVector
				score.OaccessComplexity = vectorO2.AccessComplexity
				score.Oavailability = vectorO2.Availability
				score.Oconfidentiality = vectorO2.Confidentiality
				score.Ointegrity = vectorO2.IntegrityImpact
				score.Oauthentication = vectorO2.Authentication
			}
		}
	} else {
		v2 := score.NVDScore
		vul.CveLevel = models.OpenEulerScoreProc(v2)
		score.CveNum = vul.CveNum
		score.Nstatus = 2
		var nvdError error
		if issueTemps.NVDScore > 0 {
			score.NVDScore = issueTemps.NVDScore
			score.Nstatus = 3
		} else {
			nVDScore, nvdError = strconv.ParseFloat(lop.CvsScore, 64)
			if nvdError == nil && nVDScore > 0 {
				if score.NVDScore != nVDScore {
					score.Nstatus = 3
					score.NVDScore = nVDScore
				}
			}
		}
		if issueTemps.OpenEulerScore > 0 {
			score.OpenEulerScore = issueTemps.OpenEulerScore
			score.Ostatus = 3
		} else {
			openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
			if openError == nil && openEulerScore > 0 {
				score.OpenEulerScore = openEulerScore
				score.Ostatus = 3
			}
		}
		score.OvectorVule = lop.OpVector
		score.NvectorVule = lop.CvsVector
		score.ScoreType = lop.ScoreType
		if score.ScoreType == "v3" {
			vectorO := models.VectorValue{}
			okx := vectorO.VctToVectorValue(lop.OpVector)
			if okx {
				score.OattackVector = vectorO.AttackVector
				score.OattackComplexity = vectorO.AttackComplexity
				score.OprivilegeRequired = vectorO.PrivilegesRequired
				score.OuserInteraction = vectorO.UserInteraction
				score.Oscope = vectorO.Scope
				score.Oconfidentiality = vectorO.Confidentiality
				score.Ointegrity = vectorO.Integrity
				score.Oavailability = vectorO.Availability
			}
		}
		if score.ScoreType == "v2" {
			vectorO2 := models.VectorValueV2{}
			vectOk := vectorO2.VctToVectorValue(lop.OpVector)
			if vectOk {
				score.OaccessVector = vectorO2.AccessVector
				score.OaccessComplexity = vectorO2.AccessComplexity
				score.Oavailability = vectorO2.Availability
				score.Oconfidentiality = vectorO2.Confidentiality
				score.Ointegrity = vectorO2.IntegrityImpact
				score.Oauthentication = vectorO2.Authentication
			}
		}
	}
	if vul.Status == 0 || vul.Status == 1 || vul.Status == 3 {
		hookError := CreateDepositHooks(accessToken, owner, vul.PackName, vul, cveData.Number, cveData.IssueId)
		logs.Info(hookError)
	}
	if vul.Status == 3 {
		vul.Status = 2
	}
	if vul.Status == 4 {
		vul.Status = 1
	}
	osa, osaError := models.QueryOpenSaById(vul.CveId)
	if osaError == nil && osa.OpenId > 0 {
		sec.OpenId = osa.OpenId
		score.OpenId = osa.OpenId
	} else {
		var opensa models.OpenEulerSA
		var OpenNumData int
		//var os models.OpenSaId
		osx, opError := models.QueryOpenSaLastId()
		if opError == nil {
			OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
			OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
			if err == nil {
				OpenNum += 1
			} else {
				OpenNum = openeulernum
			}
			OpenNumData = OpenNum
		} else {
			OpenNumData = openeulernum
		}
		OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
		opensa.OpenEulerSANum = OpenEulerSANum
		opensa.CveId = vul.CveId
		openId, openError := models.CreateOpenEulerSA(&opensa)
		if openError != nil && openId == 0 {
			logs.Error("生成openSA失败，openSA: ", opensa, ", error: ", openError)
			return false, errors.New("数据插入失败, 暂时不处理")
		}
		sec.OpenId = openId
		score.OpenId = openId
	}
	cveError := models.UpdateCveRelat(&vul, &sec, &score)
	if cveError != nil || vul.CveId == 0 {
		logs.Error("UpdateCveRelat(&vul, &sec, &sc) failed CveNum:", cveData.CveNumber, ",err:", cveError)
		return false, errors.New("数据插入失败, 暂时不处理")
	}
	if scOk || score.Id > 0 {
		if score.NVDScore != nVDScore {
			var scorecode models.ScoreRecord
			scorecode.NVDScore = score.NVDScore
			scorecode.NvectorVule = score.NvectorVule
			scorecode.Status = 0
			scorecode.CveId = vul.CveId
			scRecordId, scError := models.InsertScoreRecord(&scorecode)
			logs.Info(scRecordId, scError)
		}
	}
	cveCenter := models.VulnCenter{CveId: vul.CveId, CveNum: vul.CveNum}
	cveErr := models.GetVulnCenterByCid(&cveCenter, "cve_id", "cve_num")
	if cveErr != nil {
		logs.Error(cveErr)
	}
	tmpNVDScore := float64(0)
	tmpNvdError := error(nil)
	if len(lop.CvsScore) > 0 {
		tmpNVDScore, tmpNvdError = strconv.ParseFloat(lop.CvsScore, 64)
		if tmpNvdError != nil {
			logs.Error("tmpNvdError: ", tmpNvdError)
		}
	}
	var issueTemp models.IssueTemplate
	issueTemp.CveId = vul.CveId
	issueTemp.CveNum = vul.CveNum
	templateErr := models.GetIssueTemplateByColName(&issueTemp, "cve_id", "cve_num")
	if templateErr == nil && issueTemp.TemplateId > 0 {
		//issueTemp.CveNum = cveData.CveNumber
		issueTemp.OwnedComponent = lop.Components
		if (len(briefIntroduction) < 2 || tmpNVDScore <= 0 || len(lop.CvsVector) < 1) && issueTemp.Status < 3 &&
			cveData.IssueState != "已拒绝" && cveData.IssueState != "已挂起" {
			cveCenter.Status = 1
		}
		//issueTemp.OwnedVersion = RemoveSubstring(lop.Version, specCharList)
		openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
		if openError == nil && openEulerScore > 0 {
			issueTemp.OpenEulerScore = openEulerScore
		}
		if len(lop.CvsVector) > 1 {
			issueTemp.NVDVector = lop.CvsVector
		}
		nvdScore, nvdError := strconv.ParseFloat(lop.CvsScore, 64)
		if nvdError == nil && nvdScore > 0 {
			issueTemp.NVDScore = nvdScore
		}
		if lop.OpVector != "" && len(lop.OpVector) > 1 {
			issueTemp.OpenEulerVector = lop.OpVector
		}
		if len(lop.BriefIntroduction) > 2 {
			issueTemp.CveBrief = RemoveSubstring(lop.BriefIntroduction, specCharList)
		}
		if lop.Influences != "" && len(lop.Influences) > 1 {
			issueTemp.CveAnalysis = lop.Influences
		}
		issueTemp.PrincipleAnalysis = lop.Principle
		if paraAffectBrandBool(lop.InfVersion) {
			issueTemp.AffectedVersion = lop.InfVersion
		}
		if ParaAffectAbiBool(lop.AbiVersion) {
			issueTemp.AbiVersion = lop.AbiVersion
		}
		issueTemp.Solution = lop.AvoidScheme
		statusName := issueTemp.StatusName
		issueTemp.Repo = cveData.RepoPath
		if issueTemp.IssueId != cveData.IssueId || issueTemp.IssueNum != cveData.Number {
			tmpIssueErr, tmpIssueBody := GetGiteeIssue(accessToken, owner, vul.PackName, issueTemp.IssueNum)
			cveIssueErr, cveIssueBody := GetGiteeIssue(accessToken, owner, vul.PackName, cveData.Number)
			if tmpIssueErr == nil && cveIssueErr == nil {
				logs.Info("GetGiteeIssue, Issue has been created,issueBody:", tmpIssueBody, cveIssueBody)
				if issueTemp.Status > 3 {
					issueTemp.IssueId = cveData.IssueId
					issueTemp.IssueNum = cveData.Number
					issueTemp.StatusName = cveData.State
					statusName = cveData.State
					issueTemp.Assignee = cveData.IssueAssignee
				}
			} else if tmpIssueErr == nil && cveIssueErr != nil {
				logs.Info("The data does not change", issueTemp.IssueNum)
			} else if tmpIssueErr != nil && cveIssueErr == nil {
				issueTemp.IssueId = cveData.IssueId
				issueTemp.IssueNum = cveData.Number
				issueTemp.StatusName = cveData.State
				statusName = cveData.State
				issueTemp.Assignee = cveData.IssueAssignee
			}
		} else {
			issueTemp.StatusName = cveData.State
			statusName = cveData.State
		}
		UpdateIssueState(statusName, cveData.IssueState, &issueTemp, 1)
		issueTemp.Owner = owner
		if cveData.Title != "" {
			issueTemp.Title = cveData.Title
		}
		issueTemp.IssueType = CIssueType
		issueTemp.CveLevel = vul.CveLevel
	} else {
		issueTemp.CveNum = cveData.CveNumber
		issueTemp.OwnedComponent = lop.Components
		issueTemp.Repo = cveData.RepoPath
		issueTemp.Owner = owner
		issueTemp.OwnedVersion = RemoveSubstring(lop.Version, specCharList)
		issueTemp.NVDScore = nVDScore
		openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
		if openError == nil {
			issueTemp.OpenEulerScore = openEulerScore
		}
		issueTemp.NVDVector = lop.CvsVector
		nvdScore, nvdError := strconv.ParseFloat(lop.CvsScore, 64)
		if nvdError == nil {
			issueTemp.NVDScore = nvdScore
		}
		if len(briefIntroduction) < 2 || tmpNVDScore <= 0 || len(lop.CvsVector) < 1 &&
			cveData.IssueState != "已拒绝" && cveData.IssueState != "已挂起" {
			cveCenter.Status = 1
		}
		issueTemp.NVDVector = lop.CvsVector
		issueTemp.OpenEulerVector = lop.OpVector
		issueTemp.CveBrief = RemoveSubstring(lop.BriefIntroduction, specCharList)
		issueTemp.CveAnalysis = RemoveSubstring(lop.Influences, specCharList)
		issueTemp.PrincipleAnalysis = lop.Principle
		issueTemp.AffectedVersion = lop.InfVersion
		issueTemp.AbiVersion = lop.AbiVersion
		issueTemp.Solution = lop.AvoidScheme
		issueTemp.IssueId = cveData.IssueId
		issueTemp.IssueNum = cveData.Number
		issueTemp.StatusName = cveData.State
		issueTemp.IssueLabel = beego.AppConfig.String("labelUnFix")
		issueTemp.Assignee = cveData.IssueAssignee
		UpdateIssueState(cveData.State, cveData.IssueState, &issueTemp, 2)
		if cveData.Title != "" {
			issueTemp.Title = cveData.Title
		}
		issueTemp.IssueType = CIssueType
		issueTemp.CveLevel = vul.CveLevel
	}
	if issueTemp.Status == 3 {
		cveCenter.IsExport = 3
	}
	update := models.UpdateVulnCenter(&cveCenter, "is_export", "cve_status")
	if !update {
		logs.Error("update vulnCenter fail ")
	}
	// Store issue data
	issTempId, issError := models.CreateIssueTemplate(&issueTemp)
	if issError != nil {
		logs.Error("Failed to create data for issue template, "+
			"cveNum: ", cveData.CveNumber, ",err: ", issError)
		return false, issError
	} else {
		logs.Info("The data of the issue template was successfully created, "+
			"issTempId: ", issTempId, ",cveNum: ", cveData.CveNumber)
	}
	return true, nil
}

func UpdateIssueState(statusName, issueState string, issueTemp *models.IssueTemplate, flag int) {
	if (strings.ToLower(statusName) == "open" || statusName == "待办的" || statusName == "开启的" ||
		issueState == "待办的" || issueState == "新建") && issueState != "已挂起" {
		issueTemp.Status = 1
		issueTemp.IssueStatus = 1
		issueTemp.StatusName = "open"
	} else if strings.ToLower(statusName) == "progressing" ||
		strings.ToLower(statusName) == "started" || statusName == "进行中" || issueState == "进行中" {
		issueTemp.Status = 2
		issueTemp.IssueStatus = 3
		issueTemp.StatusName = "progressing"
	} else if strings.ToLower(statusName) == "closed" || statusName == "已完成" || issueState == "已完成" {
		issueTemp.Status = 3
		issueTemp.IssueStatus = 2
		issueTemp.MtAuditFlag = 1
		if flag == 2 {
			issueTemp.IssueLabel = beego.AppConfig.String("labelFixed")
			issueTemp.MtAuditFlag = 1
			issueTemp.SaAuditFlag = 1
		}
		if flag == 3 {
			issueTemp.IssueLabel = beego.AppConfig.String("labelFixed")
		}
	} else if strings.ToLower(statusName) == "rejected" || statusName == "已拒绝" ||
		issueState == "已拒绝" || issueState == "已取消" {
		issueTemp.Status = 4
		issueTemp.IssueStatus = 6
		if flag == 2 {
			issueTemp.IssueLabel = beego.AppConfig.String("labeUnaffected")
			issueTemp.MtAuditFlag = 1
			issueTemp.SaAuditFlag = 1
		}
		if flag == 3 {
			issueTemp.IssueLabel = beego.AppConfig.String("labeUnaffected")
		}
	} else if strings.ToLower(statusName) == "suspended" || statusName == "已挂起" || issueState == "已挂起" {
		issueTemp.Status = 5
		issueTemp.IssueStatus = 6
		if flag == 2 || flag == 3 {
			issueTemp.IssueLabel = beego.AppConfig.String("labeUnaffected")
		}
	} else {
		issueTemp.Status = 4
		issueTemp.IssueStatus = 6
	}
}

func paraAffectBrandBool(affectedVersion string) bool {
	unaffectedBranchList := []string{}
	brandsGroup := strings.Split(affectedVersion, ",")
	if len(brandsGroup) > 0 {
		for _, brand := range brandsGroup {
			if brand == "" || len(brand) < 2 {
				continue
			}
			brand = common.BranchVersionRep(brand)
			brandList := strings.Split(brand, ":")
			if len(brandList) > 1 {
				prams := strings.Replace(brandList[1], " ", "", -1)
				if prams == "受影响" || prams == "不受影响" {
					unaffectedBranchList = append(unaffectedBranchList, brandList[0])
				}
			} else {
				brandList = strings.Split(brand, "：")
				if len(brandList) > 1 {
					prams := strings.Replace(brandList[1], " ", "", -1)
					if prams == "受影响" || prams == "不受影响" {
						unaffectedBranchList = append(unaffectedBranchList, brandList[0])
					}
				}
			}
		}
	}
	if len(unaffectedBranchList) > 0 {
		return true
	}
	return false
}

func ParaAffectAbiBool(abiVersion string) bool {
	unaffectedBranchList := make([]string, 0)
	brandsGroup := strings.Split(abiVersion, ",")
	if len(brandsGroup) > 0 {
		for _, brand := range brandsGroup {
			if brand == "" || len(brand) < 2 {
				continue
			}
			brand = common.BranchVersionRep(brand)
			brandList := strings.Split(brand, ":")
			if len(brandList) > 1 {
				prams := strings.Replace(brandList[1], " ", "", -1)
				if prams == "是" || prams == "否" {
					unaffectedBranchList = append(unaffectedBranchList, brandList[0])
				}
			} else {
				brandList = strings.Split(brand, "：")
				if len(brandList) > 1 {
					prams := strings.Replace(brandList[1], " ", "", -1)
					if prams == "是" || prams == "否" {
						unaffectedBranchList = append(unaffectedBranchList, brandList[0])
					}
				}
			}
		}
	}
	if len(unaffectedBranchList) > 0 {
		return true
	}
	return false
}

func GenCveVulerByIssue(cveData models.GiteOriginIssue, cveRef string, openeulernum int, owner string, openFlag int8) (bool, error) {
	defer common.Catchs()
	lock.Lock()
	hole, err := cveData.ParseToLoophole()
	lock.Unlock()
	organizationID := cveData.OrganizationID
	if err != nil {
		logs.Error("Data parsing error, err: ", err, ", cveData: ", cveData)
		models.UpdateCveIssueStatusById(3, cveData.Id)
		return false, err
	}
	if len(hole.Components) < 1 {
		hole.Components = cveData.RepoPath
	}
	goe := models.GitPackageInfo{}
	if organizationID == 1 {
		goe, _ = models.QueryCveOpeneulerDetaildataByName(cveData.RepoPath, hole.Version)
		if goe.DetailId == 0 {
			logs.Error("Failed to get data, ", "Components: ", hole.Components, ",Version: ", hole.Version)
		}
	} else {
		goe, _ = models.QueryCveOpeneulerDetaildataByName(hole.Components, hole.Version)
		if goe.DetailId == 0 {
			logs.Error("Failed to get data, ", "Components: ", hole.Components, ",Version: ", hole.Version)
		}
	}
	if len(goe.Version) > 0 {
		hole.Version = goe.Version
	}
	if cveData.State != "" && (strings.ToLower(cveData.State) == "rejected" ||
		cveData.State == "已拒绝" || cveData.IssueState == "已拒绝" || cveData.IssueState == "已挂起") {
		logs.Info("Process data whose issue status is rejected：", cveData)
		cvd, ok := models.QueryCveByNum(cveData.CveNumber, cveData.RepoPath, hole.Components, organizationID)
		if ok && cvd.CveNum != "" {
			lock.Lock()
			upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, cvd, owner)
			logs.Info(upOk, upError)
			lock.Unlock()
		} else {
			lock.Lock()
			okx, errx := InsertIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, owner)
			lock.Unlock()
			if !okx {
				logs.Error("Failed to get data, InsertIssueCveGroups， err: ", errx)
				return false, err
			}
		}
		models.UpdateCveStatusExportByNum(common.GetCurTime(), cveData.CveNumber, 2, cveData.RepoPath, hole.Version)
		models.UpdateCveIssueStatusById(2, cveData.Id)
		return true, nil
	} else if cveData.State != "" && (strings.ToLower(cveData.State) == "closed" || cveData.State == "已完成") {
		logs.Info("Process data whose issue status is closed：", cveData)
		cvd, ok := models.QueryCveByNum(cveData.CveNumber, cveData.RepoPath, hole.Components, organizationID)
		if ok && cvd.CveNum != "" {
			lock.Lock()
			upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, cvd, owner)
			logs.Info(upOk, upError)
			lock.Unlock()
		} else {
			lock.Lock()
			okx, errx := InsertIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, owner)
			lock.Unlock()
			if !okx {
				logs.Error("Failed to get data, InsertIssueCveGroups， err: ", errx)
				return false, err
			}
		}
		models.UpdateCveStatusExportByNum(common.GetCurTime(), cveData.CveNumber, 3, cveData.RepoPath, hole.Version)
		models.UpdateCveIssueStatusById(2, cveData.Id)
		return true, nil
	} else {
		logs.Info("Process data whose issue status is open and processing：", cveData)
		cvd, ok := models.QueryCveByNum(cveData.CveNumber, cveData.RepoPath, hole.Components, organizationID)
		if ok && len(cvd.CveNum) > 1 {
			if openFlag == 1 {
				lock.Lock()
				upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 1, goe, cvd, owner)
				lock.Unlock()
				logs.Info(upOk, upError)
			} else {
				if cvd.Status == 0 {
					if strings.ToLower(cveData.State) == "open" || cveData.State == "待办的" ||
						strings.ToLower(cveData.State) == "progressing" || cveData.State == "进行中" ||
						strings.ToLower(cveData.State) == "started" || cveData.State == "开启的" {
						lock.Lock()
						upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 1, goe, cvd, owner)
						lock.Unlock()
						logs.Info(upOk, upError)
					} else {
						lock.Lock()
						upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 3, goe, cvd, owner)
						lock.Unlock()
						logs.Info(upOk, upError)
					}
				} else if cvd.Status == 1 {
					if strings.ToLower(cveData.State) == "open" || cveData.State == "待办的" ||
						strings.ToLower(cveData.State) == "progressing" || cveData.State == "进行中" ||
						strings.ToLower(cveData.State) == "started" || cveData.State == "开启的" {
						lock.Lock()
						upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 4, goe, cvd, owner)
						lock.Unlock()
						logs.Info(upOk, upError)
					} else {
						lock.Lock()
						upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, cvd, owner)
						lock.Unlock()
						logs.Info(upOk, upError)
					}
				} else {
					lock.Lock()
					upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, cvd, owner)
					lock.Unlock()
					logs.Info(upOk, upError)
				}
			}
		} else {
			if strings.ToLower(cveData.State) == "open" || cveData.State == "待办的" ||
				strings.ToLower(cveData.State) == "progressing" || cveData.State == "进行中" ||
				strings.ToLower(cveData.State) == "started" || cveData.State == "开启的" {
				lock.Lock()
				okx, errx := InsertIssueCveGroups(cveData, hole, cveRef, openeulernum, 1, goe, owner)
				lock.Unlock()
				if !okx {
					logs.Error("Failed to get data, InsertIssueCveGroups， err: ", errx)
					return false, err
				}
			} else {
				lock.Lock()
				okx, errx := InsertIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, owner)
				lock.Unlock()
				if !okx {
					logs.Error("Failed to get data, InsertIssueCveGroups， err: ", errx)
					return false, err
				}
			}
		}
		models.UpdateCveIssueStatusById(2, cveData.Id)
		return true, nil
	}
}

func ProcAffectData(ite models.IssueTemplate) {
	affectVerList := strings.Split(ite.AffectedVersion, ",")
	if len(affectVerList) > 0 {
		affectBranch := make([]string, 0)
		affectMap := make(map[string]string)
		for _, avl := range affectVerList {
			affectList := make([]string, 0)
			if strings.Index(avl, ":") != -1 {
				affectList = strings.Split(avl, ":")
			} else {
				affectList = strings.Split(avl, "：")
			}
			if len(affectList) > 0 {
				if _, ok := common.FindSliceEm(affectBranch, affectList[0]); !ok {
					affectBranch = append(affectBranch, affectList[0])
				}
			}
			if len(affectMap) > 0 {
				if len(affectList) > 1 {
					if av, ok := affectMap[affectList[0]]; ok {
						if len(av) >= len(affectList[1]) {
							continue
						} else {
							affectMap[affectList[0]] = affectList[1]
						}
					} else {
						affectMap[affectList[0]] = affectList[1]
					}
				} else if len(affectList) == 1 {
					if _, ok := affectMap[affectList[0]]; ok {
						continue
					} else {
						affectMap[affectList[0]] = ""
					}
				}
			} else {
				if len(affectList) > 1 {
					affectMap[affectList[0]] = affectList[1]
				} else {
					if len(affectList) == 1 {
						affectMap[affectList[0]] = ""
					}
				}
			}
		}
		if len(affectBranch) > 0 {
			affectSlice := make([]string, 0)
			for _, af := range affectBranch {
				if av, ok := affectMap[af]; ok {
					if len(av) > 1 {
						affectSlice = append(affectSlice, af+":"+av)
					} else {
						affectSlice = append(affectSlice, af+":")
					}
				}
			}
			if len(affectSlice) > 0 {
				ite.AffectedVersion = strings.Join(affectSlice, ",")
				models.UpdateIssueTemplate(&ite, "AffectedVersion")
			}
		}
	}
}

func ProcIssueTemplateBranch(duplicationDate int) {
	defer common.Catchs()
	beforeTime := common.GetBeforeTime(duplicationDate)
	tmplateId := int64(0)
	for {
		iteList, num, err := models.QueryIssueTemplateAll(100, tmplateId, beforeTime)
		if len(iteList) > 0 {
			for _, ite := range iteList {
				tmplateId = ite.TemplateId
				if len(ite.AffectedVersion) > 1 {
					ProcAffectData(ite)
				}
			}
		} else {
			logs.Error("num: ", num, ",err: ", err)
			break
		}
	}
}

func GetCveIssueData(prcnum, days, openeulernum int, cveRef, owner string, openFlag int8) (bool, error) {
	defer common.Catchs()
	count := 0
	for {
		gs, num, err := models.QueryOriginCveIssue(prcnum)
		if num == 0 {
			logs.Info("There is currently no cveissue raw data processing, err: ", err,
				", curtime: ", common.GetCurTime())
			break
		}
		ch := make(chan int, len(gs))
		for i, cveOrg := range gs {
			count = count + 1
			logs.Info("The current normal analysis: ", count, " Article data,i:", i, ", cvenum: ", cveOrg.IssueId)
			// add mutex
			lockOk := models.LockUpdateCveIssueStatus(15, cveOrg.Id)
			if !lockOk {
				logs.Error("Data is being processed, id: ", cveOrg.Id, ",cveOrg: ", cveOrg)
				ch <- i
				continue
			}
			if cveOrg.CveNumber == "" || len(cveOrg.CveNumber) == 0 {
				logs.Error("Data is abnormal, do not handle, cveData: ", cveOrg)
				models.UpdateCveIssueStatusById(3, cveOrg.Id)
				ch <- i
				continue
			}
			go func(idx, openeulernum int, cveData models.GiteOriginIssue, locCveRef, locOwner string, openFlag int8) {
				ok, err := GenCveVulerByIssue(cveData, locCveRef, openeulernum, locOwner, openFlag)
				if !ok {
					logs.Error("GenCveVulerByIssue, cveData: ", cveData, "Processing failed, err: ", err)
					models.UpdateCveIssueStatusById(3, cveData.Id)
				}
				ch <- idx
			}(i, openeulernum, cveOrg, cveRef, owner, openFlag)
		}
		for i := 0; i < cap(ch); i++ {
			<-ch
		}
		close(ch)
	}
	return true, nil
}

//GetSecurityNotice Go to the CVE official website to obtain the cve data to determine
//whether the cve issue needs to be exported.
func GetCveSecurityNotice(cveNumber, packageName string, flag bool) (bool, models.RespCveDetail) {
	var detail models.RespCveDetail
	var urlS url.URL
	q := urlS.Query()
	path := ""
	q.Add("cveId", cveNumber)
	if flag {
		q.Add("packageName", packageName)
		path = "/api-cve/cve-security-notice-server/cvedatabase/getByCveIdAndPackageName"
	} else {
		path = "/api-cve/cve-security-notice-server/cvedatabase/getByCveId"
	}
	params := q.Encode()
	secLinkConfig := beego.AppConfig.String("reflink::openeuler_web")
	req, _ := http.NewRequest("GET", secLinkConfig, nil)
	req.URL = &url.URL{
		Scheme:   req.URL.Scheme,
		Host:     req.URL.Host,
		RawQuery: params,
		Path:     path,
	}
	req.URL.EscapedPath()
	resp, err := http.Get(req.URL.String())
	if err != nil {
		logs.Error("GetCveSecurityNotice, url: ", req.URL.String(), err)
		return false, detail
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil || body == nil {
		logs.Error("ReadAll, url: ", req.URL.String(), err)
		return false, detail
	}
	//logs.Info("GetCveSecurityNotice, body: ", string(body))
	err = json.Unmarshal(body, &detail)
	if err != nil {
		logs.Error("Unmarshal, url: ", req.URL.String(), err)
		return false, detail
	}
	if detail.Result != nil && detail.Result.Id > 0 {
		return true, detail
	}
	return false, detail
}

func GetCveProduct(cveNumber, packageName string, branch ...string) (bool, models.RespCveProduct) {
	var detail models.RespCveProduct
	var urlS url.URL
	q := urlS.Query()
	path := "/api-cve/cve-security-notice-server/cvedatabase/getCVEProductPackageList"
	q.Add("cveId", cveNumber)
	q.Add("packageName", packageName)
	params := q.Encode()
	secLinkConfig := beego.AppConfig.String("reflink::openeuler_web")
	req, _ := http.NewRequest("GET", secLinkConfig, nil)
	req.URL = &url.URL{
		Scheme:   req.URL.Scheme,
		Host:     req.URL.Host,
		RawQuery: params,
		Path:     path,
	}
	req.URL.EscapedPath()
	resp, err := http.Get(req.URL.String())
	if err != nil {
		logs.Error("GetCveSecurityNotice, url: ", req.URL.String(), err)
		return false, detail
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil || body == nil {
		return false, detail
	}
	err = json.Unmarshal(body, &detail)
	if err != nil {
		return false, detail
	}
	affectedBranchs := beego.AppConfig.String("cve::affected_branchs")
	splitAffectedBranches := strings.Split(strings.ToLower(affectedBranchs), ",")
	if len(detail.Result) >= len(splitAffectedBranches)-1 {
		var p string
		var f = true
		for _, product := range detail.Result {
			p += strings.ToLower(product.ProductName) + ","
		}
		for _, s := range splitAffectedBranches {
			if !strings.Contains(p, s) {
				f = false
				break
			}
		}
		if f {
			return true, detail
		}
	}
	if len(branch) > 0 {
		for _, v := range detail.Result {
			if strings.EqualFold(v.ProductName, branch[0]) {
				return true, detail
			}
		}
		return false, detail
	}
	return len(detail.Result) >= len(splitAffectedBranches), detail
}

//FilterCveExported Filter exportable data
func FilterCveExported() {
	logs.Info("Start by removing cve data that has already released SA...")
	data, err := models.GetCanExportVulnCenterData()
	if err != nil {
		logs.Error(err)
		return
	}
	for _, v := range data {
		ewg.Add(1)
		go func(center models.VulnCenter) {
			defer ewg.Done()
			issueExist, result := GetCveSecurityNotice(center.CveNum, center.PackName, true)
			if issueExist {
				// 1640966400 -- 2022-01-01
				if t := util.TimeStrToInt(result.Result.UpdateTime, ""); t != 0 && t <= 1640966400 {
					dbLock.Lock()
					center.IsExport = 1
					models.UpdateVulnCenter(&center, "is_export")
					dbLock.Unlock()
				} else if productExist, _ := GetCveProduct(center.CveNum, center.PackName); productExist {
					dbLock.Lock()
					center.IsExport = 1
					models.UpdateVulnCenter(&center, "is_export")
					dbLock.Unlock()
				}
			} else {
				if center.IsExport == 2 {
					dbLock.Lock()
					center.IsExport = 3
					models.UpdateVulnCenter(&center, "is_export")
					dbLock.Unlock()
				}
			}
		}(v)
	}
	ewg.Wait()
	logs.Info("Excluding the cve data that has been released SA ends...")
}

func GenerateExcelTask() error {
	FilterCveExported()
	return nil
}

//GenerateExcelTrigger generate cve&security notice excel file by pr merge and influence package release.
func GenerateExcelTrigger(wgCrvf *sync.WaitGroup, fileName, startTime, fileCode, affectBranch,
	csvDownPath, dir string, cvrfFileList map[string][]string,
	componentMap map[string]ComponentInfo, cvfrFileMap map[string]CvrfSa, cves []string) UpdateInfoXml {
	defer wgCrvf.Done()
	logs.Info(affectBranch, ", GenerateExcelTrigger start...")
	var updateInfoXml UpdateInfoXml
	xmlFileName := beego.AppConfig.String("xml::updateinfo_path")
	xmfilePath := filepath.Join(dir, affectBranch+"_"+xmlFileName)
	var cvexml []CveXml
	var dpdates Updates
	securityNotice := make(map[string][]SecurityNoticeXml)
	packRpmx := make(map[string][]PackRpm)
	ReadXml(xmfilePath, &dpdates)
	fileName = filepath.Join(dir, fileName)
	localPath := filepath.Join(dir, affectBranch+"_release-package.CSV")
	err := downloadPackageFile(localPath, csvDownPath, affectBranch)
	if err != nil {
		logs.Error(err)
		return updateInfoXml
	}
	pkgList, err := ExtractPackageData(localPath)
	if err != nil {
		logs.Error(err)
	} else {
		su := time.Now().Format("2006-01-02")
		snPrefix := "openEuler-" + su
		snSuffix := int64(1001)
		err = GenerateCveExcelByTrigger(affectBranch, fileName, snPrefix, startTime,
			snSuffix, true, pkgList, cvrfFileList,
			componentMap, cvfrFileMap, &cvexml, &dpdates,
			securityNotice, packRpmx, cves)
		if err != nil {
			logs.Error(err)
		}
	}
	updateInfoXml = UpdateInfoXml{XmfilePath: xmfilePath, Cvexml: cvexml, Dpdates: &dpdates,
		SecurityNotice: securityNotice, PackRpmx: packRpmx, FileName: fileName, AffectBranch: affectBranch}
	logs.Info(affectBranch, ", GenerateExcelTrigger: end")
	return updateInfoXml
}

func downloadPackageFile(localPath, url, affectBranch string) error {
	logs.Info("The csv file currently being downloaded is: ", url)
	pkgLock.Lock()
	err := GiteeDownCsv(localPath, affectBranch)
	pkgLock.Unlock()
	return err
}

func GiteeDownCsv(localPath, branch string) error {
	gitUrl := fmt.Sprintf(
		"https://gitee.com/api/v5/repos/%s/%s/contents/%s?access_token=%s",
		"openeuler_latest_rpms", "obs_pkg_rpms_20231109", fmt.Sprintf("latest_rpm/%v.csv", branch), os.Getenv("GITEE_TOKEN"),
	)
	resp, err := http.Get(gitUrl)
	if err != nil {
		logs.Error("get error, url:", gitUrl, "error: ", err)
		return err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil || body == nil {
		return err
	}
	var contents map[string]interface{}
	if err = json.Unmarshal(body, &contents); err != nil {
		return err
	}
	f, ferr := os.Create(localPath)
	if ferr != nil {
		return ferr
	}

	if contents["type"].(string) == "file" && contents["encoding"].(string) == "base64" {
		data, baseErr := base64.StdEncoding.DecodeString(contents["content"].(string))
		if baseErr == nil {
			f.Write(data)
		}
	} else {
		f.WriteString(contents["content"].(string))
	}
	return nil
}

func CvePlanCloseTime(startTime time.Time, cveLevel string, isLocalFlag, isTparam bool) string {
	endLocal := ""
	switch cveLevel {
	case "Critical":
		endLocal = common.GetSpecifiedTime(startTime, 7, isLocalFlag, isTparam)
	case "High":
		endLocal = common.GetSpecifiedTime(startTime, 14, isLocalFlag, isTparam)
	case "Medium", "Low":
		endLocal = common.GetSpecifiedTime(startTime, 30, isLocalFlag, isTparam)
	default:
		endLocal = common.GetSpecifiedTime(startTime, 60, isLocalFlag, isTparam)
	}
	return endLocal
}

func GetIssuePriority(cveLevel string) (priority int) {
	switch cveLevel {
	case "Critical":
		priority = 4
	case "High":
		priority = 3
	case "Medium":
		priority = 2
	case "Low":
		priority = 1
	default:
		priority = 0
	}
	return
}

func judgeSocpe(pkgname, ver string) (flag bool, ids []string) {
	list, sporeErr := models.GetMindSporeYamlAll(&models.MindSporeYaml{PackageName: pkgname})
	if sporeErr == nil && len(list) > 0 {
		for _, v := range list {
			version := strings.TrimSpace(string(util.Symbol.ReplaceAll([]byte(v.Version), []byte(""))))
			if JudgeVersion(strings.TrimSpace(ver), version, v.Version) {
				flag = true
				ids = append(ids, strconv.Itoa(int(v.Id)))
			}
		}
	} else {
		return
	}
	return
}

func JudgeVersion(ver1, ver2, sourceVer string) bool {
	if strings.Contains(sourceVer, ">=") {
		if ver1 >= ver2 {
			return true
		}
	} else if strings.Contains(sourceVer, ">") {
		if ver1 > ver2 {
			return true
		}
	} else if strings.Contains(sourceVer, "<=") {
		if ver1 <= ver2 {
			return true
		}
	} else if strings.Contains(sourceVer, "<") {
		if ver1 < ver2 {
			return true
		}
	} else {
		if ver1 == ver2 {
			return true
		}
	}
	return false
}

func UpdateCveIssueScore(cveCenter models.VulnCenter) error {
	score, sErr := models.QueryIssueScore(cveCenter.CveId)
	if sErr != nil {
		return sErr
	}

	score.OpenEulerScore = score.NVDScore
	score.OattackVector = score.NattackVector
	score.OattackComplexity = score.NattackComplexity
	score.OprivilegeRequired = score.NprivilegeRequired
	score.OuserInteraction = score.NuserInteraction
	score.Oscope = score.Nscope
	score.Oconfidentiality = score.Nconfidentiality
	score.Ointegrity = score.Nintegrity
	score.Oavailability = score.Navailability

	issueTmp := models.IssueTemplate{CveId: cveCenter.CveId}
	err := models.GetIssueTemplateByColName(&issueTmp, "CveId")
	if err != nil {
		return err
	}

	if score.OpenEulerScore != 0.0 && issueTmp.OpenEulerScore != 0.0 {
		return nil
	}

	err = models.UpdateScore(&score,
		"OpenEulerScore", "OattackVector", "OattackComplexity", "OprivilegeRequired", "OuserInteraction",
		"Oscope", "Oconfidentiality", "Ointegrity", "Oavailability")
	if err != nil {
		return err
	}

	issueTmp.OpenEulerScore = issueTmp.NVDScore
	issueTmp.OpenEulerVector = issueTmp.NVDVector

	err = models.UpdateIssueTemplate(&issueTmp, "OpenEulerScore", "OpenEulerVector")
	if err != nil {
		return err
	}

	owner, accessToken := common.GetOwnerAndToken(cveCenter.CveNum, cveCenter.OrganizationID)

	_, err = UpdateIssueToGit(accessToken, owner, issueTmp.Repo, cveCenter, issueTmp)
	if err != nil {
		return err
	}

	return nil
}
