package taskhandler

import (
	"cvevulner/common"
	"cvevulner/models"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/config"
	"github.com/astaxie/beego/logs"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"
)

var GetCveDetailUrl = "https://openeuler.org/api-cve/cve-security-notice-server/cvedatabase/getByCveId?cveId=%s"

var (
	pkgLock sync.Mutex
	lockx   sync.Mutex
	dbLock  sync.Mutex
)
var ewg sync.WaitGroup

type UpdateInfoXml struct {
	XmfilePath     string
	Cvexml         []CveXml
	Dpdates        *Updates
	SecurityNotice map[string][]SecurityNoticeXml
	PackRpmx       map[string][]PackRpm
	FileName       string
	AffectBranch   string
}

func UpdateExcelCveGroups(cveData models.OriginExcel,
	cveRef string, openeulerNum int, CveRes models.VulnCenter,
	goe models.GitPackageInfo, organizationID int8) (bool, error) {
	var OpenEulId int64
	CveRes.Description = cveData.CveDesc
	CveRes.CveVersion = cveData.CveVersion
	if len(CveRes.RepairTime) < 2 && len(cveData.RepairTime) > 2 {
		CveRes.RepairTime = cveData.RepairTime
	}
	//CveRes.PackName = cveData.PackName
	CveRes.RepoName = cveData.PackName
	CveRes.CveUrl = cveRef + cveData.CveNum
	CveRes.CveLevel = cveData.CveLevel
	CveRes.OrganizationID = organizationID
	if CveRes.DataSource == 1 {
		CveRes.DataSource = 3
	}
	if CveRes.DataSource != 4 && CveRes.Status != 0 && CveRes.Status != 1 {
		CveRes.Status = 1
		CveRes.IsExport = 0
	}
	if (CveRes.DataSource == 4 || CveRes.DataSource == 3) &&
		CveRes.Status != 0 && CveRes.Status != 1 {
		issueTmp := models.IssueTemplate{CveId: CveRes.CveId,
			Repo: CveRes.PackName, OwnedVersion: CveRes.CveVersion}
		err := models.GetIssueTemplateByColName(&issueTmp, "CveId", "Repo", "OwnedVersion")
		if err != nil {
			if CveRes.DataSource == 3 {
				CveRes.Status = 0
				CveRes.IsExport = 0
			}
			logs.Error(err)
		} else {
			if issueTmp.Status < 3 {
				CveRes.Status = 1
				CveRes.IsExport = 0
			}
		}
	}
	//CveRes.Status = 1
	openEusa, operr := models.QueryOpenEulerSAByCveId(CveRes.CveId)
	if operr == false {
		var opensa models.OpenEulerSA
		osx, operr := models.QueryOpenSaLastId()
		var OpenNumData int
		if operr == nil {
			OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
			OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
			if err == nil {
				OpenNum += 1
			} else {
				OpenNum = openeulerNum
			}
			OpenNumData = OpenNum
		} else {
			OpenNumData = openeulerNum
		}
		OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(OpenNumData)
		opensa.OpenEulerSANum = OpenEulerSANum
		opensa.CveId = CveRes.CveId
		openEulerId, opEerr := models.CreateOpenEulerSA(&opensa)
		if opEerr == nil {
			OpenEulId = openEulerId
		} else {
			logs.Error("UpdateExcelCveGroups, Failed to update openEulerSa data table, err: ", opEerr)
			return false, errors.New("openEulerSA数据错误，暂时不处理")
		}
	} else {
		OpenEulId = openEusa.OpenId
	}
	scoreRes, scoreerr := models.QueryScoreByCveId(CveRes.CveId)
	if scoreerr {
		if scoreRes.NVDScore != cveData.NVDScore {
			var scorecode models.ScoreRecord
			scorecode.NVDScore = cveData.NVDScore
			scorecode.NvectorVule = cveData.NVDVector
			scorecode.Status = 0
			scorecode.CveId = CveRes.CveId
			scoreid, err := models.InsertScoreRecord(&scorecode)
			if scoreid > 0 && err == nil {
				logs.Info("insert score_record success, id:", scoreid)
			} else {
				return false, errors.New("评分记录数据错误，暂时不处理")
			}
		}
		scoreRes.NVDScore = cveData.NVDScore
		scoreRes.NvectorVule = cveData.NVDVector
		scoreRes.OpenId = OpenEulId
		scoreRes.Nstatus = 1
		if strings.ToLower(cveData.ScoreType) == "v2" || strings.ToLower(cveData.ScoreType) == "v2.0" {
			scoreRes.NaccessVector = cveData.AccessVector
			scoreRes.NaccessComplexity = cveData.AccessComplexity
			scoreRes.Nauthentication = cveData.Authentication
			scoreRes.ScoreType = "v2"
		} else {
			scoreRes.NattackVector = cveData.AttackVector
			scoreRes.NattackComplexity = cveData.AttackComplexity
			scoreRes.NprivilegeRequired = cveData.PrivilegeRequired
			scoreRes.NuserInteraction = cveData.UserInteraction
			scoreRes.Nscope = cveData.Scope
			scoreRes.ScoreType = "v3"
		}
		scoreRes.Nconfidentiality = cveData.Confidentiality
		scoreRes.Nintegrity = cveData.Integrity
		scoreRes.Navailability = cveData.Availability
	} else {
		var sc models.Score
		sc.CveNum = cveData.CveNum
		sc.NVDScore = cveData.NVDScore
		sc.OpenEulerScore = cveData.NVDScore
		sc.OpenId = OpenEulId
		sc.NvectorVule = cveData.NVDVector
		sc.OvectorVule = cveData.NVDVector
		sc.CveId = CveRes.CveId
		sc.Nstatus = 0
		sc.Ostatus = 0
		if strings.ToLower(cveData.ScoreType) == "v2" ||
			strings.ToLower(cveData.ScoreType) == "v2.0" {
			sc.NaccessVector = cveData.AccessVector
			sc.OaccessVector = cveData.AccessVector
			sc.NaccessComplexity = cveData.AccessComplexity
			sc.OaccessComplexity = cveData.AccessComplexity
			sc.Nauthentication = cveData.Authentication
			sc.Oauthentication = cveData.Authentication
			sc.ScoreType = "v2"
		} else {
			sc.NattackVector = cveData.AttackVector
			sc.OattackVector = cveData.AttackVector
			sc.NattackComplexity = cveData.AttackComplexity
			sc.OattackComplexity = cveData.AttackComplexity
			sc.NprivilegeRequired = cveData.PrivilegeRequired
			sc.OprivilegeRequired = cveData.PrivilegeRequired
			sc.OuserInteraction = cveData.UserInteraction
			sc.NuserInteraction = cveData.UserInteraction
			sc.Oscope = cveData.Scope
			sc.Nscope = cveData.Scope
			sc.ScoreType = "v3"
		}
		sc.Nconfidentiality = cveData.Confidentiality
		sc.Oconfidentiality = cveData.Confidentiality
		sc.Nintegrity = cveData.Integrity
		sc.Ointegrity = cveData.Integrity
		sc.Navailability = cveData.Availability
		sc.Oavailability = cveData.Availability
		scid, scErr := models.CreateScore(&sc)
		if scErr != nil {
			logs.Error("UpdateExcelCveGroups, insert cve_score failed cveScV3: ", sc, ",scerr: ", scErr)
			return false, errors.New("记录评分失败，暂时不处理")
		} else {
			logs.Info("insert cve_score success scid: ", scid, "CveNum:", cveData.CveNum)
		}
	}
	SecNOtice, secerrx := models.QuerySecNoticeByCveId(CveRes.CveId)
	if secerrx {
		SecNOtice.InfluenceComponent = cveData.PackName
		SecNOtice.OpenId = OpenEulId
		SecNOtice.Summary = cveData.PackName + " security update"
		SecNOtice.ReferenceLink = cveRef + cveData.CveNum
	} else {
		var sec models.SecurityNotice
		sec.CveNum = cveData.CveNum
		sec.OpenId = OpenEulId
		sec.InfluenceComponent = cveData.PackName
		sec.Status = 0
		sec.AffectStatus = "Fixed"
		sec.CveId = CveRes.CveId
		sec.Summary = cveData.PackName + " security update"
		sec.ReferenceLink = cveRef + cveData.CveNum
		if goe.Decription != "" && len(goe.Decription) > 0 {
			sec.Description = goe.Decription + "\n\n" + "Security Fix(es):" + "\n\n" + cveData.CveDesc + "(" + CveRes.CveNum + ")"
		} else {
			sec.Description = "Security Fix(es):" + "\n\n" + cveData.CveDesc + "(" + CveRes.CveNum + ")"
		}
		secid, secerr := models.CreateSecurityNotice(&sec)
		if secerr != nil {
			logs.Error("insert cve_security_notice failed CveNum:", cveData.CveNum)
			return false, errors.New("记录SA失败，暂时不处理")
		} else {
			logs.Info("insert cve_security_notice success secid: , cveNum: ", secid, cveData.CveNum)
		}
	}
	if scoreerr && secerrx {
		errx := models.UpdateCveRelat(&CveRes, &SecNOtice, &scoreRes)
		if errx != nil {
			logs.Error("UpdateExcelCveGroups, UpdateCveRelat, update failed, CveNum:",
				cveData.CveNum, ", errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else if scoreerr {
		errx := models.UpdateCveRelat1(&CveRes, &SecNOtice)
		if errx != nil {
			logs.Error("UpdateExcelCveGroups, UpdateCveRelat1, update failed,  CveNum:",
				cveData.CveNum, ", errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else {
		errx := models.UpdateCveRelat2(&CveRes, &scoreRes)
		if errx != nil {
			logs.Error("UpdateExcelCveGroups, UpdateCveRelat2, "+
				"update failed, CveNum:", cveData.CveNum, ",errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	}
	return true, nil
}

func InsertCveExcelGroups(cveData models.OriginExcel, cveRef, repoName string, openeulerNum int,
	goe models.GitPackageInfo, organizationID int8) (bool, error) {
	var vul models.VulnCenter
	vul.CveNum = cveData.CveNum
	vul.Description = cveData.CveDesc
	vul.Status = 0
	vul.CveVersion = cveData.CveVersion
	vul.RepairTime = cveData.RepairTime
	vul.PackName = repoName
	vul.RepoName = cveData.PackName
	vul.CveUrl = cveRef + cveData.CveNum
	vul.CveLevel = cveData.CveLevel
	vul.DataSource = 3
	vul.IsExport = 0
	vul.OrganizationID = organizationID
	var sec models.SecurityNotice
	sec.CveNum = cveData.CveNum
	sec.InfluenceComponent = cveData.PackName
	sec.Status = 0
	sec.AffectStatus = "Fixed"
	sec.Summary = cveData.PackName + " security update"
	sec.ReferenceLink = cveRef + cveData.CveNum
	specCharList := []string{"\n", "\r", "\t"}
	if goe.Decription != "" && len(goe.Decription) > 0 {
		sec.Description = RemoveSubstring(goe.Decription, specCharList) + "\n\n" +
			"Security Fix(es):" + "\n\n" + RemoveSubstring(cveData.CveDesc, specCharList)
	} else {
		sec.Description = "Security Fix(es):" + "\n\n" + RemoveSubstring(cveData.CveDesc, specCharList)
	}
	if sec.Description != "" && len(sec.Description) > 1 {
		sec.Description = deleteTailBlank(sec.Description) + "(" + vul.CveNum + ")"
	} else {
		sec.Description += "(" + vul.CveNum + ")"
	}
	var sc models.Score
	sc.CveNum = cveData.CveNum
	sc.NVDScore = cveData.NVDScore
	sc.OpenEulerScore = cveData.NVDScore
	sc.NvectorVule = cveData.NVDVector
	sc.OvectorVule = cveData.NVDVector
	sc.Nstatus = 0
	sc.Ostatus = 0
	if strings.ToLower(cveData.ScoreType) == "v2" ||
		strings.ToLower(cveData.ScoreType) == "v2.0" {
		sc.NaccessVector = cveData.AccessVector
		sc.OaccessVector = cveData.AccessVector
		sc.NaccessComplexity = cveData.AccessComplexity
		sc.OaccessComplexity = cveData.AccessComplexity
		sc.Nauthentication = cveData.Authentication
		sc.Oauthentication = cveData.Authentication
		sc.ScoreType = "v2"
	} else {
		sc.NattackVector = cveData.AttackVector
		sc.OattackVector = cveData.AttackVector
		sc.NattackComplexity = cveData.AttackComplexity
		sc.OattackComplexity = cveData.AttackComplexity
		sc.NprivilegeRequired = cveData.PrivilegeRequired
		sc.OprivilegeRequired = cveData.PrivilegeRequired
		sc.OuserInteraction = cveData.UserInteraction
		sc.NuserInteraction = cveData.UserInteraction
		sc.Oscope = cveData.Scope
		sc.Nscope = cveData.Scope
		sc.ScoreType = "v3"
	}
	sc.Nconfidentiality = cveData.Confidentiality
	sc.Oconfidentiality = cveData.Confidentiality
	sc.Nintegrity = cveData.Integrity
	sc.Ointegrity = cveData.Integrity
	sc.Navailability = cveData.Availability
	sc.Oavailability = cveData.Availability
	var opensa models.OpenEulerSA
	//var os models.OpenSaId
	osx, operr := models.QueryOpenSaLastId()
	var OpenNumData int
	if operr == nil {
		OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
		OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
		if err == nil {
			OpenNum += 1
		} else {
			OpenNum = openeulerNum
		}
		OpenNumData = OpenNum
	} else {
		OpenNumData = openeulerNum
	}
	OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
	opensa.OpenEulerSANum = OpenEulerSANum
	var scorecode models.ScoreRecord
	scorecode.NVDScore = cveData.NVDScore
	scorecode.NvectorVule = cveData.NVDVector
	scorecode.Status = 0
	cveid, cveerr := models.CreateCveRelat(&vul, &sec, &sc, &opensa, &scorecode)
	if cveerr != nil || cveid <= 0 {
		logs.Error("InsertCveExcelGroups, CreateCveRelat, "+
			"insert failed, CveNum:", cveData.CveNum, ", cveerr: ", cveerr)
		return false, errors.New("数据插入失败, 暂时不处理")
	}
	return true, nil
}

func UpdateCveGroups(cveData models.OriginUpstream, cveRef string, openeulerNum int, CveRes models.VulnCenter,
	cveDesc models.OriginUpstreamDesc, cveScV3 models.OriginUpstreamImpactScoreV3, goe models.GitPackageInfo,
	scopeType string, cveScV2 models.OriginUpstreamImpactScoreV2, pkList []string, organizationID int8) (bool, error) {
	var OpenEulId int64
	if len(cveDesc.EnDescription) > 2 {
		CveRes.Description = cveDesc.EnDescription
	}
	CveRes.CveVersion = pkList[1]
	if len(CveRes.RepairTime) < 2 && len(cveData.PublishedDate) > 2 {
		CveRes.RepairTime = cveData.PublishedDate
	}
	//CveRes.PackName = pkList[0]
	CveRes.RepoName = pkList[0]
	CveRes.CveUrl = cveRef + cveData.CveNum
	CveRes.CveLevel = cveScV3.CveLevel
	CveRes.OrganizationID = organizationID
	CveRes.FirstPerTime = cveData.FirstPerTime
	CveRes.FirstGetTime = cveData.FirstGetTime
	//CveRes.DataSource = 1
	if CveRes.DataSource != 4 && CveRes.Status != 0 && CveRes.Status != 1 {
		CveRes.Status = 1
		CveRes.IsExport = 0
	}
	//CveRes.Status = 1
	openEusa, operr := models.QueryOpenEulerSAByCveId(CveRes.CveId)
	if operr == false {
		var opensa models.OpenEulerSA
		osx, operr := models.QueryOpenSaLastId()
		var OpenNumData int
		if operr == nil {
			OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
			OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
			if err == nil {
				OpenNum += 1
			} else {
				OpenNum = openeulerNum
			}
			OpenNumData = OpenNum
		} else {
			OpenNumData = openeulerNum
		}
		OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(OpenNumData)
		opensa.OpenEulerSANum = OpenEulerSANum
		opensa.CveId = CveRes.CveId
		openEulerId, opEerr := models.CreateOpenEulerSA(&opensa)
		if opEerr == nil {
			OpenEulId = openEulerId
		} else {
			logs.Error("InsertCveExcelGroups, CreateOpenEulerSA, Update failed, err: ", opEerr)
			return false, errors.New("openEulerSA数据错误，暂时不处理")
		}
	} else {
		OpenEulId = openEusa.OpenId
	}
	scoreRes, scoreerr := models.QueryScoreByCveId(CveRes.CveId)
	if scoreerr {
		scoreRes.ScoreType = scopeType
		vectorString := ""
		if scopeType == "v3" {
			if cveScV3.VectorString != "" && len(cveScV3.VectorString) > 0 {
				index := strings.IndexAny(cveScV3.VectorString, "/")
				if index > 0 && strings.ToLower(cveScV3.VectorString)[:4] == "cvss" {
					vectorString = cveScV3.VectorString[index+1:]
				} else {
					vectorString = cveScV3.VectorString
				}
			}
			if scoreRes.NVDScore != cveScV3.BaseScore {
				var scorecode models.ScoreRecord
				scorecode.NVDScore = cveScV3.BaseScore
				scorecode.NvectorVule = vectorString
				scorecode.Status = 0
				scorecode.CveId = CveRes.CveId
				scoreid, err := models.InsertScoreRecord(&scorecode)
				if scoreid > 0 && err == nil {
					logs.Info("insert score_record success, id:", scoreid)
				} else {
					return false, errors.New("评分记录数据错误，暂时不处理")
				}
			}
			scoreRes.NVDScore = cveScV3.BaseScore
			scoreRes.NvectorVule = vectorString
			scoreRes.OpenId = OpenEulId
			scoreRes.Nstatus = 1
			scoreRes.NattackVector = cveScV3.AttackVector
			scoreRes.NattackComplexity = cveScV3.AttackComplexity
			scoreRes.NprivilegeRequired = cveScV3.PrivilegesRequired
			scoreRes.NuserInteraction = cveScV3.UserInteraction
			scoreRes.Nscope = cveScV3.Scope
			scoreRes.Nconfidentiality = cveScV3.ConfidentialityImpact
			scoreRes.Nintegrity = cveScV3.IntegrityImpact
			scoreRes.Navailability = cveScV3.AvailabilityImpact
		} else {
			if cveScV2.VectorString != "" && len(cveScV2.VectorString) > 0 {
				index := strings.IndexAny(cveScV2.VectorString, "/")
				if index > 0 && strings.ToLower(cveScV2.VectorString)[:4] == "cvss" {
					vectorString = cveScV2.VectorString[index+1:]
				} else {
					vectorString = cveScV2.VectorString
				}
			}
			if scoreRes.NVDScore != cveScV2.BaseScore {
				var scorecode models.ScoreRecord
				scorecode.NVDScore = cveScV2.BaseScore
				scorecode.NvectorVule = vectorString
				scorecode.Status = 0
				scorecode.CveId = CveRes.CveId
				scoreid, err := models.InsertScoreRecord(&scorecode)
				if scoreid > 0 && err == nil {
					logs.Info("insert score_record success, id:", scoreid)
				} else {
					return false, errors.New("评分记录数据错误，暂时不处理")
				}
			}
			scoreRes.NVDScore = cveScV2.BaseScore
			scoreRes.NvectorVule = vectorString
			scoreRes.OpenId = OpenEulId
			scoreRes.Nstatus = 1
			scoreRes.NaccessVector = cveScV2.AccessVector
			scoreRes.NaccessComplexity = cveScV2.AccessComplexity
			scoreRes.Nconfidentiality = cveScV2.ConfidentialityImpact
			scoreRes.Nintegrity = cveScV2.IntegrityImpact
			scoreRes.Navailability = cveScV2.AvailabilityImpact
			scoreRes.Nauthentication = cveScV2.Authentication
		}
	} else {
		var sc models.Score
		sc.CveNum = cveData.CveNum
		sc.OpenId = OpenEulId
		sc.CveId = CveRes.CveId
		sc.Nstatus = 0
		sc.Ostatus = 0
		sc.ScoreType = scopeType
		if scopeType == "v3" {
			sc.NVDScore = cveScV3.BaseScore
			sc.OpenEulerScore = cveScV3.BaseScore
			vectorString := ""
			if cveScV3.VectorString != "" && len(cveScV3.VectorString) > 0 {
				index := strings.IndexAny(cveScV3.VectorString, "/")
				if index > 0 && strings.ToLower(cveScV3.VectorString)[:4] == "cvss" {
					vectorString = cveScV3.VectorString[index+1:]
				} else {
					vectorString = cveScV3.VectorString
				}
			}
			sc.NvectorVule = vectorString
			sc.OvectorVule = vectorString
			sc.NattackVector = cveScV3.AttackVector
			sc.OattackVector = cveScV3.AttackVector
			sc.NattackComplexity = cveScV3.AttackComplexity
			sc.OattackComplexity = cveScV3.AttackComplexity
			sc.NprivilegeRequired = cveScV3.PrivilegesRequired
			sc.OprivilegeRequired = cveScV3.PrivilegesRequired
			sc.NuserInteraction = cveScV3.UserInteraction
			sc.OuserInteraction = cveScV3.UserInteraction
			sc.Nscope = cveScV3.Scope
			sc.Oscope = cveScV3.Scope
			sc.Nconfidentiality = cveScV3.ConfidentialityImpact
			sc.Oconfidentiality = cveScV3.ConfidentialityImpact
			sc.Nintegrity = cveScV3.IntegrityImpact
			sc.Ointegrity = cveScV3.IntegrityImpact
			sc.Navailability = cveScV3.AvailabilityImpact
			sc.Oavailability = cveScV3.AvailabilityImpact
		} else {
			sc.NVDScore = cveScV2.BaseScore
			sc.OpenEulerScore = cveScV2.BaseScore
			vectorString := ""
			if cveScV2.VectorString != "" && len(cveScV2.VectorString) > 0 {
				index := strings.IndexAny(cveScV2.VectorString, "/")
				if index > 0 && strings.ToLower(cveScV2.VectorString)[:4] == "cvss" {
					vectorString = cveScV2.VectorString[index+1:]
				} else {
					vectorString = cveScV2.VectorString
				}
			}
			sc.NvectorVule = vectorString
			sc.OvectorVule = vectorString
			sc.NaccessVector = cveScV2.AccessVector
			sc.OaccessVector = cveScV2.AccessVector
			sc.NaccessComplexity = cveScV2.AccessComplexity
			sc.OaccessComplexity = cveScV2.AccessComplexity
			sc.Nauthentication = cveScV2.Authentication
			sc.Oauthentication = cveScV2.Authentication
			sc.Nconfidentiality = cveScV2.ConfidentialityImpact
			sc.Oconfidentiality = cveScV2.ConfidentialityImpact
			sc.Nintegrity = cveScV2.IntegrityImpact
			sc.Ointegrity = cveScV2.IntegrityImpact
			sc.Navailability = cveScV2.AvailabilityImpact
			sc.Oavailability = cveScV2.AvailabilityImpact
		}
		scid, scerr := models.CreateScore(&sc)
		if scerr != nil {
			logs.Error("InsertCveExcelGroups, CreateScore, "+
				"insert failed, cveScV3:", cveScV3, ",scerr: ", scerr)
			return false, errors.New("记录评分失败，暂时不处理")
		} else {
			logs.Info("insert cve_score success scid: ", scid, "CveNum:", cveData.CveNum)
		}
	}
	SecNOtice, secerrx := models.QuerySecNoticeByCveId(CveRes.CveId)
	if secerrx {
		SecNOtice.CveId = CveRes.CveId
		SecNOtice.InfluenceComponent = pkList[0]
		SecNOtice.OpenId = OpenEulId
		SecNOtice.Summary = pkList[0] + " security update"
		SecNOtice.ReferenceLink = cveRef + cveData.CveNum
	} else {
		var sec models.SecurityNotice
		sec.CveNum = cveData.CveNum
		sec.OpenId = OpenEulId
		sec.InfluenceComponent = pkList[0]
		sec.Status = 0
		sec.AffectStatus = "Fixed"
		sec.CveId = CveRes.CveId
		sec.Summary = pkList[0] + " security update"
		sec.ReferenceLink = cveRef + cveData.CveNum
		if goe.Decription != "" && len(goe.Decription) > 0 {
			sec.Description = goe.Decription + "\n\n" + "Security Fix(es):" + "\n\n" + cveDesc.EnDescription + "(" + CveRes.CveNum + ")"
		} else {
			sec.Description = "Security Fix(es):" + "\n\n" + cveDesc.EnDescription + "(" + CveRes.CveNum + ")"
		}
		secid, secerr := models.CreateSecurityNotice(&sec)
		if secerr != nil {
			logs.Error("InsertCveExcelGroups, CreateSecurityNotice, "+
				"insert failed, CveNum:", cveData.CveNum, ",secerr: ", secerr)
			return false, errors.New("记录SA失败，暂时不处理")
		} else {
			logs.Info("insert cve_security_notice success secid: , cveNum: ", secid, cveData.CveNum)
		}
	}
	if scoreerr && secerrx {
		errx := models.UpdateCveRelat(&CveRes, &SecNOtice, &scoreRes)
		if errx != nil {
			logs.Error("InsertCveExcelGroups, UpdateCveRelat, "+
				"update failed, CveNum:", cveData.CveNum, ",errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else if scoreerr {
		errx := models.UpdateCveRelat1(&CveRes, &SecNOtice)
		if errx != nil {
			logs.Error("InsertCveExcelGroups, UpdateCveRelat1, "+
				"update failed, CveNum:", cveData.CveNum, ",errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	} else {
		errx := models.UpdateCveRelat2(&CveRes, &scoreRes)
		if errx != nil {
			logs.Error("InsertCveExcelGroups, UpdateCveRelat2, "+
				"update failed, CveNum:", cveData.CveNum, ", errx: ", errx)
			return false, errors.New("数据更新失败, 暂时不处理")
		}
	}
	return true, nil
}

func InsertCveGroups(cveData models.OriginUpstream, cveRef, repoNme string,
	openeulerNum int, cveDesc models.OriginUpstreamDesc,
	cveScV3 models.OriginUpstreamImpactScoreV3, goe models.GitPackageInfo,
	scopeType string, cveScV2 models.OriginUpstreamImpactScoreV2,
	pkList []string, organizationID int8) (bool, error) {
	var vul models.VulnCenter
	vul.CveNum = cveData.CveNum
	vul.FirstPerTime = cveData.FirstPerTime
	vul.FirstGetTime = cveData.FirstGetTime
	vul.Description = cveDesc.EnDescription
	vul.Status = 0
	vul.CveVersion = pkList[1]
	vul.RepairTime = cveData.PublishedDate
	vul.RepoName = pkList[0]
	vul.PackName = repoNme
	vul.CveUrl = cveRef + cveData.CveNum
	vul.CveLevel = cveScV3.CveLevel
	vul.DataSource = 1
	vul.IsExport = 0
	vul.OrganizationID = organizationID
	var sec models.SecurityNotice
	sec.CveNum = cveData.CveNum
	sec.InfluenceComponent = pkList[0]
	sec.Status = 0
	sec.AffectStatus = "Fixed"
	sec.Summary = pkList[0] + " security update"
	sec.ReferenceLink = cveRef + cveData.CveNum
	specCharList := []string{"\n", "\r", "\t"}
	if goe.Decription != "" && len(goe.Decription) > 0 {
		sec.Description = RemoveSubstring(goe.Decription, specCharList) + "\n\n" + "Security Fix(es):" + "\n\n" +
			RemoveSubstring(cveDesc.EnDescription, specCharList)
	} else {
		sec.Description = "Security Fix(es):" + "\n\n" + RemoveSubstring(cveDesc.EnDescription, specCharList)
	}
	if sec.Description != "" && len(sec.Description) > 1 {
		sec.Description = deleteTailBlank(sec.Description) + "(" + vul.CveNum + ")"
	} else {
		sec.Description += "(" + vul.CveNum + ")"
	}
	var sc models.Score
	sc.CveNum = cveData.CveNum
	sc.Nstatus = 0
	sc.Ostatus = 0
	if scopeType == "v3" {
		sc.NVDScore = cveScV3.BaseScore
		sc.OpenEulerScore = cveScV3.BaseScore
		vectorString := ""
		if cveScV3.VectorString != "" && len(cveScV3.VectorString) > 0 {
			index := strings.IndexAny(cveScV3.VectorString, "/")
			if index > 0 && strings.ToLower(cveScV3.VectorString)[:4] == "cvss" {
				vectorString = cveScV3.VectorString[index+1:]
			} else {
				vectorString = cveScV3.VectorString
			}
		}
		sc.NvectorVule = vectorString
		sc.OvectorVule = vectorString
		sc.NattackVector = cveScV3.AttackVector
		sc.OattackVector = cveScV3.AttackVector
		sc.NattackComplexity = cveScV3.AttackComplexity
		sc.OattackComplexity = cveScV3.AttackComplexity
		sc.NprivilegeRequired = cveScV3.PrivilegesRequired
		sc.OprivilegeRequired = cveScV3.PrivilegesRequired
		sc.NuserInteraction = cveScV3.UserInteraction
		sc.OuserInteraction = cveScV3.UserInteraction
		sc.Nscope = cveScV3.Scope
		sc.Oscope = cveScV3.Scope
		sc.Nconfidentiality = cveScV3.ConfidentialityImpact
		sc.Oconfidentiality = cveScV3.ConfidentialityImpact
		sc.Nintegrity = cveScV3.IntegrityImpact
		sc.Ointegrity = cveScV3.IntegrityImpact
		sc.Navailability = cveScV3.AvailabilityImpact
		sc.Oavailability = cveScV3.AvailabilityImpact
	} else {
		sc.NVDScore = cveScV2.BaseScore
		sc.OpenEulerScore = cveScV2.BaseScore
		vectorString := ""
		if cveScV2.VectorString != "" && len(cveScV2.VectorString) > 0 {
			index := strings.IndexAny(cveScV2.VectorString, "/")
			if index > 0 && strings.ToLower(cveScV2.VectorString)[:4] == "cvss" {
				vectorString = cveScV2.VectorString[index+1:]
			} else {
				vectorString = cveScV2.VectorString
			}
		}
		sc.NvectorVule = vectorString
		sc.OvectorVule = vectorString
		sc.NaccessVector = cveScV2.AccessVector
		sc.OaccessVector = cveScV2.AccessVector
		sc.NaccessComplexity = cveScV2.AccessComplexity
		sc.OaccessComplexity = cveScV2.AccessComplexity
		sc.Nauthentication = cveScV2.Authentication
		sc.Oauthentication = cveScV2.Authentication
		sc.Nconfidentiality = cveScV2.ConfidentialityImpact
		sc.Oconfidentiality = cveScV2.ConfidentialityImpact
		sc.Nintegrity = cveScV2.IntegrityImpact
		sc.Ointegrity = cveScV2.IntegrityImpact
		sc.Navailability = cveScV2.AvailabilityImpact
		sc.Oavailability = cveScV2.AvailabilityImpact
	}
	sc.ScoreType = scopeType
	var opensa models.OpenEulerSA
	//var os models.OpenSaId
	osx, operr := models.QueryOpenSaLastId()
	var OpenNumData int
	if operr == nil {
		OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
		OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
		if err == nil {
			OpenNum += 1
		} else {
			OpenNum = openeulerNum
		}
		OpenNumData = OpenNum
	} else {
		OpenNumData = openeulerNum
	}
	OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
	opensa.OpenEulerSANum = OpenEulerSANum
	var scorecode models.ScoreRecord
	scorecode.NVDScore = cveScV3.BaseScore
	scorecode.NvectorVule = cveScV3.VectorString
	scorecode.Status = 0
	cveId, cveErr := models.CreateCveRelat(&vul, &sec, &sc, &opensa, &scorecode)
	if cveErr != nil || cveId <= 0 {
		logs.Error("InsertCveGroups, CreateCveRelat, insert failed, "+
			"CveNum:", cveData.CveNum, ",cveErr: ", cveErr)
		return false, errors.New("数据插入失败, 暂时不处理")
	}
	return true, nil
}

// Synchronize the data returned by the Chinese Academy of Sciences
func GenCveVuler(cveData models.OriginUpstream, cveRef string, openeulernum int) (bool, error) {
	if cveData.Ids == "" || cveData.CveNum == "" {
		logs.Error("GenCveVuler, The current data cveNum is empty "+
			"and will not be processed temporarily, data: ", cveData)
		models.UpdateOriginStatus(common.GetCurTime(),
			cveData.PackName, cveData.Version, cveData.CveId, 3)
		UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum, "ids or cveNum is empty", 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	BConfig, err := config.NewConfig("ini", "conf/app.conf")
	if err != nil {
		logs.Error("GenCveVuler, config init error:", err, cveData.CveNum)
		models.UpdateOriginStatus(common.GetCurTime(),
			cveData.PackName, cveData.Version, cveData.CveId, 0)
		return false, err
	}
	years, confOk := BConfig.Int("cve::cve_number_t")
	if confOk != nil {
		logs.Error("GenCveVuler, config cve::cve_number_t, error:", confOk, cveData.CveNum)
		models.UpdateOriginStatus(common.GetCurTime(),
			cveData.PackName, cveData.Version, cveData.CveId, 0)
		return false, errors.New("数据错误，暂时不处理")
	}
	// Import cve as data after 2018
	cveNumList := strings.Split(cveData.CveNum, "-")
	if cveNumList != nil && len(cveNumList) > 1 {
		cveYears, yearErr := strconv.Atoi(cveNumList[1])
		if yearErr == nil {
			if cveYears <= years {
				models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 5)
				logs.Error("GenCveVuler, cve: ", cveData.CveNum, ",Need to be greater than: ", years,
					", Otherwise there is no need to submit an issue on git, cveData: ", cveData)
				UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum, cveData.CveNum+" cve year limited", 5)
				return false, errors.New("数据错误，暂时不处理")
			}
		}
	}
	cveDesc, ok := models.QueryCveDesc(cveData.CveId)
	if !ok {
		logs.Error("GenCveVuler, QueryCveDesc, The current data description is empty "+
			"and will not be processed temporarily, data: ", cveData)
		models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
		UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum, "cve description information is empty", 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	cveImpact, ok := models.QueryCveImpact(cveData.CveId)
	if !ok {
		logs.Error("GenCveVuler, QueryCveImpact, Data query failed, data: ", cveData)
		models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
		UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum, "cve score information is empty 1", 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	scopeType := "v3"
	//var cveScV2 models.OriginUpstreamImpactScoreV2
	cveScore, ok := models.QueryCveScore(cveImpact.ImpactId, "v3")
	if !ok {
		scopeType = "v2"
	}
	cveScV3, ok := models.QueryCveCvssV3(cveScore.ScoreId)
	if !ok {
		scopeType = "v2"
	}
	if cveScV3.VectorString == "" || len(cveScV3.VectorString) == 0 || cveScV3.BaseScore == 0.0 {
		scopeType = "v2"
	}
	cveScoreV2, ok2 := models.QueryCveScore(cveImpact.ImpactId, "v2")
	if !ok2 {
		if scopeType == "v2" {
			logs.Error("GenCveVuler, QueryCveScore3, data: ", cveData, ",cveImpact: ", cveImpact)
			models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
			UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum, "cve score information is empty 2", 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	}
	cveScV2, okV2 := models.QueryCveCvssV2(cveScoreV2.ScoreId)
	if !okV2 {
		if scopeType == "v2" {
			logs.Error("GenCveVuler, QueryCveCvssV2, data: ", cveData, ",cveScore: ", cveScore)
			models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
			UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum, "cve score information is empty 3", 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	}
	packNameMap := map[string]string{}
	packNameList := []string{}
	if cveData.PackName != "" && len(cveData.PackName) > 0 {
		packNameList = strings.Split(cveData.PackName, ",")
		if len(packNameList) > 0 {
			for _, pk := range packNameList {
				pkList := strings.Split(pk, "==")
				if len(pkList) == 2 {
					if _, ok := packNameMap[pkList[0]]; ok {
						versionList := strings.Split(packNameMap[pkList[0]], ",")
						verExist := false
						for _, vl := range versionList {
							if vl == pkList[1] {
								verExist = true
								break
							}
						}
						if !verExist {
							packNameMap[pkList[0]] += "," + pkList[1]
						}
					} else {
						packNameMap[pkList[0]] = pkList[1]
					}
				}
			}
		}
	}
	for key, value := range packNameMap {
		if key != "" && len(key) > 1 {
			pkList := []string{}
			pkList = append(pkList, key)
			versionFlag := false
			gaussFlag := false
			sporeFlag := false
			var goe models.GitPackageInfo
			openGausVersion := make([]string, 0)
			mindSporeVersion := make([]string, 0)
			openEulerVersion := make([]string, 0)
			versionList := make([]string, 0)
			if value != "" && len(value) > 0 {
				versionList = strings.Split(value, ",")
				if len(versionList) > 0 {
					for _, ver := range versionList {
						if ver != "" && len(ver) > 0 {
							opy := models.OpenGussYaml{PackageName: key, Version: ver}
							gaussErr := models.GetOpengaussYaml(&opy, "PackageName", "Version")
							if gaussErr == nil && opy.Id > 0 {
								openGausVersion = append(openGausVersion, ver)
								gaussFlag = true
							}
							ms := models.MindSporeYaml{PackageName: key, Version: ver}
							sporeErr := models.GetMindSporeYaml(&ms, "PackageName", "Version")
							if sporeErr == nil && ms.Id > 0 {
								mindSporeVersion = append(mindSporeVersion, ver)
								sporeFlag = true
							}
							goe, ok = models.QueryCveOpeneulerDetaildataByName(key, ver)
							if ok {
								versionFlag = true
								openEulerVersion = append(openEulerVersion, ver)
							} else {
								logs.Error("GenCveVuler, The corresponding warehouse data is not queried, data: ", cveData)
							}
						}
					}
				}
			}
			if !versionFlag && !gaussFlag && !sporeFlag {
				models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 4)
				logs.Error("GenCveVuler, The version information corresponds to the error, ",
					cveData.PackName, cveData.Version, cveData.CveNum)
				UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum,
					"The cve component or version information cannot be matched to the corresponding data", 4)
				return false, errors.New("数据错误，暂时不处理")
			}
			organizationList := make([]int8, 0)
			organizationID := int8(1)
			if versionFlag {
				organizationList = append(organizationList, organizationID)
			}
			if gaussFlag {
				organizationID = int8(2)
				organizationList = append(organizationList, organizationID)
			}
			if sporeFlag {
				organizationID = int8(3)
				organizationList = append(organizationList, organizationID)
			}
			failFlag := false
			for _, orId := range organizationList {
				ok, addErr := AddOrSelectToCenter(key, cveRef, scopeType, value, cveData,
					openGausVersion, openEulerVersion, mindSporeVersion, pkList, openeulernum,
					cveDesc, cveScV3, goe, cveScV2, orId)
				if !ok || addErr != nil {
					logs.Error("AddOrSelectToCenter, addErr: ", addErr)
					failFlag = true
					continue
				}
			}
			if failFlag {
				logs.Error("Part of the data failed")
				models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
				UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum,
					"Version does not match, data synchronization failed", 3)
				return false, errors.New("Part of the data failed")
			}
		}
	}
	models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 2)
	UpdateOriginUpstreamRecord(cveData.Ids, cveData.CveNum, "success", 2)
	return true, nil
}

func AddOrSelectToCenter(packageName, cveRef, scopeType, value string, cveData models.OriginUpstream,
	openGausVersion, openEulerVersion, mindSporeVersion, pkList []string, openeulerNum int,
	cveDesc models.OriginUpstreamDesc, cveScV3 models.OriginUpstreamImpactScoreV3, goe models.GitPackageInfo,
	cveScV2 models.OriginUpstreamImpactScoreV2, organizationID int8) (bool, error) {
	if organizationID == 3 {
		if len(mindSporeVersion) > 0 {
			mindMap := make(map[string]string)
			for _, ver := range mindSporeVersion {
				ms := models.MindSporeYaml{PackageName: packageName, Version: ver}
				msy, mErr := models.GetMindSporeYamlAll(&ms)
				if len(msy) > 0 {
					for _, my := range msy {
						if _, ok := mindMap[my.Repo]; !ok {
							mindMap[my.Repo] = packageName
						}
					}
				} else {
					logs.Error("MindSpore, mErr: ", mErr)
				}
			}
			if len(mindMap) > 0 {
				for repo, _ := range mindMap {
					ok, dErr := AddOrDataToCenter(repo, packageName, cveRef, scopeType, value, cveData,
						openGausVersion, openEulerVersion, mindSporeVersion, pkList, openeulerNum,
						cveDesc, cveScV3, goe, cveScV2, organizationID)
					if !ok {
						logs.Error("MindSpore, dErr: ", dErr)
					}
				}
			}
		}
	} else if organizationID == 2 {
		if len(openGausVersion) > 0 {
			gaussMap := make(map[string]string)
			for _, ver := range openGausVersion {
				opy := models.OpenGussYaml{PackageName: packageName, Version: ver}
				ogy, oErr := models.GetOpengaussYamlAll(&opy)
				if len(ogy) > 0 {
					for _, gy := range ogy {
						if _, ok := gaussMap[gy.Repo]; !ok {
							gaussMap[gy.Repo] = packageName
						}
					}
				} else {
					logs.Error("openGauss, dErr: ", oErr)
				}
			}
			if len(gaussMap) > 0 {
				for repo, _ := range gaussMap {
					ok, dErr := AddOrDataToCenter(repo, packageName, cveRef, scopeType, value, cveData,
						openGausVersion, openEulerVersion, mindSporeVersion, pkList, openeulerNum,
						cveDesc, cveScV3, goe, cveScV2, organizationID)
					if !ok {
						logs.Error("openGauss, dErr: ", dErr)
					}
				}
			}
		}
	} else {
		ok, dErr := AddOrDataToCenter(packageName, packageName, cveRef, scopeType, value, cveData,
			openGausVersion, openEulerVersion, mindSporeVersion, pkList, openeulerNum,
			cveDesc, cveScV3, goe, cveScV2, organizationID)
		if !ok {
			logs.Error("openEuler, dErr: ", dErr)
			return false, dErr
		}
	}
	return true, nil
}

func AddOrDataToCenter(repoNme, packageName, cveRef, scopeType, value string, cveData models.OriginUpstream,
	openGausVersion, openEulerVersion, mindSporeVersion, pkList []string, openeulerNum int,
	cveDesc models.OriginUpstreamDesc, cveScV3 models.OriginUpstreamImpactScoreV3, goe models.GitPackageInfo,
	cveScV2 models.OriginUpstreamImpactScoreV2, organizationID int8) (bool, error) {
	CveRes, err := models.QueryCveByNum(cveData.CveNum, repoNme, organizationID)
	if err {
		CveRes.RepoName = packageName
		retVersion := AddCveVersion(organizationID, openGausVersion,
			openEulerVersion, mindSporeVersion, CveRes.CveVersion)
		pkList = append(pkList, retVersion)
		lockx.Lock()
		ok, err := UpdateCveGroups(cveData, cveRef, openeulerNum, CveRes, cveDesc, cveScV3, goe,
			scopeType, cveScV2, pkList, organizationID)
		lockx.Unlock()
		if !ok {
			logs.Error("GenCveVuler, UpdateCveGroups, cveData: ", cveData, ", err: ", err)
			//models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	} else {
		retVersion := AddCveVersion(organizationID, openGausVersion,
			openEulerVersion, mindSporeVersion, "")
		pkList = append(pkList, retVersion)
		lockx.Lock()
		ok, err := InsertCveGroups(cveData, cveRef, repoNme, openeulerNum, cveDesc, cveScV3, goe,
			scopeType, cveScV2, pkList, organizationID)
		lockx.Unlock()
		if !ok {
			logs.Error("GenCveVuler, InsertCveGroups, cveData: ", cveData, ", err: ", err)
			//models.UpdateOriginStatus(common.GetCurTime(), cveData.PackName, cveData.Version, cveData.CveId, 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	}
	return true, nil
}

func UpdateOriginUpstreamRecord(ids, cveNum, errDesc string, errStatus int8) {
	our := models.OriginUpstreamRecord{}
	err := models.QueryOriginUpstreamRecord(&our, ids, cveNum)
	if our.CveId > 0 {
		our.SysStatus = errStatus
		our.ErrDesc = errDesc
		upErr := models.UpdateOriginUpstreamRecord(&our, "SysStatus", "ErrDesc")
		if upErr != nil {
			logs.Error("upErr: ", upErr)
		}
	} else {
		logs.Error("err: ", err)
	}
}

func AddCveVersion(organizationID int8, openGausVersion,
	openEulerVersion, mindSporeVersion []string, cveVersion string) (retVersion string) {
	retVersion = cveVersion
	cveVerList := strings.Split(cveVersion, ",")
	if organizationID == 3 {
		if len(cveVerList) > 0 && len(mindSporeVersion) > 0 {
			mindSporeVersion = append(mindSporeVersion, cveVerList...)
		}
		mindSlice := make([]string, 0)
		if len(mindSporeVersion) > 0 {
			sort.Strings(mindSporeVersion)
			repSlice := common.SliceRemoveDup(mindSporeVersion)
			for _, rep := range repSlice {
				if len(rep.(string)) > 0 {
					mindSlice = append(mindSlice, rep.(string))
				}
			}
		}
		if len(mindSlice) > 0 {
			retVersion = strings.Join(mindSlice, ",")
		}
	} else if organizationID == 2 {
		if len(cveVerList) > 0 && len(openGausVersion) > 0 {
			openGausVersion = append(openGausVersion, cveVerList...)
		}
		gaussSlice := make([]string, 0)
		if len(openGausVersion) > 0 {
			sort.Strings(openGausVersion)
			repSlice := common.SliceRemoveDup(openGausVersion)
			for _, rep := range repSlice {
				if len(rep.(string)) > 0 {
					gaussSlice = append(gaussSlice, rep.(string))
				}
			}
		}
		if len(gaussSlice) > 0 {
			retVersion = strings.Join(gaussSlice, ",")
		}
	} else {
		if len(cveVerList) > 0 && len(openEulerVersion) > 0 {
			openEulerVersion = append(openEulerVersion, cveVerList...)
		}
		eulerSlice := make([]string, 0)
		if len(openEulerVersion) > 0 {
			tmpEulerSlice := make([]string, len(openEulerVersion))
			for _, es := range openEulerVersion {
				if len(es) > 0 {
					versx := common.BranchVersionRep(es)
					tmpEulerSlice = append(tmpEulerSlice, versx)
				}
			}
			sort.Strings(tmpEulerSlice)
			repSlice := common.SliceRemoveDup(tmpEulerSlice)
			for _, rep := range repSlice {
				eulerSlice = append(eulerSlice, rep.(string))
			}
		}
		if len(eulerSlice) > 0 {
			retVersion = strings.Join(eulerSlice, ",")
		}
	}
	if len(retVersion) > 0 && retVersion[0] == ',' {
		retVersion = retVersion[1:]
	}
	return retVersion
}

func SyncCveVuler(cveData models.OriginExcel, cveRef string, openeulerNum, manYears int) (bool, error) {
	if cveData.CveNum == "" || len(cveData.CveNum) == 0 {
		logs.Error("SyncCveVuler, The current data cveNum is empty and "+
			"will not be processed temporarily, data: ", cveData)
		models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 3)
		return false, errors.New("数据错误，暂时不处理")
	}
	organizationID := int8(1)
	organizationList := make([]int8, 0)
	ms := models.MindSporeYaml{PackageName: cveData.PackName, Version: cveData.CveVersion}
	sporeErr := models.GetMindSporeYaml(&ms, "PackageName", "Version")
	if sporeErr == nil && ms.Id > 0 {
		organizationID = 3
		organizationList = append(organizationList, organizationID)
	}
	opy := models.OpenGussYaml{PackageName: cveData.PackName, Version: cveData.CveVersion}
	openErr := models.GetOpengaussYaml(&opy, "PackageName", "Version")
	if openErr == nil && opy.Id > 0 {
		organizationID = 2
		organizationList = append(organizationList, organizationID)
	}
	var god models.GitOpenEuler
	god.PackageName = cveData.PackName
	god.Version = cveData.CveVersion
	god.Status = 1
	ok := models.QueryCveOpeneulerdata(&god)
	if !ok {
		if organizationID == 1 {
			logs.Error("The repo and version correspond to errors, data: ", cveData)
			models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 4)
			return false, errors.New("The repo and version correspond to errors and" +
				" will not be processed temporarily")
		}
	} else {
		organizationList = append(organizationList, organizationID)
	}
	// Import cve as data after 2018
	cveNumList := strings.Split(cveData.CveNum, "-")
	if cveNumList != nil && len(cveNumList) > 1 {
		cveYears, yearErr := strconv.Atoi(cveNumList[1])
		if yearErr == nil {
			if cveYears <= manYears {
				logs.Error("limited cve years, cveData: ", cveData, ", err: ", cveYears, manYears)
				models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 7)
				return false, errors.New("limited cve years")
			}
		}
	}
	goe, ok := models.QueryCveOpeneulerDetaildataByName(cveData.PackName, cveData.CveVersion)
	if !ok {
		logs.Error("SyncCveVuler, The repo exists, but the yaml data source does not exist,"+
			" repo: ", cveData.PackName, cveData.CveVersion)
	}
	failFlag := false
	for _, orId := range organizationList {
		exOk, exErr := AddExcelToCenter(cveData, cveRef, openeulerNum, goe, orId)
		if !exOk || exErr != nil {
			logs.Error("AddExcelToCenter, exErr: ", exErr)
			failFlag = true
		}
	}
	if failFlag {
		return false, errors.New("数据错误，暂时不处理")
	}
	models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 2)
	return true, nil
}

func AddExcelToCenter(cveData models.OriginExcel, cveRef string, openeulerNum int,
	goe models.GitPackageInfo, organizationID int8) (bool, error) {
	if organizationID == 3 {
		ms := models.MindSporeYaml{PackageName: cveData.PackName, Version: cveData.CveVersion}
		msy, mErr := models.GetMindSporeYamlAll(&ms)
		if len(msy) > 0 {
			for _, my := range msy {
				ok, dErr := AddExDataToCenter(cveData, cveRef, my.Repo, openeulerNum, goe, organizationID)
				if !ok {
					logs.Error("MindSpore, dErr: ", dErr)
					return ok, dErr
				}
			}
		} else {
			logs.Error("MindSpore, mErr: ", mErr)
			return false, mErr
		}
	} else if organizationID == 2 {
		opy := models.OpenGussYaml{PackageName: cveData.PackName, Version: cveData.CveVersion}
		ogy, oErr := models.GetOpengaussYamlAll(&opy)
		if len(ogy) > 0 {
			for _, gy := range ogy {
				ok, dErr := AddExDataToCenter(cveData, cveRef, gy.Repo, openeulerNum, goe, organizationID)
				if !ok {
					logs.Error("openGauss, dErr: ", dErr)
					return ok, dErr
				}
			}
		} else {
			logs.Error("openGauss, oErr: ", oErr)
			return false, oErr
		}
	} else {
		ok, dErr := AddExDataToCenter(cveData, cveRef, cveData.PackName, openeulerNum, goe, organizationID)
		if !ok {
			logs.Error("openEuler, dErr: ", dErr)
			return ok, dErr
		}
	}
	return true, nil
}

func AddExDataToCenter(cveData models.OriginExcel,
	cveRef, repoName string, openeulerNum int,
	goe models.GitPackageInfo, organizationID int8) (bool, error) {
	CveRes, err := models.QueryCveByNum(cveData.CveNum, repoName, organizationID)
	if err {
		CveRes.RepoName = cveData.PackName
		retVersion := AddCveVersion(organizationID, []string{cveData.CveVersion},
			[]string{cveData.CveVersion}, []string{cveData.CveVersion}, CveRes.CveVersion)
		cveData.CveVersion = retVersion
		lockx.Lock()
		ok, err := UpdateExcelCveGroups(cveData, cveRef, openeulerNum, CveRes, goe, organizationID)
		lockx.Unlock()
		if !ok {
			logs.Error("AddExDataToCenter, UpdateExcelCveGroups, cveData: ", cveData, ", err: ", err)
			models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	} else {
		retVersion := AddCveVersion(organizationID, []string{cveData.CveVersion},
			[]string{cveData.CveVersion}, []string{cveData.CveVersion}, "")
		cveData.CveVersion = retVersion
		lockx.Lock()
		ok, err := InsertCveExcelGroups(cveData, cveRef, repoName, openeulerNum, goe, organizationID)
		lockx.Unlock()
		if !ok {
			logs.Error("AddExDataToCenter, InsertCveExcelGroups, cveData: ", cveData, ", err: ", err)
			models.UpdateOriginExcelStatus(common.GetCurTime(), cveData.CveId, 3)
			return false, errors.New("数据错误，暂时不处理")
		}
	}
	return true, nil
}

func GetCveOriginData(prcnum, days, openeulernum, credibilityLevel int, cveRef string) (bool, error) {
	defer common.Catchs()
	count := 0
	beforeTime := common.GetBeforeTime(days)
	for {
		osx, num, err := models.QueryOriginCve(beforeTime, prcnum, credibilityLevel)
		if err != nil || num == 0 {
			logs.Info("There is currently no cve raw data processing, err: ", err,
				", Processing time range > beforetime: ", beforeTime,
				"curtime: ", common.GetCurTime())
			break
		}
		ch := make(chan int, len(osx))
		for i, cveOrg := range osx {
			count = count + 1
			// Add mutex
			lockOk := models.LockUpdateOriginStatus(common.GetCurTime(), cveOrg.PackName,
				cveOrg.Version, cveOrg.CveId, cveOrg.Status, 15)
			if !lockOk {
				logs.Error("Current data is being processed: PackName: ",
					cveOrg.PackName, cveOrg.Version, cveOrg.CveId)
				ch <- i
				continue
			}
			go func(idx int, cveData models.OriginUpstream, locOpenEulernum int, locCveRef string) {
				ok, err := GenCveVuler(cveData, locCveRef, locOpenEulernum)
				if !ok {
					logs.Error("GenCveVuler, cveData: ", cveData, "Processing failed, err: ", err)
				}
				ch <- idx
			}(i, cveOrg, openeulernum, cveRef)
		}
		for i := 0; i < cap(ch); i++ {
			<-ch
		}
		close(ch)
	}
	return true, nil
}

func GetCveOriginExcelData(prcnum, days, openeulerNum int, cveRef string) (bool, error) {
	defer common.Catchs()
	manYears, ok := beego.AppConfig.Int("cve::cve_number_m")
	if ok != nil {
		logs.Error("config cve::manYears error:", ok)
		return false, ok
	}
	count := 0
	beforeTime := common.GetBeforeTime(days)
	for {
		osx, num, err := models.QueryOriginCveExcel(beforeTime, prcnum)
		if err != nil || num == 0 {
			logs.Info("There is currently no cve raw data processing imported by excel, err: ", err,
				", beforetime: ", beforeTime,
				"curtime: ", common.GetCurTime())
			break
		}
		logs.Info("Excel has a total of: ", num, "Articles of data need to be processed,", osx)
		ch := make(chan int, len(osx))
		for i, cveOrg := range osx {
			count = count + 1
			logs.Info("The current normal analysis: ", count, "Pieces of data, i:", i, ", cvenum: ", cveOrg.CveNum)
			// add mutex
			lockOk := models.LockUpdateOriginExcelStatus(common.GetCurTime(), cveOrg.CveId, 15)
			if !lockOk {
				logs.Error("Current data is being processed, cveNum: ", cveOrg.CveNum, ",cveId: ", cveOrg.CveId)
				ch <- i
				continue
			}
			go func(idx, manYears, locOpeneulerNum int, cveData models.OriginExcel, locCveRef string) {
				ok, err := SyncCveVuler(cveData, locCveRef, openeulerNum, manYears)
				if !ok {
					logs.Error("SyncCveVuler, err: ", err, "cveData: ", cveData)
				}
				ch <- idx
			}(i, manYears, openeulerNum, cveOrg, cveRef)
		}
		for i := 0; i < cap(ch); i++ {
			<-ch
		}
		close(ch)
	}
	return true, nil
}

func InsertIssueCveGroups(cveData models.GiteOriginIssue, lop models.Loophole, cveRef string, openeulernum int,
	cveStatus int8, goe models.GitPackageInfo, owner string) (bool, error) {
	var vul models.VulnCenter
	vul.CveNum = cveData.CveNumber
	specCharList := []string{"</br><br>", "\n", "\r", "\t"}
	briefIntroduction := RemoveSubstring(lop.BriefIntroduction, specCharList)
	vul.Description = briefIntroduction
	vul.Status = cveStatus
	vul.OrganizationID = cveData.OrganizationID
	owner = beego.AppConfig.String("gitee::owner")
	accessToken := beego.AppConfig.String("gitee::git_token")
	if vul.OrganizationID == 3 {
		owner = beego.AppConfig.String("mindspore::mindspore_owner")
		accessToken = beego.AppConfig.String("mindspore::git_mindspore_token")
	} else if vul.OrganizationID == 2 {
		owner = beego.AppConfig.String("opengauss::gauss_owner")
		accessToken = beego.AppConfig.String("opengauss::git_gauss_token")
	}
	retVersion := AddCveVersion(vul.OrganizationID, []string{},
		strings.Split(RemoveSubstring(lop.Version, specCharList), ","), []string{}, "")
	vul.CveVersion = retVersion
	vul.RepairTime = ""
	vul.PackName = cveData.RepoPath
	vul.RepoName = lop.Components
	vul.CveUrl = cveRef + cveData.CveNumber
	vul.IsExport = 0
	vul.DataSource = 4
	v2, cvsError := strconv.ParseFloat(lop.CvsScore, 64)
	if cvsError != nil {
		vul.CveLevel = "Critical"
	}
	if len(briefIntroduction) < 2 || v2 <= 0 || len(lop.CvsVector) < 1 &&
		cveData.IssueState != "已拒绝" && cveData.IssueState != "已挂起" {
		vul.Status = 1
	}
	vul.CveLevel = models.OpenEulerScoreProc(v2)
	var sec models.SecurityNotice
	sec.CveNum = cveData.CveNumber
	sec.InfluenceComponent = cveData.RepoPath
	sec.Status = 0
	sec.AffectStatus = "Fixed"
	sec.Summary = cveData.RepoPath + " security update"
	sec.Description = RemoveSubstring(goe.Decription, specCharList) + "\n\n" + "Security Fix(es):" + "\n\n" +
		RemoveSubstring(lop.BriefIntroduction, specCharList)
	if sec.Description != "" && len(sec.Description) > 1 {
		sec.Description = deleteTailBlank(sec.Description) + "(" + vul.CveNum + ")"
	} else {
		sec.Description += "(" + vul.CveNum + ")"
	}
	opScoreLeve := ""
	opScore, opError := strconv.ParseFloat(lop.OpScore, 64)
	if opError != nil {
		opScoreLeve = "Critical"
	} else {
		opScoreLeve = models.OpenEulerScoreProc(opScore)
	}
	sec.ReferenceLink = cveRef + cveData.CveNumber
	affectBrands := ""
	if lop.InfVersion != "" && len(lop.InfVersion) > 1 {
		affectBrands = AddAffectBrands(lop.InfVersion)
	} else {
		affectBrands = lop.InfProduct
	}
	sec.Introduction = "An update for " + cveData.RepoPath + " is now available for " + affectBrands + "."
	sec.Theme = sec.Introduction[:len(sec.Introduction)-1] + ".\n\n" + "openEuler Security has rated this" +
		" update as having a security impact of " + strings.ToLower(opScoreLeve) + ". A Common Vunlnerability" +
		" Scoring System(CVSS)base score,which gives a detailed severity rating," +
		" is available for each vulnerability from the CVElink(s) in the References section."
	sec.AffectProduct = affectBrands
	var sc models.Score
	sc.CveNum = cveData.CveNumber
	nVDScore, nvdError := strconv.ParseFloat(lop.CvsScore, 64)
	if nvdError == nil {
		sc.NVDScore = nVDScore
	}
	openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
	if openError == nil {
		sc.OpenEulerScore = openEulerScore
	}
	sc.NvectorVule = lop.CvsVector
	sc.OvectorVule = lop.OpVector
	sc.Nstatus = 0
	sc.Ostatus = 0
	sc.ScoreType = lop.ScoreType
	if sc.ScoreType == "v3" {
		vectorN := models.VectorValue{}
		ok := vectorN.VctToVectorValue(lop.CvsVector)
		if ok {
			sc.NattackVector = vectorN.AttackVector
			sc.NattackComplexity = vectorN.AttackComplexity
			sc.NprivilegeRequired = vectorN.PrivilegesRequired
			sc.NuserInteraction = vectorN.UserInteraction
			sc.Nscope = vectorN.Scope
			sc.Nconfidentiality = vectorN.Confidentiality
			sc.Nintegrity = vectorN.Integrity
			sc.Navailability = vectorN.Availability
		}
		vectorO := models.VectorValue{}
		vectOk := vectorO.VctToVectorValue(lop.OpVector)
		if vectOk {
			sc.OattackVector = vectorO.AttackVector
			sc.OattackComplexity = vectorO.AttackComplexity
			sc.OprivilegeRequired = vectorO.PrivilegesRequired
			sc.OuserInteraction = vectorO.UserInteraction
			sc.Oscope = vectorO.Scope
			sc.Oconfidentiality = vectorO.Confidentiality
			sc.Ointegrity = vectorO.Integrity
			sc.Oavailability = vectorO.Availability
		}
	}
	if sc.ScoreType == "v2" {
		vectorN2 := models.VectorValueV2{}
		ok := vectorN2.VctToVectorValue(lop.CvsVector)
		if ok {
			sc.NaccessVector = vectorN2.AccessVector
			sc.NaccessComplexity = vectorN2.AccessComplexity
			sc.Navailability = vectorN2.Availability
			sc.Nconfidentiality = vectorN2.Confidentiality
			sc.Nintegrity = vectorN2.IntegrityImpact
			sc.Nauthentication = vectorN2.Authentication
		}
		vectorO2 := models.VectorValueV2{}
		vectOk := vectorO2.VctToVectorValue(lop.OpVector)
		if vectOk {
			sc.OaccessVector = vectorO2.AccessVector
			sc.OaccessComplexity = vectorO2.AccessComplexity
			sc.Oavailability = vectorO2.Availability
			sc.Oconfidentiality = vectorO2.Confidentiality
			sc.Ointegrity = vectorO2.IntegrityImpact
			sc.Oauthentication = vectorO2.Authentication
		}
	}
	var opensa models.OpenEulerSA
	var OpenNumData int
	//var os models.OpenSaId
	osx, opError := models.QueryOpenSaLastId()
	if opError == nil {
		OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
		OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
		if err == nil {
			OpenNum += 10
		} else {
			OpenNum = openeulernum
		}
		OpenNumData = OpenNum
	} else {
		OpenNumData = openeulernum
	}
	OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
	opensa.OpenEulerSANum = OpenEulerSANum
	var scorecode models.ScoreRecord
	scorecode.NVDScore = nVDScore
	scorecode.NvectorVule = lop.CvsVector
	scorecode.Status = 0
	cveid, cveError := models.CreateCveRelat(&vul, &sec, &sc, &opensa, &scorecode)
	if cveError != nil || cveid <= 0 {
		logs.Error("insert (&CveRes, &scoreRes,  &sec) failed CveNum:", cveData.CveNumber)
		return false, errors.New("数据插入失败, 暂时不处理")
	}
	vul.CveId = cveid
	cveCenter := models.VulnCenter{CveId: vul.CveId, CveNum: vul.CveNum, PackName: cveData.RepoPath}
	cveErr := models.GetVulnCenterByCid(&cveCenter, "cve_id", "cve_num", "pack_name")
	if cveErr != nil {
		logs.Error(cveErr)
	}
	var issueTemp models.IssueTemplate
	issueTemp.CveId = cveid
	issueTemp.CveNum = vul.CveNum
	issueTemp.CveNum = cveData.CveNumber
	issueTemp.OwnedComponent = lop.Components
	issueTemp.OwnedVersion = RemoveSubstring(lop.Version, specCharList)
	issueTemp.NVDScore = nVDScore
	issueTemp.OpenEulerScore = openEulerScore
	issueTemp.NVDVector = lop.CvsVector
	issueTemp.OpenEulerVector = lop.OpVector
	issueTemp.CveBrief = RemoveSubstring(lop.BriefIntroduction, specCharList)
	issueTemp.CveAnalysis = lop.Influences
	issueTemp.PrincipleAnalysis = lop.Principle
	issueTemp.AffectedVersion = lop.InfVersion
	issueTemp.AbiVersion = lop.AbiVersion
	issueTemp.Solution = lop.AvoidScheme
	issueTemp.IssueId = cveData.IssueId
	issueTemp.IssueNum = cveData.Number
	issueTemp.IssueLabel = beego.AppConfig.String("labelUnFix")
	issueTemp.StatusName = cveData.State
	issueTemp.Assignee = cveData.IssueAssignee
	UpdateIssueState(cveData.State, cveData.IssueState, &issueTemp, 3)
	if issueTemp.Status == 3 {
		vul.IsExport = 3
		cveCenter.IsExport = 3
	}
	issueTemp.Owner = owner
	issueTemp.Repo = cveData.RepoPath
	if cveData.Title != "" {
		issueTemp.Title = cveData.Title
	}
	update := models.UpdateVulnCenter(&cveCenter, "is_export")
	if !update {
		logs.Error("update vulnCenter fail ")
	}
	issueTemp.IssueType = CIssueType
	issueTemp.CveLevel = vul.CveLevel
	issueTemp.MtAuditFlag = 1
	issueTemp.SaAuditFlag = 1
	issTempId, issError := models.CreateIssueTemplate(&issueTemp)
	if issError != nil {
		logs.Error("Failed to create data for issue template, "+
			"cveNum: ", cveData.CveNumber, ",err: ", issError)
		return false, issError
	} else {
		logs.Info("The data of the issue template was successfully created, "+
			"issTempId: ", issTempId, ",cveNum: ", cveData.CveNumber)
	}
	hookError := CreateDepositHooks(accessToken, owner, cveData.RepoPath, vul, cveData.Number, cveData.IssueId)
	if hookError != nil {
		logs.Error(hookError)
	}
	return true, nil
}

func UpdateIssueCveGroups(cveData models.GiteOriginIssue, lop models.Loophole, cveRef string, openeulernum int,
	cveStatus int8, goe models.GitPackageInfo, vul models.VulnCenter, owner string) (bool, error) {
	//var vul models.VulnCenter
	if vul.CveNum == "" || len(vul.CveNum) < 1 {
		vul.CveNum = cveData.CveNumber
	}
	vul.Status = cveStatus
	specCharList := []string{"</br><br>", "\n", "\r", "\t"}
	briefIntroduction := RemoveSubstring(lop.BriefIntroduction, specCharList)
	if (vul.Description == "" || len(vul.Description) < 1) && len(briefIntroduction) > 1 {
		vul.Description = briefIntroduction
	}
	retVersion := AddCveVersion(cveData.OrganizationID, []string{},
		strings.Split(RemoveSubstring(lop.Version, specCharList), ","), []string{}, vul.CveVersion)
	vul.CveVersion = retVersion
	if vul.PackName == "" || len(vul.PackName) < 1 {
		vul.PackName = cveData.RepoPath
	}
	if vul.CveUrl == "" || len(vul.CveUrl) < 1 {
		vul.CveUrl = cveRef + cveData.CveNumber
	}
	vul.RepoName = lop.Components
	vul.OrganizationID = cveData.OrganizationID
	owner = beego.AppConfig.String("gitee::owner")
	accessToken := beego.AppConfig.String("gitee::git_token")
	if vul.OrganizationID == 3 {
		owner = beego.AppConfig.String("mindspore::mindspore_owner")
		accessToken = beego.AppConfig.String("mindspore::git_mindspore_token")
	} else if vul.OrganizationID == 2 {
		owner = beego.AppConfig.String("opengauss::gauss_owner")
		accessToken = beego.AppConfig.String("opengauss::git_gauss_token")
	}
	var sec models.SecurityNotice
	sec.CveId = vul.CveId
	sec.CveNum = vul.CveNum
	sec.InfluenceComponent = vul.PackName
	sec.Status = 0
	sec.AffectStatus = "Fixed"
	sec.Summary = vul.PackName + " security update"
	sec.Description = RemoveSubstring(goe.Decription, specCharList) + "\n\n" + "Security Fix(es):" + "\n\n" + vul.Description
	if sec.Description != "" && len(sec.Description) > 1 {
		sec.Description = deleteTailBlank(sec.Description) + "(" + vul.CveNum + ")"
	} else {
		sec.Description += "(" + vul.CveNum + ")"
	}
	sec.ReferenceLink = vul.CveUrl
	var issueTemps models.IssueTemplate
	issueTemps.CveId = vul.CveId
	issueTemps.CveNum = vul.CveNum
	models.GetIssueTemplateByColName(&issueTemps, "cve_id", "cve_num")
	opScoreLeve := ""
	opScore := float64(0)
	if issueTemps.OpenEulerScore > 0 {
		opScore = issueTemps.OpenEulerScore
		opScoreLeve = models.OpenEulerScoreProc(opScore)
	} else {
		opScore, opError := strconv.ParseFloat(lop.OpScore, 64)
		if opError != nil {
			opScoreLeve = "Critical"
		} else {
			opScoreLeve = models.OpenEulerScoreProc(opScore)
		}
	}
	if issueTemps.NVDVector != "" && len(issueTemps.NVDVector) > 1 {
		lop.CvsVector = issueTemps.NVDVector
	}
	if issueTemps.OpenEulerVector != "" && len(issueTemps.OpenEulerVector) > 1 {
		lop.OpVector = issueTemps.OpenEulerVector
	}
	vul.CveLevel = opScoreLeve
	affectBrands := ""
	if lop.InfVersion != "" && len(lop.InfVersion) > 2 {
		affectBrands = AddAffectBrands(lop.InfVersion)
	} else {
		if issueTemps.AffectedVersion != "" && len(issueTemps.AffectedVersion) > 1 {
			affectBrands = AddAffectBrands(issueTemps.AffectedVersion)
		}
	}
	sec.Introduction = "An update for " + vul.PackName + " is now available for " + affectBrands + "."
	sec.Theme = sec.Introduction[:len(sec.Introduction)-1] + ".\n\n" + "openEuler Security has rated this" +
		" update as having a security impact of " + strings.ToLower(opScoreLeve) + ". A Common Vunlnerability" +
		" Scoring System(CVSS)base score,which gives a detailed severity rating," +
		" is available for each vulnerability from the CVElink(s) in the References section."
	sec.AffectProduct = affectBrands
	nVDScore := 0.0
	if issueTemps.NVDScore > 0 {
		nVDScore = issueTemps.NVDScore
	}
	//var err error
	var score models.Score
	score.CveId = vul.CveId
	var scOk bool
	score, scOk = models.QueryScoreByCveId(vul.CveId)
	if !scOk || score.Id == 0 {
		//var sc models.Score
		score.CveNum = vul.CveNum
		var nvdError error
		if issueTemps.NVDScore > 0 {
			score.NVDScore = issueTemps.NVDScore
		} else {
			nVDScore, nvdError = strconv.ParseFloat(lop.CvsScore, 64)
			if nvdError == nil && nVDScore > 0 {
				score.NVDScore = nVDScore
			}
		}
		if issueTemps.OpenEulerScore > 0 {
			score.OpenEulerScore = issueTemps.OpenEulerScore
		} else {
			openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
			if openError == nil && openEulerScore > 0 {
				score.OpenEulerScore = openEulerScore
			}
		}
		score.NvectorVule = lop.CvsVector
		score.OvectorVule = lop.OpVector
		score.Nstatus = 0
		score.Ostatus = 0
		score.ScoreType = lop.ScoreType
		if score.ScoreType == "v3" {
			vectorN := models.VectorValue{}
			ok := vectorN.VctToVectorValue(lop.CvsVector)
			if ok {
				score.NattackVector = vectorN.AttackVector
				score.NattackComplexity = vectorN.AttackComplexity
				score.NprivilegeRequired = vectorN.PrivilegesRequired
				score.NuserInteraction = vectorN.UserInteraction
				score.Nscope = vectorN.Scope
				score.Nconfidentiality = vectorN.Confidentiality
				score.Nintegrity = vectorN.Integrity
				score.Navailability = vectorN.Availability
			}
			vectorO := models.VectorValue{}
			vectOk := vectorO.VctToVectorValue(lop.OpVector)
			if vectOk {
				score.OattackVector = vectorO.AttackVector
				score.OattackComplexity = vectorO.AttackComplexity
				score.OprivilegeRequired = vectorO.PrivilegesRequired
				score.OuserInteraction = vectorO.UserInteraction
				score.Oscope = vectorO.Scope
				score.Oconfidentiality = vectorO.Confidentiality
				score.Ointegrity = vectorO.Integrity
				score.Oavailability = vectorO.Availability
			}
		}
		if score.ScoreType == "v2" {
			vectorN2 := models.VectorValueV2{}
			ok := vectorN2.VctToVectorValue(lop.CvsVector)
			if ok {
				score.NaccessVector = vectorN2.AccessVector
				score.NaccessComplexity = vectorN2.AccessComplexity
				score.Navailability = vectorN2.Availability
				score.Nconfidentiality = vectorN2.Confidentiality
				score.Nintegrity = vectorN2.IntegrityImpact
				score.Nauthentication = vectorN2.Authentication
			}
			vectorO2 := models.VectorValueV2{}
			vectOk := vectorO2.VctToVectorValue(lop.OpVector)
			if vectOk {
				score.OaccessVector = vectorO2.AccessVector
				score.OaccessComplexity = vectorO2.AccessComplexity
				score.Oavailability = vectorO2.Availability
				score.Oconfidentiality = vectorO2.Confidentiality
				score.Ointegrity = vectorO2.IntegrityImpact
				score.Oauthentication = vectorO2.Authentication
			}
		}

	} else {
		v2 := score.NVDScore
		vul.CveLevel = models.OpenEulerScoreProc(v2)
		score.CveNum = vul.CveNum
		score.Nstatus = 2
		var nvdError error
		if issueTemps.NVDScore > 0 {
			score.NVDScore = issueTemps.NVDScore
			score.Nstatus = 3
		} else {
			nVDScore, nvdError = strconv.ParseFloat(lop.CvsScore, 64)
			if nvdError == nil && nVDScore > 0 {
				if score.NVDScore != nVDScore {
					score.Nstatus = 3
					score.NVDScore = nVDScore
				}
			}
		}
		if issueTemps.OpenEulerScore > 0 {
			score.OpenEulerScore = issueTemps.OpenEulerScore
			score.Ostatus = 3
		} else {
			openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
			if openError == nil && openEulerScore > 0 {
				score.OpenEulerScore = openEulerScore
				score.Ostatus = 3
			}
		}
		score.OvectorVule = lop.OpVector
		score.NvectorVule = lop.CvsVector
		score.ScoreType = lop.ScoreType
		if score.ScoreType == "v3" {
			vectorO := models.VectorValue{}
			okx := vectorO.VctToVectorValue(lop.OpVector)
			if okx {
				score.OattackVector = vectorO.AttackVector
				score.OattackComplexity = vectorO.AttackComplexity
				score.OprivilegeRequired = vectorO.PrivilegesRequired
				score.OuserInteraction = vectorO.UserInteraction
				score.Oscope = vectorO.Scope
				score.Oconfidentiality = vectorO.Confidentiality
				score.Ointegrity = vectorO.Integrity
				score.Oavailability = vectorO.Availability
			}
		}
		if score.ScoreType == "v2" {
			vectorO2 := models.VectorValueV2{}
			vectOk := vectorO2.VctToVectorValue(lop.OpVector)
			if vectOk {
				score.OaccessVector = vectorO2.AccessVector
				score.OaccessComplexity = vectorO2.AccessComplexity
				score.Oavailability = vectorO2.Availability
				score.Oconfidentiality = vectorO2.Confidentiality
				score.Ointegrity = vectorO2.IntegrityImpact
				score.Oauthentication = vectorO2.Authentication
			}
		}
	}
	if vul.Status == 0 || vul.Status == 1 || vul.Status == 3 {
		hookError := CreateDepositHooks(accessToken, owner, vul.PackName, vul, cveData.Number, cveData.IssueId)
		logs.Info(hookError)
	}
	if vul.Status == 3 {
		vul.Status = 2
	}
	if vul.Status == 4 {
		vul.Status = 1
	}
	osa, osaError := models.QueryOpenSaById(vul.CveId)
	if osaError == nil && osa.OpenId > 0 {
		sec.OpenId = osa.OpenId
		score.OpenId = osa.OpenId
	} else {
		var opensa models.OpenEulerSA
		var OpenNumData int
		//var os models.OpenSaId
		osx, opError := models.QueryOpenSaLastId()
		if opError == nil {
			OpenNumList := strings.Split(osx.OpenEulerSANum, "-")
			OpenNum, err := strconv.Atoi(OpenNumList[len(OpenNumList)-1])
			if err == nil {
				OpenNum += 1
			} else {
				OpenNum = openeulernum
			}
			OpenNumData = OpenNum
		} else {
			OpenNumData = openeulernum
		}
		OpenEulerSANum := "openEuler-SA-" + strconv.Itoa(time.Now().Year()) + "-" + strconv.Itoa(int(OpenNumData))
		opensa.OpenEulerSANum = OpenEulerSANum
		opensa.CveId = vul.CveId
		openId, openError := models.CreateOpenEulerSA(&opensa)
		if openError != nil && openId == 0 {
			logs.Error("生成openSA失败，openSA: ", opensa, ", error: ", openError)
			return false, errors.New("数据插入失败, 暂时不处理")
		}
		sec.OpenId = openId
		score.OpenId = openId
	}
	cveError := models.UpdateCveRelat(&vul, &sec, &score)
	if cveError != nil || vul.CveId == 0 {
		logs.Error("UpdateCveRelat(&vul, &sec, &sc) failed CveNum:", cveData.CveNumber, ",err:", cveError)
		return false, errors.New("数据插入失败, 暂时不处理")
	}
	if scOk || score.Id > 0 {
		if score.NVDScore != nVDScore {
			var scorecode models.ScoreRecord
			scorecode.NVDScore = score.NVDScore
			scorecode.NvectorVule = score.NvectorVule
			scorecode.Status = 0
			scorecode.CveId = vul.CveId
			scRecordId, scError := models.InsertScoreRecord(&scorecode)
			logs.Info(scRecordId, scError)
		}
	}
	cveCenter := models.VulnCenter{CveId: vul.CveId, CveNum: vul.CveNum, PackName: cveData.RepoPath}
	cveErr := models.GetVulnCenterByCid(&cveCenter, "cve_id", "cve_num", "pack_name")
	if cveErr != nil {
		logs.Error(cveErr)
	}
	tmpNVDScore := float64(0)
	tmpNvdError := error(nil)
	if len(lop.CvsScore) > 0 {
		tmpNVDScore, tmpNvdError = strconv.ParseFloat(lop.CvsScore, 64)
		if tmpNvdError != nil {
			logs.Error("tmpNvdError: ", tmpNvdError)
		}
	}
	var issueTemp models.IssueTemplate
	issueTemp.CveId = vul.CveId
	issueTemp.CveNum = vul.CveNum
	templateErr := models.GetIssueTemplateByColName(&issueTemp, "cve_id", "cve_num")
	if templateErr == nil && issueTemp.TemplateId > 0 {
		//issueTemp.CveNum = cveData.CveNumber
		if len(issueTemp.OwnedComponent) < 2 {
			issueTemp.OwnedComponent = lop.Components
		}
		if (len(briefIntroduction) < 2 || tmpNVDScore <= 0 || len(lop.CvsVector) < 1) && issueTemp.Status < 3 &&
			cveData.IssueState != "已拒绝" && cveData.IssueState != "已挂起" {
			cveCenter.Status = 1
		}
		//issueTemp.OwnedVersion = RemoveSubstring(lop.Version, specCharList)
		openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
		if openError == nil && openEulerScore > 0 && issueTemp.OpenEulerScore == 0 {
			issueTemp.OpenEulerScore = openEulerScore
		}
		if issueTemp.NVDVector == "" || len(issueTemp.NVDVector) < 1 {
			issueTemp.NVDVector = lop.CvsVector
		}
		nvdScore, nvdError := strconv.ParseFloat(lop.CvsScore, 64)
		if nvdError == nil && nvdScore > 0 && issueTemp.NVDScore == 0 {
			issueTemp.NVDScore = nvdScore
		}
		if lop.OpVector != "" && len(lop.OpVector) > 1 || len(issueTemp.OpenEulerVector) < 2 {
			issueTemp.OpenEulerVector = lop.OpVector
		}
		if issueTemp.CveBrief == "" || len(issueTemp.CveBrief) < 2 {
			issueTemp.CveBrief = RemoveSubstring(lop.BriefIntroduction, specCharList)
		}
		if lop.Influences != "" && len(lop.Influences) > 1 && len(issueTemp.CveAnalysis) < 2 {
			issueTemp.CveAnalysis = lop.Influences
		}
		issueTemp.PrincipleAnalysis = lop.Principle
		if paraAffectBrandBool(lop.InfVersion) {
			issueTemp.AffectedVersion = lop.InfVersion
		}
		if ParaAffectAbiBool(lop.AbiVersion) {
			issueTemp.AbiVersion = lop.AbiVersion
		}
		issueTemp.Solution = lop.AvoidScheme
		statusName := issueTemp.StatusName
		issueTemp.Repo = cveData.RepoPath
		if issueTemp.IssueId != cveData.IssueId || issueTemp.IssueNum != cveData.Number {
			tmpIssueErr, tmpIssueBody := GetGiteeIssue(accessToken, owner, vul.PackName, issueTemp.IssueNum)
			cveIssueErr, cveIssueBody := GetGiteeIssue(accessToken, owner, vul.PackName, cveData.Number)
			if tmpIssueErr == nil && cveIssueErr == nil {
				logs.Info("GetGiteeIssue, Issue has been created,issueBody:", tmpIssueBody, cveIssueBody)
				if issueTemp.Status > 3 {
					issueTemp.IssueId = cveData.IssueId
					issueTemp.IssueNum = cveData.Number
					issueTemp.StatusName = cveData.State
					statusName = cveData.State
					issueTemp.Assignee = cveData.IssueAssignee
				}
			} else if tmpIssueErr == nil && cveIssueErr != nil {
				logs.Info("The data does not change", issueTemp.IssueNum)
			} else if tmpIssueErr != nil && cveIssueErr == nil {
				issueTemp.IssueId = cveData.IssueId
				issueTemp.IssueNum = cveData.Number
				issueTemp.StatusName = cveData.State
				statusName = cveData.State
				issueTemp.Assignee = cveData.IssueAssignee
			}
		} else {
			issueTemp.StatusName = cveData.State
			statusName = cveData.State
		}
		UpdateIssueState(statusName, cveData.IssueState, &issueTemp, 1)
		issueTemp.Owner = owner
		if cveData.Title != "" {
			issueTemp.Title = cveData.Title
		}
		issueTemp.IssueType = CIssueType
		issueTemp.CveLevel = vul.CveLevel
	} else {
		issueTemp.CveNum = cveData.CveNumber
		issueTemp.OwnedComponent = lop.Components
		issueTemp.Repo = cveData.RepoPath
		issueTemp.Owner = owner
		issueTemp.OwnedVersion = RemoveSubstring(lop.Version, specCharList)
		issueTemp.NVDScore = nVDScore
		openEulerScore, openError := strconv.ParseFloat(lop.OpScore, 64)
		if openError == nil {
			issueTemp.OpenEulerScore = openEulerScore
		}
		issueTemp.NVDVector = lop.CvsVector
		nvdScore, nvdError := strconv.ParseFloat(lop.CvsScore, 64)
		if nvdError == nil {
			issueTemp.NVDScore = nvdScore
		}
		if len(briefIntroduction) < 2 || tmpNVDScore <= 0 || len(lop.CvsVector) < 1 &&
			cveData.IssueState != "已拒绝" && cveData.IssueState != "已挂起" {
			cveCenter.Status = 1
		}
		issueTemp.NVDVector = lop.CvsVector
		issueTemp.OpenEulerVector = lop.OpVector
		issueTemp.CveBrief = RemoveSubstring(lop.BriefIntroduction, specCharList)
		issueTemp.CveAnalysis = RemoveSubstring(lop.Influences, specCharList)
		issueTemp.PrincipleAnalysis = lop.Principle
		issueTemp.AffectedVersion = lop.InfVersion
		issueTemp.AbiVersion = lop.AbiVersion
		issueTemp.Solution = lop.AvoidScheme
		issueTemp.IssueId = cveData.IssueId
		issueTemp.IssueNum = cveData.Number
		issueTemp.StatusName = cveData.State
		issueTemp.IssueLabel = beego.AppConfig.String("labelUnFix")
		issueTemp.Assignee = cveData.IssueAssignee
		UpdateIssueState(cveData.State, cveData.IssueState, &issueTemp, 2)
		if cveData.Title != "" {
			issueTemp.Title = cveData.Title
		}
		issueTemp.IssueType = CIssueType
		issueTemp.CveLevel = vul.CveLevel
	}
	if issueTemp.Status == 3 {
		cveCenter.IsExport = 3
	}
	update := models.UpdateVulnCenter(&cveCenter, "is_export", "cve_status")
	if !update {
		logs.Error("update vulnCenter fail ")
	}
	// Store issue data
	issTempId, issError := models.CreateIssueTemplate(&issueTemp)
	if issError != nil {
		logs.Error("Failed to create data for issue template, "+
			"cveNum: ", cveData.CveNumber, ",err: ", issError)
		return false, issError
	} else {
		logs.Info("The data of the issue template was successfully created, "+
			"issTempId: ", issTempId, ",cveNum: ", cveData.CveNumber)
	}
	return true, nil
}

func UpdateIssueState(statusName, issueState string, issueTemp *models.IssueTemplate, flag int) {
	if (strings.ToLower(statusName) == "open" || statusName == "待办的" || statusName == "开启的" ||
		issueState == "待办的" || issueState == "新建") && issueState != "已挂起" {
		issueTemp.Status = 1
		issueTemp.IssueStatus = 1
		issueTemp.StatusName = "open"
	} else if strings.ToLower(statusName) == "progressing" ||
		strings.ToLower(statusName) == "started" || statusName == "进行中" || issueState == "进行中" {
		issueTemp.Status = 2
		issueTemp.IssueStatus = 3
		issueTemp.StatusName = "progressing"
	} else if strings.ToLower(statusName) == "closed" || statusName == "已完成" || issueState == "已完成" {
		issueTemp.Status = 3
		issueTemp.IssueStatus = 2
		issueTemp.MtAuditFlag = 1
		if flag == 2 {
			issueTemp.IssueLabel = beego.AppConfig.String("labelFixed")
			issueTemp.MtAuditFlag = 1
			issueTemp.SaAuditFlag = 1
		}
		if flag == 3 {
			issueTemp.IssueLabel = beego.AppConfig.String("labelFixed")
		}
	} else if strings.ToLower(statusName) == "rejected" || statusName == "已拒绝" ||
		issueState == "已拒绝" || issueState == "已取消" {
		issueTemp.Status = 4
		issueTemp.IssueStatus = 6
		if flag == 2 {
			issueTemp.IssueLabel = beego.AppConfig.String("labeUnaffected")
			issueTemp.MtAuditFlag = 1
			issueTemp.SaAuditFlag = 1
		}
		if flag == 3 {
			issueTemp.IssueLabel = beego.AppConfig.String("labeUnaffected")
		}
	} else if strings.ToLower(statusName) == "suspended" || statusName == "已挂起" || issueState == "已挂起" {
		issueTemp.Status = 5
		issueTemp.IssueStatus = 6
		if flag == 2 || flag == 3 {
			issueTemp.IssueLabel = beego.AppConfig.String("labeUnaffected")
		}
	} else {
		issueTemp.Status = 4
		issueTemp.IssueStatus = 6
	}
}

func paraAffectBrandBool(affectedVersion string) bool {
	unaffectedBranchList := []string{}
	brandsGroup := strings.Split(affectedVersion, ",")
	if len(brandsGroup) > 0 {
		for _, brand := range brandsGroup {
			if brand == "" || len(brand) < 2 {
				continue
			}
			brand = common.BranchVersionRep(brand)
			brandList := strings.Split(brand, ":")
			if len(brandList) > 1 {
				prams := strings.Replace(brandList[1], " ", "", -1)
				if prams == "受影响" || prams == "不受影响" {
					unaffectedBranchList = append(unaffectedBranchList, brandList[0])
				}
			} else {
				brandList = strings.Split(brand, "：")
				if len(brandList) > 1 {
					prams := strings.Replace(brandList[1], " ", "", -1)
					if prams == "受影响" || prams == "不受影响" {
						unaffectedBranchList = append(unaffectedBranchList, brandList[0])
					}
				}
			}
		}
	}
	if len(unaffectedBranchList) > 0 {
		return true
	}
	return false
}

func ParaAffectAbiBool(abiVersion string) bool {
	unaffectedBranchList := make([]string, 0)
	brandsGroup := strings.Split(abiVersion, ",")
	if len(brandsGroup) > 0 {
		for _, brand := range brandsGroup {
			if brand == "" || len(brand) < 2 {
				continue
			}
			brand = common.BranchVersionRep(brand)
			brandList := strings.Split(brand, ":")
			if len(brandList) > 1 {
				prams := strings.Replace(brandList[1], " ", "", -1)
				if prams == "是" || prams == "否" {
					unaffectedBranchList = append(unaffectedBranchList, brandList[0])
				}
			} else {
				brandList = strings.Split(brand, "：")
				if len(brandList) > 1 {
					prams := strings.Replace(brandList[1], " ", "", -1)
					if prams == "是" || prams == "否" {
						unaffectedBranchList = append(unaffectedBranchList, brandList[0])
					}
				}
			}
		}
	}
	if len(unaffectedBranchList) > 0 {
		return true
	}
	return false
}

func GenCveVulerByIssue(cveData models.GiteOriginIssue, cveRef string, openeulernum int, owner string, openFlag int8) (bool, error) {
	defer common.Catchs()
	lock.Lock()
	hole, err := cveData.ParseToLoophole()
	lock.Unlock()
	organizationID := cveData.OrganizationID
	if err != nil {
		logs.Error("Data parsing error, err: ", err, ", cveData: ", cveData)
		models.UpdateCveIssueStatusById(3, cveData.Id)
		return false, err
	}
	goe := models.GitPackageInfo{}
	if organizationID == 1 {
		goe, _ = models.QueryCveOpeneulerDetaildataByName(cveData.RepoPath, hole.Version)
		if goe.DetailId == 0 {
			logs.Error("Failed to get data, ", "Components: ", hole.Components, ",Version: ", hole.Version)
		}
	} else {
		goe, _ = models.QueryCveOpeneulerDetaildataByName(hole.Components, hole.Version)
		if goe.DetailId == 0 {
			logs.Error("Failed to get data, ", "Components: ", hole.Components, ",Version: ", hole.Version)
		}
	}
	if len(goe.Version) > 0 {
		hole.Version = goe.Version
	}
	if cveData.State != "" && (strings.ToLower(cveData.State) == "rejected" ||
		cveData.State == "已拒绝" || cveData.IssueState == "已拒绝" || cveData.IssueState == "已挂起") {
		logs.Info("Process data whose issue status is rejected：", cveData)
		cvd, ok := models.QueryCveByNum(cveData.CveNumber, cveData.RepoPath, organizationID)
		if ok && cvd.CveNum != "" {
			lock.Lock()
			upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, cvd, owner)
			logs.Info(upOk, upError)
			lock.Unlock()
		} else {
			lock.Lock()
			okx, errx := InsertIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, owner)
			lock.Unlock()
			if !okx {
				logs.Error("Failed to get data, InsertIssueCveGroups， err: ", errx)
				return false, err
			}
		}
		models.UpdateCveStatusExportByNum(common.GetCurTime(), cveData.CveNumber, 2, cveData.RepoPath, hole.Version)
		models.UpdateCveIssueStatusById(2, cveData.Id)
		return true, nil
	} else if cveData.State != "" && (strings.ToLower(cveData.State) == "closed" || cveData.State == "已完成") {
		logs.Info("Process data whose issue status is closed：", cveData)
		cvd, ok := models.QueryCveByNum(cveData.CveNumber, cveData.RepoPath, organizationID)
		if ok && cvd.CveNum != "" {
			lock.Lock()
			upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, cvd, owner)
			logs.Info(upOk, upError)
			lock.Unlock()
		} else {
			lock.Lock()
			okx, errx := InsertIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, owner)
			lock.Unlock()
			if !okx {
				logs.Error("Failed to get data, InsertIssueCveGroups， err: ", errx)
				return false, err
			}
		}
		models.UpdateCveStatusExportByNum(common.GetCurTime(), cveData.CveNumber, 3, cveData.RepoPath, hole.Version)
		models.UpdateCveIssueStatusById(2, cveData.Id)
		return true, nil
	} else {
		logs.Info("Process data whose issue status is open and processing：", cveData)
		cvd, ok := models.QueryCveByNum(cveData.CveNumber, cveData.RepoPath, organizationID)
		if ok && len(cvd.CveNum) > 1 {
			if openFlag == 1 {
				lock.Lock()
				upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 1, goe, cvd, owner)
				lock.Unlock()
				logs.Info(upOk, upError)
			} else {
				if cvd.Status == 0 {
					if strings.ToLower(cveData.State) == "open" || cveData.State == "待办的" ||
						strings.ToLower(cveData.State) == "progressing" || cveData.State == "进行中" ||
						strings.ToLower(cveData.State) == "started" || cveData.State == "开启的" {
						lock.Lock()
						upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 1, goe, cvd, owner)
						lock.Unlock()
						logs.Info(upOk, upError)
					} else {
						lock.Lock()
						upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 3, goe, cvd, owner)
						lock.Unlock()
						logs.Info(upOk, upError)
					}
				} else if cvd.Status == 1 {
					if strings.ToLower(cveData.State) == "open" || cveData.State == "待办的" ||
						strings.ToLower(cveData.State) == "progressing" || cveData.State == "进行中" ||
						strings.ToLower(cveData.State) == "started" || cveData.State == "开启的" {
						lock.Lock()
						upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 4, goe, cvd, owner)
						lock.Unlock()
						logs.Info(upOk, upError)
					} else {
						lock.Lock()
						upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, cvd, owner)
						lock.Unlock()
						logs.Info(upOk, upError)
					}
				} else {
					lock.Lock()
					upOk, upError := UpdateIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, cvd, owner)
					lock.Unlock()
					logs.Info(upOk, upError)
				}
			}
		} else {
			if strings.ToLower(cveData.State) == "open" || cveData.State == "待办的" ||
				strings.ToLower(cveData.State) == "progressing" || cveData.State == "进行中" ||
				strings.ToLower(cveData.State) == "started" || cveData.State == "开启的" {
				lock.Lock()
				okx, errx := InsertIssueCveGroups(cveData, hole, cveRef, openeulernum, 1, goe, owner)
				lock.Unlock()
				if !okx {
					logs.Error("Failed to get data, InsertIssueCveGroups， err: ", errx)
					return false, err
				}
			} else {
				lock.Lock()
				okx, errx := InsertIssueCveGroups(cveData, hole, cveRef, openeulernum, 2, goe, owner)
				lock.Unlock()
				if !okx {
					logs.Error("Failed to get data, InsertIssueCveGroups， err: ", errx)
					return false, err
				}
			}
		}
		models.UpdateCveIssueStatusById(2, cveData.Id)
		return true, nil
	}
}

func ProcAffectData(ite models.IssueTemplate) {
	affectVerList := strings.Split(ite.AffectedVersion, ",")
	if len(affectVerList) > 0 {
		affectBranch := make([]string, 0)
		affectMap := make(map[string]string)
		for _, avl := range affectVerList {
			affectList := make([]string, 0)
			if strings.Index(avl, ":") != -1 {
				affectList = strings.Split(avl, ":")
			} else {
				affectList = strings.Split(avl, "：")
			}
			if len(affectList) > 0 {
				if _, ok := common.FindSliceEm(affectBranch, affectList[0]); !ok {
					affectBranch = append(affectBranch, affectList[0])
				}
			}
			if len(affectMap) > 0 {
				if len(affectList) > 1 {
					if av, ok := affectMap[affectList[0]]; ok {
						if len(av) >= len(affectList[1]) {
							continue
						} else {
							affectMap[affectList[0]] = affectList[1]
						}
					} else {
						affectMap[affectList[0]] = affectList[1]
					}
				} else if len(affectList) == 1 {
					if _, ok := affectMap[affectList[0]]; ok {
						continue
					} else {
						affectMap[affectList[0]] = ""
					}
				}
			} else {
				if len(affectList) > 1 {
					affectMap[affectList[0]] = affectList[1]
				} else {
					if len(affectList) == 1 {
						affectMap[affectList[0]] = ""
					}
				}
			}
		}
		if len(affectBranch) > 0 {
			affectSlice := make([]string, 0)
			for _, af := range affectBranch {
				if av, ok := affectMap[af]; ok {
					if len(av) > 1 {
						affectSlice = append(affectSlice, af+":"+av)
					} else {
						affectSlice = append(affectSlice, af+":")
					}
				}
			}
			if len(affectSlice) > 0 {
				ite.AffectedVersion = strings.Join(affectSlice, ",")
				models.UpdateIssueTemplate(&ite, "AffectedVersion")
			}
		}
	}
}

func ProcIssueTemplateBranch(duplicationDate int) {
	defer common.Catchs()
	beforeTime := common.GetBeforeTime(duplicationDate)
	tmplateId := int64(0)
	for {
		iteList, num, err := models.QueryIssueTemplateAll(100, tmplateId, beforeTime)
		if len(iteList) > 0 {
			for _, ite := range iteList {
				tmplateId = ite.TemplateId
				if len(ite.AffectedVersion) > 1 {
					ProcAffectData(ite)
				}
			}
		} else {
			logs.Error("num: ", num, ",err: ", err)
			break
		}
	}
}

func GetCveIssueData(prcnum, days, openeulernum int, cveRef, owner string, openFlag int8) (bool, error) {
	defer common.Catchs()
	count := 0
	for {
		gs, num, err := models.QueryOriginCveIssue(prcnum)
		if num == 0 {
			logs.Info("There is currently no cveissue raw data processing, err: ", err,
				", curtime: ", common.GetCurTime())
			break
		}
		ch := make(chan int, len(gs))
		for i, cveOrg := range gs {
			count = count + 1
			logs.Info("The current normal analysis: ", count, " Article data,i:", i, ", cvenum: ", cveOrg.IssueId)
			// add mutex
			lockOk := models.LockUpdateCveIssueStatus(15, cveOrg.Id)
			if !lockOk {
				logs.Error("Data is being processed, id: ", cveOrg.Id, ",cveOrg: ", cveOrg)
				ch <- i
				continue
			}
			if cveOrg.CveNumber == "" || len(cveOrg.CveNumber) == 0 {
				logs.Error("Data is abnormal, do not handle, cveData: ", cveOrg)
				models.UpdateCveIssueStatusById(3, cveOrg.Id)
				ch <- i
				continue
			}
			go func(idx, openeulernum int, cveData models.GiteOriginIssue, locCveRef, locOwner string, openFlag int8) {
				ok, err := GenCveVulerByIssue(cveData, locCveRef, openeulernum, locOwner, openFlag)
				if !ok {
					logs.Error("GenCveVulerByIssue, cveData: ", cveData, "Processing failed, err: ", err)
					models.UpdateCveIssueStatusById(3, cveData.Id)
				}
				ch <- idx
			}(i, openeulernum, cveOrg, cveRef, owner, openFlag)
		}
		for i := 0; i < cap(ch); i++ {
			<-ch
		}
		close(ch)
	}
	return true, nil
}

//GetSecurityNotice Go to the CVE official website to obtain the cve data to determine
//whether the cve issue needs to be exported.
func GetCveSecurityNotice(cveNumber string) (bool, models.RespCveDetail) {
	var detail models.RespCveDetail
	var urlS url.URL
	q := urlS.Query()
	q.Add("cveId", cveNumber)
	params := q.Encode()
	secLinkConfig := beego.AppConfig.String("reflink::openeuler_web")
	req, _ := http.NewRequest("GET", secLinkConfig, nil)
	req.URL = &url.URL{
		Scheme:   req.URL.Scheme,
		Host:     req.URL.Host,
		RawQuery: params,
		Path:     "/api-cve/cve-security-notice-server/cvedatabase/getByCveId",
	}
	req.URL.EscapedPath()
	resp, err := http.Get(req.URL.String())
	if err != nil {
		logs.Error("Get, url: ", req.URL.String(), err)
		return false, detail
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil || body == nil {
		logs.Error("ReadAll, url: ", req.URL.String(), err)
		return false, detail
	}
	logs.Info("body: ", string(body))
	err = json.Unmarshal(body, &detail)
	if err != nil {
		logs.Error("Unmarshal, url: ", req.URL.String(), err)
		return false, detail
	}
	if detail.Result != nil && detail.Result.Id > 0 {
		return true, detail
	}
	return false, detail
}

//FilterCveExported Filter exportable data
func FilterCveExported() {
	logs.Info("Start by removing cve data that has already released SA...")
	data, err := models.GetCanExportVulnCenterData()
	if err != nil {
		logs.Error(err)
		return
	}
	for _, v := range data {
		go func(center models.VulnCenter) {
			ewg.Add(1)
			defer ewg.Done()
			issueExist, _ := GetCveSecurityNotice(center.CveNum)
			if issueExist {
				dbLock.Lock()
				center.IsExport = 1
				models.UpdateVulnCenter(&center, "is_export")
				dbLock.Unlock()
			} else {
				if center.IsExport == 2 {
					dbLock.Lock()
					center.IsExport = 3
					models.UpdateVulnCenter(&center, "is_export")
					dbLock.Unlock()
				}
			}
		}(v)
	}
	ewg.Wait()
	logs.Info("Excluding the cve data that has been released SA ends...")
}

func GenerateExcelTask() error {
	FilterCveExported()
	return nil
}

//GenerateExcelTrigger generate cve&security notice excel file by pr merge and influence package release.
func GenerateExcelTrigger(wgCrvf *sync.WaitGroup, fileName, startTime, fileCode, affectBranch,
	csvDownPath, dir string, cvrfFileList map[string][]string,
	componentMap map[string]ComponentInfo, cvfrFileMap map[string]CvrfSa) UpdateInfoXml {
	defer wgCrvf.Done()
	logs.Info(affectBranch, ", GenerateExcelTrigger start...")
	var updateInfoXml UpdateInfoXml
	xmlFileName := beego.AppConfig.String("xml::updateinfo_path")
	xmfilePath := filepath.Join(dir, affectBranch+"_"+xmlFileName)
	var cvexml []CveXml
	var dpdates Updates
	securityNotice := make(map[string][]SecurityNoticeXml)
	packRpmx := make(map[string][]PackRpm)
	ReadXml(xmfilePath, &dpdates)
	fileName = filepath.Join(dir, fileName)
	localPath := filepath.Join(dir, affectBranch+"_release-package.CSV")
	err := downloadPackageFile(localPath, csvDownPath, affectBranch)
	if err != nil {
		logs.Error(err)
		return updateInfoXml
	}
	pkgList, err := ExtractPackageData(localPath)
	if err != nil {
		logs.Error(err)
	} else {
		su := time.Now().Format("2006-01-02")
		snPrefix := "openEuler-" + su
		snSuffix := int64(1001)
		err = GenerateCveExcelByTrigger(affectBranch, fileName, snPrefix, startTime,
			snSuffix, true, pkgList, cvrfFileList,
			componentMap, cvfrFileMap, &cvexml, &dpdates,
			securityNotice, packRpmx)
		if err != nil {
			logs.Error(err)
		}
	}
	updateInfoXml = UpdateInfoXml{XmfilePath: xmfilePath, Cvexml: cvexml, Dpdates: &dpdates,
		SecurityNotice: securityNotice, PackRpmx: packRpmx, FileName: fileName, AffectBranch: affectBranch}
	logs.Info(affectBranch, ", GenerateExcelTrigger: end")
	return updateInfoXml
}

func downloadPackageFile(localPath, url, affectBranch string) error {
	logs.Info("The csv file currently being downloaded is: ", url)
	pkgLock.Lock()
	err := GiteeDownCsv(localPath, affectBranch)
	pkgLock.Unlock()
	return err
}

func GiteeDownCsv(localPath, branch string) (error) {
	accessToken := os.Getenv("GITEE_TOKEN")
	owner := "unsunghero"
	repo := "obs_pkg_rpms"
	path := fmt.Sprintf("latest_rpm/%v.csv", branch)
	gitUrl := fmt.Sprintf("https://gitee.com/api/v5/repos/%v/%v/contents/%v?access_token=%v",
		owner, repo, path, accessToken)
	resp, err := http.Get(gitUrl)
	if err != nil {
		logs.Error("get error, url:", gitUrl, "error: ", err)
		return err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil || body == nil {
		logs.Error(err)
		return err
	}
	//logs.Info("body: \n", string(body), "url: ", gitUrl)
	var contents map[string]interface{}
	err = json.Unmarshal(body, &contents)
	if err != nil {
		logs.Error(err)
		return err
	}
	f, ferr := os.Create(localPath)
	if ferr != nil {
		logs.Error(ferr)
		return ferr
	}
	fileType := contents["type"].(string)
	encoding := contents["encoding"].(string)
	content := contents["content"].(string)
	if fileType == "file" && encoding == "base64" {
		data, baseErr := base64.StdEncoding.DecodeString(content)
		if baseErr == nil {
			f.Write(data)
		}
	} else {
		f.WriteString(content)
	}
	return nil
}
