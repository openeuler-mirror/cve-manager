package tabletask

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"

	"cvevulner/common"
	"cvevulner/cve-timed-task/db_models"
	"cvevulner/cve-timed-task/util"
	"cvevulner/models"

	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"github.com/astaxie/beego/orm"
)

// DownloadGuessYaml Download the yaml file of openGauss on Gitee
func DownloadMindSporeYaml() (string, error) {
	filePath := beego.AppConfig.String("timedtask::packageDir") + "mindspore_yaml/"
	err := util.MakeDir(filePath)
	if err != nil {
		return "", err
	}
	yamlFileName := filePath + "mindspore_yaml.yaml"
	//download the yaml file
	downloadUrl := "https://gitee.com/mindspore/community/raw/master/security/config/Third_Party_Open_Source_Software_List.yaml"
	resp, dErr := http.Get(downloadUrl)
	defer resp.Body.Close()
	if dErr != nil {
		logs.Error("get", downloadUrl, "error: ", dErr.Error())
		return "", dErr
	}
	if resp.StatusCode != http.StatusOK {
		logs.Error("get", downloadUrl, resp.Status)
		return "", errors.New(resp.Status)
	}
	saveFile, cErr := os.Create(yamlFileName)
	defer saveFile.Close()
	if cErr != nil {
		logs.Error("Create file error: ", yamlFileName, cErr.Error())
		return "", cErr
	}
	_, cErr = io.Copy(saveFile, resp.Body)
	if cErr != nil {
		logs.Error("copy resp.Body to file error", yamlFileName, cErr.Error())
		return "", cErr
	}
	return yamlFileName, nil
}

// StoreOpenLookengYaml parse dict
//Store yaml data to mysql
func StoreMindSporeYaml(yamlData map[string]map[string]map[string]string, ormModel orm.Ormer) {
	if len(yamlData) > 0 {
		err := db_models.UpdateMindYamlOriginMark(ormModel)
		if err != nil {
			logs.Error("db_models.UpdateYamlOriginMarkLookeng:", err.Error())
			return
		}
		owner, token := common.GetOwnerAndToken("", 3)
		for RepoKey, RepoValue := range yamlData {
			for k, v := range RepoValue {
				milestones, _ := getMilestone(owner, token, RepoKey)
				mile := 0
				if _, ok := v["version"]; !ok || v["version"] == "" {
					v["version"] = ""
				}
				if _, ok := v["handler"]; !ok || v["handler"] == "" {
					v["handler"] = ""
				}
				if _, ok := v["milestone"]; !ok || v["milestone"] == "" {
					v["milestone"] = ""
				}
				for _, milestone := range milestones {
					if strings.EqualFold(milestone.Title, v["milestone"]) {
						mile = milestone.Id
						break
					}
				}
				//open transaction
				logs.Info("open transaction")
				tranErr := ormModel.Begin()
				if tranErr != nil {
					logs.Error(" Open transaction error:", tranErr.Error())
					continue
				}
				if len(v["handler"]) > 0 {
					srer, _ := db_models.SelectMindSporeSecurityReviewer(v["handler"], ormModel)
					if srer.Id < 1 {
						msr := models.Reviewer{NameSpace: v["handler"], Status: 0, OrganizationID: 3}
						err = db_models.InsertMindSporeSecurityReviewer(&msr, ormModel)
						if err != nil {
							logs.Error("db_models.InsertMindSporeSecurityReviewer error:", err.Error())
							tranErr = ormModel.Rollback()
							if tranErr != nil {
								logs.Error(" Rollback transaction error:", tranErr.Error())
							}
							continue
						}
					}
				}
				originData, sErr := db_models.SelectMindYamlOriginData(k, v["version"], RepoKey, ormModel)
				now := time.Now()
				if sErr != nil {
					if errors.Is(orm.ErrNoRows, sErr) {
						logs.Warn("error is orm.ErrNoRows, Create a record")
						mindSporeYaml := &models.MindSporeYaml{
							PackageName: k,
							Version:     v["version"],
							OriginUrl:   v["url"],
							Status:      1,
							CpeName:     v["cpeName"],
							CreateTime:  now.Format("2006-01-02 15:04:05"),
							UpdateTime:  now.Format("2006-01-02 15:04:05"),
							MarkBit:     1,
							Repo:        RepoKey,
							Owner:       v["handler"],
							Milestone:   mile,
						}
						sErr = db_models.InsertMindYamlOriginData(mindSporeYaml, ormModel)
						if sErr != nil {
							logs.Error("db_models.InsertMindYamlOriginData error:", sErr.Error())
							tranErr = ormModel.Rollback()
							if tranErr != nil {
								logs.Error(" Rollback transaction error:", tranErr.Error())
							}
							continue
						}
						logs.Info("insert MindSporeYaml success")
					} else {
						logs.Error("db_models.SelectMindYamlOriginData error:", sErr)
						tranErr = ormModel.Rollback()
						if tranErr != nil {
							logs.Error(" Rollback transaction error:", tranErr.Error())
						}
						continue
					}
				} else {
					logs.Info("database records, change the data")
					mindSporeYaml := &models.MindSporeYaml{
						Id:         originData.Id,
						OriginUrl:  v["url"],
						Status:     1,
						CpeName:    v["cpeName"],
						UpdateTime: now.Format("2006-01-02 15:04:05"),
						MarkBit:    1,
						Owner:      v["handler"],
						Milestone:  mile,
					}
					_, sErr = db_models.UpdateMindYamlOriginData(mindSporeYaml, ormModel)
					if sErr != nil {
						logs.Error("db_models.UpdateMindYamlOriginData:", sErr.Error())
						tranErr = ormModel.Rollback()
						if tranErr != nil {
							logs.Error(" Rollback transaction error:", tranErr.Error())
						}
						continue
					}
				}
				packAgesData, rowsAffected, yErr := db_models.SelectYamlData(k, v["version"], ormModel)
				if yErr != nil {
					logs.Error("db_models.SelectMindYamlData error:", yErr)
					tranErr = ormModel.Rollback()
					if tranErr != nil {
						logs.Error(" Rollback transaction error:", yErr.Error())
					}
					continue
				}
				if rowsAffected == 0 {
					logs.Warn("No record found, Create a record")
					var packId int64
					gitOpenEuler, dErr := db_models.SelectYamlLastData(ormModel)
					if dErr != nil {
						if errors.Is(orm.ErrNoRows, dErr) {
							packId = 10000000
						} else {
							logs.Error("db_models.SelectYamlLastData error:", dErr)
							tranErr = ormModel.Rollback()
							if tranErr != nil {
								logs.Error(" Rollback transaction error:", tranErr.Error())
							}
							continue
						}
					} else {
						if gitOpenEuler.PackageId >= 10000000 {
							packId = gitOpenEuler.PackageId + 1
						} else {
							packId = 10000000
						}
					}
					goe := &models.GitOpenEuler{
						PackageId:   packId,
						PackageName: k,
						Version:     v["version"],
						OriginUrl:   v["url"],
						CreateTime:  now,
						UpdateTime:  now,
						CpePackName: v["cpeName"],
						Status:      1,
					}
					lastId, iErr := models.InsertYamlData(goe)
					if iErr != nil {
						logs.Error("db_models.InsertYamlData error:", iErr)
						tranErr = ormModel.Rollback()
						if tranErr != nil {
							logs.Error(" Rollback transaction error:", tranErr.Error())
						}
						continue
					}
					gpi := &models.GitPackageInfo{
						GitId:       lastId,
						PackageName: k,
						Version:     v["version"],
						OriginUrl:   v["url"],
						CreateTime:  now,
						UpdateTime:  now,
						Decription:  "",
						Status:      0,
					}
					iErr = db_models.InsertYamlDetailData(gpi, ormModel)
					if iErr != nil {
						logs.Error("db_models.InsertYamlDetailData:", iErr.Error())
						tranErr = ormModel.Rollback()
						if tranErr != nil {
							logs.Error(" Rollback transaction error:", tranErr.Error())
						}
						continue
					}
				} else {
					if rowsAffected > 1 {
						for _, pv := range packAgesData[1:] {
							yErr = db_models.DeleteYamlOpenEulerDetailData(pv.GitId, ormModel)
							if yErr != nil {
								logs.Error("db_models.DeleteYamlOpenEulerDetailData, error:", yErr.Error())
								tranErr = ormModel.Rollback()
								if tranErr != nil {
									logs.Error(" Rollback transaction error:", tranErr.Error())
								}
								continue
							}
							yErr = db_models.DeleteYamlOpenEulerData(pv.GitId, ormModel)
							if yErr != nil {
								logs.Error("db_models.DeleteYamlOpenEulerData, error:", yErr.Error())
								tranErr = ormModel.Rollback()
								if tranErr != nil {
									logs.Error(" Rollback transaction error:", tranErr.Error())
								}
								continue
							}
						}
					}
					goe := &models.GitOpenEuler{
						OriginUrl:   v["url"],
						UpdateTime:  now,
						CpePackName: v["cpeName"],
						Status:      1,
						PackageId:   packAgesData[0].PackageId,
						PackageName: k,
						Version:     v["version"],
					}
					yErr = models.UpdateYamlData(goe)
					if yErr != nil {
						logs.Error("db_models.UpdateYamlData, error:", yErr.Error())
						tranErr = ormModel.Rollback()
						if tranErr != nil {
							logs.Error(" Rollback transaction error:", tranErr.Error())
						}
						continue
					}
					gpi := &models.GitPackageInfo{
						PackageName: k,
						Version:     v["version"],
						OriginUrl:   v["url"],
						UpdateTime:  now,
						Status:      0,
						GitId:       packAgesData[0].GitId,
					}
					yErr = db_models.UpdateYamlDetailData(gpi, ormModel)
					if yErr != nil {
						logs.Error("db_models.UpdateYamlDetailData, error: ", yErr.Error())
						tranErr = ormModel.Rollback()
						if tranErr != nil {
							logs.Error(" Rollback transaction error:", tranErr.Error())
						}
						continue
					}
				}
				tranErr = ormModel.Commit()
				if tranErr != nil {
					logs.Error(" Commit transaction error:", tranErr.Error())
					continue
				}
				logs.Info("Transaction committed successfully", k)
			}
		}
		err = db_models.DeleteMindYamlOriginMark(ormModel)
		if err != nil {
			logs.Error("db_models.DeleteMindYamlOriginMark error:", err.Error())
		}
	} else {
		logs.Warning("yamlData Is empty, nothing can be done")
	}
}

// ProcOpenLookengYaml
//1. Create a folder;
//2. Download yaml;
//3. Parse yaml;
//4. Save in mysql;
func ProcMindSporeYaml() {
	ormModel := orm.NewOrm()
	yamlFileName, err := DownloadMindSporeYaml()
	if err != nil {
		logs.Error("DownloadMindSporeYaml error:", err.Error())
		return
	}
	yamlData, err := util.ParseYamlTypeTwo(yamlFileName)
	if err != nil {
		logs.Error("util.ParseYamlTypeTwo error: ", yamlFileName, err)
		return
	}
	StoreMindSporeYaml(yamlData, ormModel)

	DeleteYamlData(ormModel)
}

type miles struct {
	Id    int
	Title string
}

func getMilestone(owner, token, repo string) (data []miles, _ error) {
	url := fmt.Sprintf("https://gitee.com/api/v5/repos/%s/%s/milestones?access_token=%s&state=open&sort=due_on&page=1&per_page=100", owner, repo, token)

	do, err := http.Get(url)
	if err != nil {
		return nil, err
	}

	if do.StatusCode > 300 {
		return nil, nil
	}

	err = json.NewDecoder(do.Body).Decode(&data)
	return
}
