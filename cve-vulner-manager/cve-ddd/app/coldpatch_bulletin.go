package app

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/astaxie/beego"

	"cvevulner/cve-ddd/domain"
	"cvevulner/cve-ddd/domain/repository"
	"cvevulner/cve-ddd/infrastructure/obsimpl"
	"cvevulner/util"
)

const (
	EOF = "\r\n"

	fileIndex       = "index.txt"
	fileUpdateFixed = "update_fixed.txt"
)

var (
	regexpBulletin = regexp.MustCompile(`cvrf-openEuler-(\w+)-(\d{4})-(\d{4})\.xml`)
)

func (c *coldPatchService) GenerateBulletins(cveNum []string, date string) error {
	handleBranch, err := c.maJun.GetReleasedBranch()
	if err != nil {
		return fmt.Errorf("get release branch err: %w", err)
	}

	domain.InitMaintainVersion(handleBranch)

	cves, err := c.repo.FindCves(repository.Option{CveNum: cveNum})
	if err != nil {
		return fmt.Errorf("find cves failed: %w", err)
	}

	if len(cves) == 0 {
		return fmt.Errorf("no cves")
	}

	if err = c.testResult.Init(handleBranch, date); err != nil {
		return fmt.Errorf("init test result failed: %w", err)
	}

	// 用成功转测的数据进行过滤，只发布转测成功的cve
	testedCves := c.testResult.Filter(cves)

	indexContent, err := c.getIndexContent()
	if err != nil {
		return fmt.Errorf("get %s failed: %w", fileIndex, err)
	}

	maxId, err := c.parseColdPatchMaxIDFromIndex(indexContent)
	if err != nil {
		return fmt.Errorf("parse max id failed: %w", err)
	}

	uploadDir := c.generateUploadDir()

	bulletins := testedCves.GenerateBulletins()

	updateFixedFiles := c.handleColdPatchBulletins(bulletins, uploadDir, maxId)

	c.uploadIndexAndFixed(uploadDir, indexContent, updateFixedFiles)

	// set upload dirname of hotpatch
	obsimpl.SetDynamicDir(uploadDir)
	// process hot patch
	c.hotPatchAdapter.Process()

	return nil
}

func (c *coldPatchService) handleColdPatchBulletins(
	bulletins []domain.SecurityBulletin, uploadDir string, maxId int,
) []string {
	var updateFixedFiles []string

	for _, b := range bulletins {
		maxId++

		b.SetIdentificationOfColdPatch(maxId)

		b.ProductTree = c.testResult.GenerateProductTree(b.Component, b.AffectedVersion)

		xmlData, err1 := c.bulletin.GenerateColdPatch(&b)
		if err1 != nil {
			c.log.Errorf("generate cold patch %s failed: %v", b.Identification, err1)
			continue
		}

		path := uploadDir + b.CvrfFileName()
		if err1 = c.obs.Upload(path, xmlData); err1 != nil {
			c.log.Errorf("upload cold patch %s failed: %v", b.Identification, err1)
			continue
		}

		updateFixedFiles = append(updateFixedFiles, b.PathAppendToIndexFile())
	}

	return updateFixedFiles
}

func (c *coldPatchService) uploadIndexAndFixed(uploadDir, indexContent string, updateFixedFiles []string) {
	updateFixedContent := strings.TrimSpace(strings.Join(updateFixedFiles, EOF))
	newIndexContent := strings.TrimSpace(indexContent) + EOF + updateFixedContent

	indexPath := uploadDir + fileIndex
	updateFixedPath := uploadDir + fileUpdateFixed

	if err := c.obs.Upload(indexPath, []byte(newIndexContent)); err != nil {
		c.log.Errorf("upload %s failed: %v", fileIndex, err)
	}

	if err := c.obs.Upload(updateFixedPath, []byte(updateFixedContent)); err != nil {
		c.log.Errorf("upload %s failed: %v", fileUpdateFixed, err)
	}
}

func (c *coldPatchService) generateUploadDir() string {
	parentDir := beego.AppConfig.String("obs::upload_cvrf_dir")

	subDir := time.Now().Format("2006-01-02-15-04-05") + "-new/"

	return parentDir + subDir
}

func (c *coldPatchService) getIndexContent() (string, error) {
	cvrfdir := beego.AppConfig.String("obs::download_cvrf_dir")
	content, err := c.obs.Download(cvrfdir + fileIndex)

	return string(content), err
}

func (c *coldPatchService) parseColdPatchMaxIDFromIndex(content string) (int, error) {
	split := strings.Fields(content)
	for i := len(split) - 1; i >= 0; i-- {
		v := split[i]

		ret := regexpBulletin.FindStringSubmatch(v)
		if len(ret) != 4 {
			continue
		}

		if ret[1] != domain.BulletinTypeSA {
			continue
		}

		year, err := strconv.Atoi(ret[2])
		if err != nil {
			return 0, err
		}

		num, err := strconv.Atoi(ret[3])
		if err != nil {
			return 0, err
		}

		currentYear := util.Year()
		if year == currentYear {
			return num, nil
		}

		return 1000, nil
	}

	return 0, fmt.Errorf("not match in %s", fileIndex)
}
