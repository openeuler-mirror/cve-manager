package app

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/astaxie/beego"

	"cvevulner/cve-ddd/domain"
	"cvevulner/cve-ddd/domain/repository"
	"cvevulner/util"
)

const (
	EOF = "\r\n"

	fileIndex       = "index.txt"
	fileUpdateFixed = "update_fixed.txt"
)

var (
	regexpBulletin = regexp.MustCompile(`cvrf-openEuler-(\w+)-(\d{4})-(\d{4})\.xml`)
)

func (c *coldPatchService) GenerateBulletins(cveNum []string, date string) error {
	handleBranch, err := c.maJun.GetReleasedBranch()
	if err != nil {
		return fmt.Errorf("get release branch err: %w", err)
	}

	domain.InitMaintainVersion(handleBranch)

	cves, err := c.repo.FindCves(repository.Option{CveNum: cveNum})
	if err != nil {
		return fmt.Errorf("find cves failed: %w", err)
	}

	if len(cves) == 0 {
		return fmt.Errorf("no cves")
	}

	if err = c.testResult.Init(handleBranch, date); err != nil {
		return fmt.Errorf("init test result failed: %w", err)
	}

	// 用成功转测的数据进行过滤，只发布转测成功的cve
	testedCves := c.testResult.Filter(cves)

	indexContent, err := c.getIndexContent()
	if err != nil {
		return fmt.Errorf("get %s failed: %w", fileIndex, err)
	}

	maxColdPatchId, _, err := c.parseColdPatchMaxIDFromIndex(indexContent)
	if err != nil {
		return fmt.Errorf("parse max id failed: %w", err)
	}

	uploadDir := c.generateUploadDir()

	bulletins := testedCves.GenerateBulletins()

	updateFixedFiles := c.handleColdPatchBulletins(bulletins, uploadDir, maxColdPatchId)

	c.uploadIndexAndFixed(uploadDir, indexContent, updateFixedFiles)

	return nil
}

func (c *coldPatchService) handleColdPatchBulletins(
	bulletins []domain.SecurityBulletin, uploadDir string, maxId int,
) []string {
	var updateFixedFiles []string

	for _, b := range bulletins {
		maxId++

		b.SetIdentificationOfColdPatch(maxId)

		b.ProductTree = c.testResult.GenerateProductTree(b.Component, b.AffectedVersion)

		xmlData, err1 := c.bulletin.GenerateColdPatch(&b)
		if err1 != nil {
			c.log.Errorf("generate cold patch %s failed: %v", b.Identification, err1)
			continue
		}

		path := uploadDir + b.CvrfFileName()
		if err1 = c.obs.Upload(path, xmlData); err1 != nil {
			c.log.Errorf("upload cold patch %s failed: %v", b.Identification, err1)
			continue
		}

		updateFixedFiles = append(updateFixedFiles, b.PathAppendToIndexFile())
	}

	return updateFixedFiles
}

func (c *coldPatchService) uploadIndexAndFixed(uploadDir, indexContent string, updateFixedFiles []string) {
	updateFixedContent := strings.TrimSpace(strings.Join(updateFixedFiles, EOF))
	newIndexContent := strings.TrimSpace(indexContent) + EOF + updateFixedContent

	indexPath := uploadDir + fileIndex
	updateFixedPath := uploadDir + fileUpdateFixed

	if err := c.obs.Upload(indexPath, []byte(newIndexContent)); err != nil {
		c.log.Errorf("upload %s failed: %v", fileIndex, err)
	}

	if err := c.obs.Upload(updateFixedPath, []byte(updateFixedContent)); err != nil {
		c.log.Errorf("upload %s failed: %v", fileUpdateFixed, err)
	}
}

func (c *coldPatchService) generateUploadDir() string {
	parentDir := beego.AppConfig.String("obs::upload_cvrf_dir")

	subDir := time.Now().Format("2006-01-02-15-04-05") + "-new/"

	return parentDir + subDir
}

func (c *coldPatchService) getIndexContent() (string, error) {
	cvrfdir := beego.AppConfig.String("obs::download_cvrf_dir")
	content, err := c.obs.Download(cvrfdir + fileIndex)

	return string(content), err
}

func (c *coldPatchService) parseColdPatchMaxIDFromIndex(content string,
) (maxColdPatchId, maxHotPatchId int, err error) {
	split := strings.Fields(content)
	for i := len(split) - 1; i >= 0; i-- {
		v := split[i]

		ret := regexpBulletin.FindStringSubmatch(v)
		if len(ret) != 4 {
			continue
		}

		year, err1 := strconv.Atoi(ret[2])
		if err1 != nil {
			return 0, 0, err1
		}

		num, err1 := strconv.Atoi(ret[3])
		if err1 != nil {
			return 0, 0, err1
		}

		currentYear := util.Year()
		if year != currentYear {
			num = 1000
		}

		if ret[1] == domain.BulletinTypeSA {
			maxColdPatchId = num
		}

		if ret[1] == domain.BulletinTypeHotPatch {
			maxHotPatchId = num
		}

		if maxHotPatchId != 0 && maxColdPatchId != 0 {
			break
		}
	}

	if maxHotPatchId == 0 {
		maxHotPatchId = 1000
	}

	if maxColdPatchId == 0 {
		maxColdPatchId = 1000
	}

	return maxColdPatchId, maxHotPatchId, nil
}
