package app

import (
	"fmt"
	"strings"
	"time"

	"github.com/astaxie/beego"
	"github.com/sirupsen/logrus"

	"cvevulner/cve-ddd/domain"
	"cvevulner/cve-ddd/domain/bulletin"
	"cvevulner/cve-ddd/domain/hotpatch"
	"cvevulner/cve-ddd/domain/obs"
	"cvevulner/cve-ddd/domain/repository"
	"cvevulner/cve-ddd/domain/updateinfo"
)

const (
	fileHotPatch = "update_hot_patch.txt"
)

type RefactorHotPatchService interface {
	GenerateBulletins(string) error
}

func NewRefactorHotPatchService(
	r repository.CveRepository,
	b bulletin.Bulletin,
	o obs.OBS,
	u updateinfo.UpdateInfo,
	h hotpatch.HotPatch,
	l *logrus.Entry,
) *refactorHotPatchService {
	return &refactorHotPatchService{
		repository: r,
		bulletin:   b,
		obs:        o,
		updateInfo: u,
		hotPatch:   h,
		log:        l,
	}
}

type refactorHotPatchService struct {
	repository repository.CveRepository
	bulletin   bulletin.Bulletin
	obs        obs.OBS
	updateInfo updateinfo.UpdateInfo
	hotPatch   hotpatch.HotPatch

	log *logrus.Entry
}

func (h *refactorHotPatchService) GenerateBulletins(uploadDir string) error {
	issues, err := h.hotPatch.GetIssueInfo()
	if err != nil {
		return err
	}

	var cvesForUpdateInfo domain.Cves
	var uploadFileName []string

	indexContent, err := h.getIndexContent(uploadDir)
	if err != nil {
		return fmt.Errorf("get %s failed: %w", fileIndex, err)
	}

	maxHotPatchId, err := domain.ParseMaxIdFromIndexTxt(indexContent, domain.BulletinTypeHotPatch)
	if err != nil {
		return fmt.Errorf("parse max id failed: %w", err)
	}

	for _, issue := range issues {
		if exist := h.repository.IssueNumExist(issue.HotIssueNum); exist {
			h.log.Errorf("issue num %s exists", issue.HotIssueNum)
			continue
		}

		cves, err1 := h.repository.FindCves(
			repository.Option{
				CveNum:    issue.CveNum,
				Component: issue.Component,
			})
		if err1 != nil {
			h.log.Errorf("find cve %s, error %s", issue.CveNum, err.Error())
			return err
		}
		if len(cves) == 0 {
			h.log.Errorf("find cve %s nil", issue.CveNum)
			continue
		}
		// all cves have the same hot issue number
		for k := range cves {
			cves[k].HotIssueNum = issue.HotIssueNum
			cves[k].AffectedVersion = []string{issue.Branch}
			cves[k].Component = issue.Component
		}

		bulletins := cves.GenerateBulletins()
		for _, b := range bulletins {
			b.PatchUrl = issue.PatchUrl

			maxHotPatchId++
			b.SetIdentificationOfHotPatch(maxHotPatchId)

			xmlData, err2 := h.bulletin.GenerateHotPatch(&b)
			if err2 != nil {
				h.log.Errorf("component: %s, to xml error: %s", b.Component, err.Error())
				continue
			}

			path := uploadDir + b.CvrfFileName()
			if err2 = h.obs.Upload(path, xmlData); err2 != nil {
				h.log.Errorf("component: %s, upload to obs error: %s", b.Component, err.Error())

				continue
			}

			uploadFileName = append(uploadFileName, b.PathAppendToIndexFile())

			cvesForUpdateInfo = append(cvesForUpdateInfo, b.Cves...)
		}

		if err = h.repository.SaveIssueNum(issue.HotIssueNum); err != nil {
			h.log.Errorf("save issue num %s error %s", issue.HotIssueNum, err.Error())
		}
	}

	if len(uploadFileName) == 0 {
		return fmt.Errorf("no new hot patch issues")
	}

	h.uploadIndexAndHotPatch(uploadDir, indexContent, uploadFileName)

	return h.uploadUpdateInfo(cvesForUpdateInfo)
}

// getIndexContent 热补丁生成的公告文件要和冷补丁的公告文件名需上传同一个目录，追加到同一个index.txt文件下，
// 因此热补丁直接下载之前冷补丁逻辑修改后的index.txt文件
func (h *refactorHotPatchService) getIndexContent(uploadDir string) (string, error) {
	path := uploadDir + fileIndex
	content, err := h.obs.Download(path)

	return string(content), err
}

func (h *refactorHotPatchService) uploadIndexAndHotPatch(uploadDir, indexContent string, hotPatchFiles []string) {
	updateHotPatchContent := strings.TrimSpace(strings.Join(hotPatchFiles, EOF))
	newIndexContent := strings.TrimSpace(indexContent) + EOF + updateHotPatchContent

	indexPath := uploadDir + fileIndex
	updateFixedPath := uploadDir + fileHotPatch

	if err := h.obs.Upload(indexPath, []byte(newIndexContent)); err != nil {
		h.log.Errorf("upload %s failed: %v", fileIndex, err)
	}

	if err := h.obs.Upload(updateFixedPath, []byte(updateHotPatchContent)); err != nil {
		h.log.Errorf("upload %s failed: %v", fileHotPatch, err)
	}
}

func (h *refactorHotPatchService) uploadUpdateInfo(cves domain.Cves) error {
	if len(cves) == 0 {
		return nil
	}

	dir := beego.AppConfig.String("obs::upload_updateinfo_dir")
	nowStr := time.Now().Format("2006-01-02")

	for version, v := range cves.GroupByVersion() {
		bytes, err := h.updateInfo.Generate(v)
		if err != nil {
			h.log.Errorf("generate updateinfo of %s error %s", version, err.Error())
			continue
		}

		path := fmt.Sprintf("%s%s-%s/%s", dir, nowStr, "hotpatch", fmt.Sprintf("%s_updateinfo.xlsx", version))
		if err := h.obs.Upload(path, bytes); err != nil {
			h.log.Errorf("version: %s, upload to obs error: %s", version, err.Error())
			continue
		}
	}

	return nil
}
