package app

import (
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/sirupsen/logrus"

	"cvevulner/cve-ddd/domain"
	"cvevulner/cve-ddd/domain/bulletin"
	"cvevulner/cve-ddd/domain/obs"
	"cvevulner/cve-ddd/domain/repository"
	"cvevulner/cve-ddd/domain/updateinfo"
	"cvevulner/util"
)

const (
	indexFileName       = "index.txt"
	updateFixedFileName = "update_fixed.txt"
)

var updateTxt = []string{indexFileName, updateFixedFileName}

type HotPatchService interface {
	GenerateBulletins([]CmdToGenerateBulletins) error
}

func NewHotPatchService(r repository.CveRepository, b bulletin.Bulletin, o obs.OBS, u updateinfo.UpdateInfo,
) *hotPatchService {
	return &hotPatchService{
		repository: r,
		bulletin:   b,
		obs:        o,
		updateInfo: u,
	}
}

type hotPatchService struct {
	repository repository.CveRepository
	bulletin   bulletin.Bulletin
	obs        obs.OBS
	updateInfo updateinfo.UpdateInfo
}

func (h *hotPatchService) GenerateBulletins(cmds []CmdToGenerateBulletins) error {
	var cvesForUpdateInfo domain.Cves
	var uploadFileName []string

	for _, cmd := range cmds {
		if exist := h.repository.IssueNumExist(cmd.HotIssueNum); exist {
			continue
		}

		cves, err := h.repository.FindCves(
			repository.Option{
				CveNum:          cmd.CveNum,
				Component:       cmd.Component,
				AffectedVersion: cmd.Branch,
			})
		if err != nil {
			logrus.Errorf("find cve %s, error %s", cmd.CveNum, err.Error())
			return err
		}
		if len(cves) == 0 {
			logrus.Errorf("find cve %s nil", cmd.CveNum)
			continue
		}
		// all cves have the same hot issue number
		for k := range cves {
			cves[k].HotIssueNum = cmd.HotIssueNum
		}

		bulletins := cves.GenerateBulletins()
		for _, b := range bulletins {
			b.PatchUrl = cmd.PatchUrl

			id, err := h.generateBulletinId()
			if err != nil {
				return err
			}
			b.Identification = id

			xmlData, err := h.bulletin.Generate(&b)
			if err != nil {
				logrus.Errorf("component: %s, to xml error: %s", b.Component, err.Error())

				continue
			}

			fileName := fmt.Sprintf("cvrf-%s.xml", b.Identification)
			if err := h.obs.UploadToDynamicDir(fileName, xmlData); err != nil {
				logrus.Errorf("component: %s, upload to obs error: %s", b.Component, err.Error())

				continue
			}

			uploadFileName = append(uploadFileName, fileName)

			cvesForUpdateInfo = append(cvesForUpdateInfo, b.Cves...)

			if err := h.repository.SetMaxBulletinID(b.Identification); err != nil {
				logrus.Errorf("set max bulletin id %s error %s", b.Identification, err.Error())
			}
		}

		if err := h.repository.SaveIssueNum(cmd.HotIssueNum); err != nil {
			logrus.Errorf("save issue num %s error %s", cmd.HotIssueNum, err.Error())
		}
	}

	h.appendHotPatchToIndex(uploadFileName)

	return h.uploadUpdateInfo(cvesForUpdateInfo)
}

func (h *hotPatchService) generateBulletinId() (string, error) {
	bulletinNumFormat := "openEuler-HotPatchSA-%d-%d"

	maxID, err := h.repository.MaxBulletinID()
	if err != nil {
		return "", err
	}

	thisYear := util.Year()

	if maxID == "" {
		return fmt.Sprintf(bulletinNumFormat, thisYear, 1001), nil
	}

	split := strings.Split(maxID, "-")
	if split[2] != strconv.Itoa(thisYear) {
		return fmt.Sprintf(bulletinNumFormat, thisYear, 1001), nil
	}

	num, err := strconv.Atoi(split[3])
	if err != nil {
		return "", err
	}

	return fmt.Sprintf(bulletinNumFormat, thisYear, num+1), nil
}

func (h *hotPatchService) uploadUpdateInfo(cves domain.Cves) error {
	if len(cves) == 0 {
		return nil
	}

	for version, v := range cves.GroupByVersion() {
		bytes, err := h.updateInfo.Generate(v)
		if err != nil {
			logrus.Errorf("generate updateinfo of %s error %s", version, err.Error())
			continue
		}

		fileName := fmt.Sprintf("%s_updateinfo.xlsx", version)
		if err := h.obs.UploadUpdateInfo(fileName, bytes); err != nil {
			logrus.Errorf("version: %s, upload to obs error: %s", version, err.Error())

			continue
		}
	}

	return nil
}

func (h *hotPatchService) appendHotPatchToIndex(files []string) {
	if len(files) == 0 {
		return
	}

	var appendContent string
	for _, v := range files {
		appendContent += fmt.Sprintf("\n%d/%s", time.Now().Year(), v)
	}

	for _, v := range updateTxt {
		content, err := h.obs.DownloadFromDynamicDir(v)
		if err != nil {
			logrus.Errorf("download %s error: %s", v, err.Error())
			continue
		}

		content = append(content, appendContent...)

		if err = h.obs.UploadToDynamicDir(v, content); err != nil {
			logrus.Errorf("upload %s error: %s", v, err.Error())
		}
	}
}
