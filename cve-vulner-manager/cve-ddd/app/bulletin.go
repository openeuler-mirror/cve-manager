package app

import (
	"fmt"
	"strings"
	"time"

	"github.com/astaxie/beego"
	"github.com/sirupsen/logrus"

	"cvevulner/cve-ddd/domain"
	"cvevulner/cve-ddd/domain/bulletin"
	"cvevulner/cve-ddd/domain/majun"
	"cvevulner/cve-ddd/domain/obs"
	"cvevulner/cve-ddd/domain/repository"
	"cvevulner/cve-ddd/domain/testresult"
)

const (
	EOF = "\r\n"

	fileIndex       = "index.txt"
	fileUpdateFixed = "update_fixed.txt"
)

type BulletinService interface {
	GenerateBulletins([]string, string) (string, error)
}

func NewBulletinService(
	o obs.OBS,
	r repository.CveRepository,
	m majun.Majun,
	b bulletin.Bulletin,
	t testresult.Result,
	l *logrus.Entry,
) *bulletinService {
	return &bulletinService{
		obs:        o,
		repo:       r,
		maJun:      m,
		bulletin:   b,
		testResult: t,
		log:        l,
	}
}

type bulletinService struct {
	obs        obs.OBS
	repo       repository.CveRepository
	maJun      majun.Majun
	bulletin   bulletin.Bulletin
	testResult testresult.Result

	log *logrus.Entry
}

func (b *bulletinService) GenerateBulletins(cveNum []string, date string) (string, error) {
	handleBranch, err := b.maJun.GetReleasedBranch()
	if err != nil {
		return "", fmt.Errorf("get release branch err: %w", err)
	}

	domain.InitMaintainVersion(handleBranch)

	cves, err := b.repo.FindCves(repository.Option{CveNum: cveNum})
	if err != nil {
		return "", fmt.Errorf("find cves failed: %w", err)
	}

	if len(cves) == 0 {
		return "", fmt.Errorf("no cves")
	}

	b.testResult.Init(handleBranch, date)

	// 用成功转测的数据进行过滤，只发布转测成功的cve
	testedCves := b.testResult.Filter(cves)

	indexContent, err := b.getIndexContent()
	if err != nil {
		return "", fmt.Errorf("get %s failed: %w", fileIndex, err)
	}

	maxColdPatchId, err := domain.ParseMaxIdFromIndexTxt(indexContent, domain.BulletinTypeSA)
	if err != nil {
		return "", fmt.Errorf("parse max id failed: %w", err)
	}

	uploadDir := b.generateUploadDir()

	bulletins := testedCves.GenerateBulletins()

	var updateFixedFiles []string

	for _, v := range bulletins {
		maxColdPatchId++

		v.SetIdentificationOfColdPatch(maxColdPatchId)

		v.ProductTree = b.testResult.GenerateProductTree(v.Component, v.AffectedVersion)

		xmlData, err1 := b.bulletin.GenerateColdPatch(&v)
		if err1 != nil {
			b.log.Errorf("generate cold patch %s failed: %v", v.Identification, err1)
			continue
		}

		path := uploadDir + v.CvrfFileName()
		if err1 = b.obs.Upload(path, xmlData); err1 != nil {
			b.log.Errorf("upload cold patch %s failed: %v", v.Identification, err1)
			continue
		}

		updateFixedFiles = append(updateFixedFiles, v.PathAppendToIndexFile())
	}

	b.uploadIndexAndFixed(uploadDir, indexContent, updateFixedFiles)

	return uploadDir, nil
}

func (b *bulletinService) uploadIndexAndFixed(uploadDir, indexContent string, updateFixedFiles []string) {
	updateFixedContent := strings.TrimSpace(strings.Join(updateFixedFiles, EOF))
	newIndexContent := strings.TrimSpace(indexContent) + EOF + updateFixedContent

	indexPath := uploadDir + fileIndex
	updateFixedPath := uploadDir + fileUpdateFixed

	if err := b.obs.Upload(indexPath, []byte(newIndexContent)); err != nil {
		b.log.Errorf("upload %s failed: %v", fileIndex, err)
	}

	if err := b.obs.Upload(updateFixedPath, []byte(updateFixedContent)); err != nil {
		b.log.Errorf("upload %s failed: %v", fileUpdateFixed, err)
	}
}

func (b *bulletinService) generateUploadDir() string {
	parentDir := beego.AppConfig.String("obs::upload_cvrf_dir")

	subDir := time.Now().Format("2006-01-02-15-04-05") + "-new/"

	return parentDir + subDir
}

func (b *bulletinService) getIndexContent() (string, error) {
	cvrfdir := beego.AppConfig.String("obs::download_cvrf_dir")
	content, err := b.obs.Download(cvrfdir + fileIndex)

	return string(content), err
}
