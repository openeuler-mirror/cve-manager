package testresultimpl

import (
	"bytes"
	"encoding/csv"
	"fmt"
	"io"
	"net/http"
	"strings"

	"github.com/opensourceways/server-common-lib/utils"
	"github.com/sirupsen/logrus"

	"cvevulner/cve-ddd/domain"
)

func NewTestResultImpl(log *logrus.Entry) *testResultImpl {
	return &testResultImpl{
		log:    log,
		client: utils.NewHttpClient(3),
	}
}

type testResultImpl struct {
	log    *logrus.Entry
	client utils.HttpClient

	// map[branch]map[component][]rpm
	resultCache map[string]map[string][]string
}

func (impl *testResultImpl) Init(handleBranch []string, date string) error {
	impl.resultCache = make(map[string]map[string][]string)

	for _, b := range handleBranch {
		url := fmt.Sprintf("http://121.36.84.172/repo.openeuler.org/%s/%s/xxx.csv", b, date)

		req, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return err
		}

		content, _, err := impl.client.Download(req)
		if err != nil {
			impl.log.Errorf("download test result of %s failed: %v", b, err)
			continue // 有的分支可能没有转测，请求肯定为404，只能直接跳过了
		}

		impl.resultCache[b] = impl.parseContent(content)
	}

	return nil
}

func (impl *testResultImpl) Filter(cves domain.Cves) domain.Cves {
	var filtered domain.Cves

	for _, cve := range cves {
		var filteredVersion []string
		for _, av := range cve.AffectedVersion {
			if _, ok := impl.resultCache[av][cve.Component]; ok {
				filteredVersion = append(filteredVersion, av) // 在转测数据对应的分支能找到对应的包，该cve的该分支才能发布公告
			}
		}

		if len(filteredVersion) == 0 {
			continue // 过滤后的受影响分支为空，整个cve都不用发布公告了
		}

		cve.AffectedVersion = filteredVersion
		filtered = append(filtered, cve)
	}

	return filtered
}

func (impl *testResultImpl) GenerateProductTree(component string, affectedVersion []string) domain.ProductTree {
	var tree domain.ProductTree

	for _, version := range affectedVersion {
		rpms := impl.resultCache[version][component] // 生成公告前已经过滤一次了，所以组件和影响分支必定存在

		for _, rpm := range rpms {
			// example of rpm: zbar-0.22-4.oe2203.src.rpm
			t := strings.Split(rpm, ".")
			arch := t[len(t)-2]
			productId := strings.Join(t[:len(t)-3], ".")

			product := domain.Product{
				ID:       productId,
				CPE:      version,
				FullName: rpm,
			}

			tree[arch] = append(tree[arch], product)
		}
	}

	return tree
}

func (impl *testResultImpl) parseContent(content []byte) map[string][]string {
	buff := bytes.NewBuffer(content)
	r := csv.NewReader(buff)

	componentAndRpm := make(map[string][]string)
	for {
		line, err := r.Read()
		if err == io.EOF {
			break
		}

		if err != nil {
			continue
		}

		splitRpm := strings.Fields(line[1])
		if len(splitRpm) == 0 {
			continue
		}

		componentAndRpm[line[0]] = splitRpm
	}

	return componentAndRpm
}
