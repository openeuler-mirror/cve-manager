package testresultimpl

import (
	"bytes"
	"encoding/csv"
	"fmt"
	"io"
	"net/http"
	"strings"

	"github.com/opensourceways/server-common-lib/utils"
	"github.com/sirupsen/logrus"

	"cvevulner/cve-ddd/domain"
)

const (
	epolBranch = "openEuler-22.03-LTS-SP1"
)

func NewTestResultImpl(log *logrus.Entry) *testResultImpl {
	return &testResultImpl{
		log:    log,
		client: utils.NewHttpClient(3),
	}
}

type testResultImpl struct {
	log    *logrus.Entry
	client utils.HttpClient

	// map[branch]map[component][]rpm
	resultCache map[string]map[string][]rpm
}

type rpm struct {
	Name   string
	IsEpol bool
}

func (impl *testResultImpl) getCsvOfRpmByBranch(branch, date string) []byte {
	url := fmt.Sprintf("http://121.36.84.172/repo.openeuler.org/%s/%s/%s.csv", branch, date, branch)

	req, _ := http.NewRequest(http.MethodGet, url, nil)

	content, _, err := impl.client.Download(req)
	if err != nil {
		// 可能有些分支没有转测，所以出错后记录日志即可
		impl.log.Errorf("get csv rpm of [%s %s] failed: %s", branch, date, err.Error())
	}

	return content
}

func (impl *testResultImpl) getCsvOfRpmInEpolByBranch(branch, date string) []byte {
	epolUrl := fmt.Sprintf("http://121.36.84.172/repo.openeuler.org/%s/EPOL/%s/main/%s.csv", branch, date, branch)

	req, _ := http.NewRequest(http.MethodGet, epolUrl, nil)

	content, _, err := impl.client.Download(req)
	if err != nil {
		impl.log.Errorf("get epol csv rpm of [%s %s] failed: %s", branch, date, err.Error())
	}

	return content
}

func (impl *testResultImpl) Init(handleBranch []string, date string) {
	impl.resultCache = make(map[string]map[string][]rpm)

	for _, b := range handleBranch {
		var cacheNormal, cacheEpol map[string][]rpm

		content := impl.getCsvOfRpmByBranch(b, date)
		cacheNormal = impl.parseContent(content, false)

		// 该分支特殊，csv分别在两处目录，需要额外处理，将两处的内容合并
		if b == epolBranch {
			epolContent := impl.getCsvOfRpmInEpolByBranch(b, date)
			cacheEpol = impl.parseContent(epolContent, true)
		}

		cacheMerged := impl.mergeCache(cacheNormal, cacheEpol)
		if len(cacheMerged) == 0 {
			continue
		}

		impl.resultCache[b] = cacheMerged
	}
}

func (impl *testResultImpl) mergeCache(source ...map[string][]rpm) map[string][]rpm {
	target := make(map[string][]rpm)
	for _, m := range source {
		for k, v := range m {
			target[k] = append(target[k], v...)
		}
	}

	return target

}

func (impl *testResultImpl) Filter(cves domain.Cves) domain.Cves {
	var filtered domain.Cves

	for _, cve := range cves {
		var filteredVersion []string
		for _, av := range cve.AffectedVersion {
			if _, ok := impl.resultCache[av][cve.Component]; ok {
				filteredVersion = append(filteredVersion, av) // 在转测数据对应的分支能找到对应的包，该cve的该分支才能发布公告
			}
		}

		if len(filteredVersion) == 0 {
			continue // 过滤后的受影响分支为空，整个cve都不用发布公告了
		}

		cve.AffectedVersion = filteredVersion
		filtered = append(filtered, cve)
	}

	return filtered
}

func (impl *testResultImpl) GenerateProductTree(component string, affectedVersion []string) domain.ProductTree {
	tree := make(domain.ProductTree)

	for _, version := range affectedVersion {
		rpms := impl.resultCache[version][component] // 生成公告前已经过滤一次了，所以组件和影响分支必定存在

		for _, v := range rpms {
			// example of rpm: zbar-0.22-4.oe2203.src.rpm
			t := strings.Split(v.Name, ".")
			arch := t[len(t)-2]
			productId := strings.Join(t[:len(t)-3], ".")

			product := domain.Product{
				ID:       productId,
				CPE:      version,
				FullName: v.Name,
				IsEpol:   v.IsEpol,
			}

			tree[arch] = append(tree[arch], product)
		}
	}

	return tree
}

func (impl *testResultImpl) parseContent(content []byte, fromEpol bool) map[string][]rpm {
	buff := bytes.NewBuffer(content)
	r := csv.NewReader(buff)

	componentAndRpm := make(map[string][]rpm)
	for {
		line, err := r.Read()
		if err == io.EOF {
			break
		}

		if err != nil {
			continue
		}

		splitRpm := strings.Fields(line[1])
		if len(splitRpm) == 0 {
			continue
		}

		var t []rpm
		for _, v := range splitRpm {
			t = append(t, rpm{Name: v, IsEpol: fromEpol})
		}

		componentAndRpm[line[0]] = t
	}

	return componentAndRpm
}
