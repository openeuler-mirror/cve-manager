package repositoryimpl

import (
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/astaxie/beego/orm"

	"cvevulner/cve-ddd/domain"
	"cvevulner/cve-ddd/domain/repository"
	"cvevulner/models"
)

func NewRepositoryImpl() repositoryImpl {
	return repositoryImpl{}
}

type repositoryImpl struct {
}

func (impl repositoryImpl) FindCves(opt repository.Option) (cves domain.Cves, err error) {
	var data []CveInfo

	sql := `select a.cve_num,a.cve_version,b.openeuler_score,b.openeuler_vector,
       b.owned_component, b.cve_brief, b.cve_level, b.affected_version,
       c.introduction, c.summary, c.description, c.affect_product, c.reference_link,c.theme
from cve_vuln_center a
join cve_issue_template b on a.cve_id=b.cve_id
join cve_security_notice c on a.cve_id=c.cve_id
where a.cve_num in (%s) and a.organizate_id = 1 and a.pack_name = "%s" 
`
	o := orm.NewOrm()
	cveStr := "\"" + strings.Join(opt.CveNum, "\",\"") + "\""
	if _, err = o.Raw(fmt.Sprintf(sql, cveStr, opt.Component)).QueryRows(&data); err != nil {
		return
	}

	for _, v := range data {
		cve := domain.Cve{
			Component:       opt.Component,
			Description:     v.Description,
			SeverityLevel:   v.CveLevel,
			AffectedVersion: []string{opt.AffectedVersion},
			AffectedProduct: v.AffectProduct,
			OpeneulerScore:  v.OpeneulerScore,
			Theme:           v.Theme,
			CveNum:          v.CveNum,
			CveBrief:        v.CveBrief,
			OpeneulerVector: v.OpeneulerVector,
			CveVersion:      v.CveVersion,
		}

		cves = append(cves, cve)
	}

	return
}

func (impl repositoryImpl) MaxBulletinID() (string, error) {
	var hotPatch models.HotPatch

	o := orm.NewOrm()
	err := o.QueryTable(&hotPatch).Filter("type", 2).One(&hotPatch)
	if errors.Is(err, orm.ErrNoRows) {
		return "", nil
	}

	if err != nil {
		return "", err
	}

	return hotPatch.MaxID, nil
}

func (impl repositoryImpl) SetMaxBulletinID(id string) error {
	hotPatch := models.HotPatch{
		Type: 2,
	}
	now := time.Now().Format(time.RFC3339)

	o := orm.NewOrm()
	err := o.Read(&hotPatch, "type")
	if errors.Is(err, orm.ErrNoRows) {
		hotPatch.MaxID = id
		hotPatch.CreateTime = now
		hotPatch.UpdateTime = now

		_, err := o.Insert(&hotPatch)

		return err

	} else if err == nil {
		hotPatch.MaxID = id
		hotPatch.UpdateTime = now
		_, err := o.Update(&hotPatch)

		return err
	}

	return err
}

func (impl repositoryImpl) IssueNumExist(num string) bool {
	hotPatch := models.HotPatch{
		Type:     1,
		IssueNum: num,
	}

	o := orm.NewOrm()
	if err := o.Read(&hotPatch, "type", "issue_num"); err != nil {
		return false
	}

	return true
}

func (impl repositoryImpl) SaveIssueNum(num string) error {
	now := time.Now().Format(time.RFC3339)

	hotPatch := models.HotPatch{
		Type:       1,
		IssueNum:   num,
		CreateTime: now,
		UpdateTime: now,
	}

	o := orm.NewOrm()
	_, err := o.Insert(&hotPatch)

	return err
}
