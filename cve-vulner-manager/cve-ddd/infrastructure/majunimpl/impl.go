package majunimpl

import (
	"bytes"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"errors"
	"net/http"
	"strconv"
	"time"

	"github.com/astaxie/beego"
	"github.com/opensourceways/server-common-lib/utils"

	"cvevulner/cve-ddd/domain"
)

const (
	urlReleaseVersion  = "https://majun.osinfra.cn/majun-platform-release/publish/externalinterface/queryReleaseVersion"
	urlCollectCallback = "https://majun.osinfra.cn/majun-platform-release/publish/externalinterface/saveCveCallbackResult"
)

type config struct {
	AppId     string
	SecretKey string
}

func NewMajunImpl() *majunImpl {
	return &majunImpl{
		cfg: config{
			AppId:     beego.AppConfig.String("majun::app_id"),
			SecretKey: beego.AppConfig.String("majun::secret_key"),
		},
		client: utils.NewHttpClient(3),
	}
}

type majunImpl struct {
	cfg    config
	client utils.HttpClient
}

type releaseResponse struct {
	Code    int      `json:"code"`
	Message string   `json:"message"`
	Result  []string `json:"result"`
}

func (impl *majunImpl) GetReleasedBranch() ([]string, error) {
	//req, err := impl.generateRequest(urlReleaseVersion, nil)
	//if err != nil {
	//	return nil, err
	//}
	//
	//var v releaseResponse
	//_, err = impl.client.ForwardTo(req, &v)
	//if err != nil {
	//	return nil, err
	//}
	//
	//if v.Code != http.StatusOK {
	//	return nil, errors.New(v.Message)
	//}
	//
	//return v.Result, nil

	return []string{
		"openEuler-20.03-LTS-SP1",
		"openEuler-20.03-LTS-SP4",
		"openEuler-22.03-LTS",
		"openEuler-22.03-LTS-SP1",
		"openEuler-22.03-LTS-SP2",
		"openEuler-22.03-LTS-SP3",
	}, nil
}

type callbackBody struct {
	Code int                  `json:"code"`
	Id   string               `json:"id"`
	Msg  string               `json:"msg"`
	Data []domain.CallbackDTO `json:"data"`
}

func (impl *majunImpl) CollectCallback(id, data string) error {
	var dataDTO []domain.CallbackDTO
	err := json.Unmarshal([]byte(data), &dataDTO)
	if err != nil {
		return err
	}

	body := callbackBody{
		Code: 200,
		Id:   id,
		Msg:  "success",
		Data: dataDTO,
	}

	payload, err := json.Marshal(body)
	if err != nil {
		return err
	}

	req, err := impl.generateRequest(urlCollectCallback, payload)
	if err != nil {
		return err
	}

	var v releaseResponse
	_, err = impl.client.ForwardTo(req, &v)
	if err != nil {
		return err
	}

	if v.Code != http.StatusOK {
		return errors.New(v.Message)
	}

	return nil
}

func (impl *majunImpl) generateRequest(url string, body []byte) (*http.Request, error) {
	timestamp := strconv.FormatInt(time.Now().UnixMilli(), 10)
	sign := impl.sign(timestamp)

	var payload *bytes.Buffer
	if len(body) != 0 {
		payload = bytes.NewBuffer(body)
	}

	req, err := http.NewRequest(http.MethodPost, url, payload)
	if err != nil {
		return nil, err
	}

	req.Header.Set("timestamp", timestamp)
	req.Header.Set("appId", impl.cfg.AppId)
	req.Header.Set("sign", sign)

	return req, nil
}

func (impl *majunImpl) sign(timestamp string) string {
	msg := impl.cfg.AppId + timestamp

	mac := hmac.New(sha256.New, []byte(impl.cfg.SecretKey))
	_, _ = mac.Write([]byte(msg))

	return base64.StdEncoding.EncodeToString(mac.Sum(nil))
}
