package util

import (
	"fmt"
	"math"
	"strings"

	"github.com/astaxie/beego"
)

const (
	defaultBaseScore     = 0
	unChangedScope       = "SU"
	changedScope         = "SC"
	maxScore             = 10
	baseFactor           = 1.08
	unchangeImpactFactor = 6.42
	changeImpactFactor1  = 7.52
	changeImpactFactor2  = 0.029
	changeImpactFactor3  = 3.25
	changeImpactFactor4  = 0.02
	changeImpactFactor5  = 15
	iscFactor            = 1
	exFactor             = 8.22
)

// Calculate CVSS v3 basescore based on vector
func CalculateCVSSV3BaseScore(vector string) float64 {
	vectors := strings.Split(vector, "/")
	var dealVectors []string
	for _, v := range vectors {
		dv := strings.ReplaceAll(v, ":", "")
		dealVectors = append(dealVectors, dv)
	}

	scope := dealVectors[4]

	avScore := beego.AppConfig.DefaultFloat(fmt.Sprintf("metrics::%s", dealVectors[0]), defaultBaseScore)

	acScore := beego.AppConfig.DefaultFloat(fmt.Sprintf("metrics::%s", dealVectors[1]), defaultBaseScore)

	uiScore := beego.AppConfig.DefaultFloat(fmt.Sprintf("metrics::%s", dealVectors[3]), defaultBaseScore)

	cScore := beego.AppConfig.DefaultFloat(fmt.Sprintf("metrics::%s", dealVectors[5]), defaultBaseScore)

	iScore := beego.AppConfig.DefaultFloat(fmt.Sprintf("metrics::%s", dealVectors[6]), defaultBaseScore)

	aScore := beego.AppConfig.DefaultFloat(fmt.Sprintf("metrics::%s", dealVectors[7]), defaultBaseScore)

	iscBase := iscFactor - ((iscFactor - cScore) * (1 - iScore) * (1 - aScore))

	if scope == unChangedScope {
		prScore := beego.AppConfig.DefaultFloat(fmt.Sprintf("unchangedpr::%s", dealVectors[2]), defaultBaseScore)
		exploitabilitySubScore := exFactor * avScore * acScore * prScore * uiScore
		impactSubScore := unchangeImpactFactor * iscBase
		if impactSubScore <= 0 {
			return defaultBaseScore
		}

		miniNum := Minimum(exploitabilitySubScore+impactSubScore, maxScore)

		baseScore := Roundup(miniNum)

		return baseScore
	} else if scope == changedScope {
		prScore := beego.AppConfig.DefaultFloat(fmt.Sprintf("changedpr::%s", dealVectors[2]), defaultBaseScore)
		exploitabilitySubScore := exFactor * avScore * acScore * prScore * uiScore

		res := math.Pow(iscBase-changeImpactFactor4, float64(changeImpactFactor5))
		imapctSubScore := changeImpactFactor1*(iscBase-changeImpactFactor2) - changeImpactFactor3*res
		if imapctSubScore <= 0 {
			return defaultBaseScore
		}

		miniNum := Minimum(baseFactor*(exploitabilitySubScore+imapctSubScore), maxScore)

		baseScore := Roundup(miniNum)

		return baseScore
	}

	return defaultBaseScore
}

func Roundup(value float64) float64 {
	roundedValue := math.Ceil(value*10) / 10
	return roundedValue
}

func Minimum(a, b float64) float64 {
	if a < b {
		return a
	}
	return b
}
